"use strict";(globalThis.webpackChunkconvengine_docs=globalThis.webpackChunkconvengine_docs||[]).push([[958],{5420(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"deep-dive/pipeline-steps","title":"Pipeline & Steps","description":"<DbTable","source":"@site/docs/v2/deep-dive/pipeline-steps.mdx","sourceDirName":"deep-dive","slug":"/deep-dive/pipeline-steps","permalink":"/docs/v2/deep-dive/pipeline-steps","draft":false,"unlisted":false,"editUrl":"https://github.com/salilvnair/convengine-docs/tree/main/docs/v2/deep-dive/pipeline-steps.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Pipeline & Steps","sidebar_position":7},"sidebar":"docSidebar","previous":{"title":"File Map","permalink":"/docs/v2/deep-dive/file-map"},"next":{"title":"Intent & Schema","permalink":"/docs/v2/deep-dive/intent-and-schema"}}');var i=t(4848),o=t(8453),a=t(7555);const r={title:"Pipeline & Steps",sidebar_position:7},l="Pipeline Steps (what each step does)",c={},d=[{value:"Supported Dialogue Acts",id:"supported-dialogue-acts",level:3},{value:"Source Execution Profile",id:"source-execution-profile",level:3},{value:"Why <code>POST_DIALOGUE_ACT</code> exists",id:"why-post_dialogue_act-exists",level:3}];function u(e){const n={admonition:"admonition",br:"br",code:"code",h1:"h1",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"pipeline-steps-what-each-step-does",children:"Pipeline Steps (what each step does)"})}),"\n",(0,i.jsx)(a.p,{title:"Step responsibilities",columns:["Step","Primary responsibility","Main session mutations","Config/table dependencies"],rows:[["LoadOrCreateConversationStep","Fetch or bootstrap conversation row","conversation, intent/state/context sync","ce_conversation"],["CacheInspectAuditStep","Conditionally audit cache snapshot","none","convengine.audit.cache-inspector property"],["ResetConversationStep","Early explicit reset","intent/state/context/input params reset","input flags, command text"],["PersistConversationBootstrapStep","Ensure conversation row persisted","none/metadata","ce_conversation"],["AuditUserInputStep","Persist user input audit","none","ce_audit"],["PolicyEnforcementStep","Policy block and stop","payload + stop result on block","ce_policy"],["DialogueActStep","Classify user turn action type","dialogue_act, dialogue_act_confidence, standalone_query, resolved_user_input","ce_config (dialogue act mode), ce_audit"],["InteractionPolicyStep","Decide runtime policy before intent","policy_decision, skip_intent_resolution","ce_config, session pending state"],["CorrectionStep","Route confirmation turns and apply in-place correction patches","routing_decision, skip_schema_extraction, correction_applied","ce_output_schema, session context, ce_audit"],["ActionLifecycleStep","Maintain pending action runtime TTL/status","pending_action_runtime context","ce_pending_action, ce_audit"],["DisambiguationStep","Ask question when multiple actions fit","pending_clarification question/context","ce_pending_action, ce_config, ce_audit"],["GuardrailStep","Apply guardrails and approval rules","guardrail flags/sanitized text","ce_config, ce_audit"],["IntentResolutionStep","Resolve intent with classifier+agent","intent/state/clarification fields","ce_intent, ce_intent_classifier, ce_config"],["ResetResolvedIntentStep","Reset on configured reset intent","full reset","ce_config RESET_INTENT_CODES"],["FallbackIntentStateStep","Fill missing intent/state defaults","intent/state","none"],["AddContainerDataStep","Fetch and attach container data","containerData/context merge","ce_container_config"],["PendingActionStep","Execute/reject pending action task","pending_action_runtime status/result","ce_pending_action, CeTaskExecutor, ce_audit"],["ToolOrchestrationStep","Run tool_group based orchestration","tool_request/tool_result fields","ce_tool, ce_mcp_tool, ce_audit"],["McpToolStep","MCP planner/tool loop","context_json.mcp.*, mcp tool metadata","ce_mcp_tool, ce_mcp_db_tool, ce_mcp_planner (fallback ce_config)"],["SchemaExtractionStep","Schema-driven extraction and lock handling","schema facts/context/lock, POST_SCHEMA_EXTRACTION facts","ce_output_schema, ce_prompt_template"],["AutoAdvanceStep","Compute schema status facts","schemaComplete/hasAny","resolved schema + context"],["RulesStep","Match and apply transitions/actions","intent/state/input params","ce_rule"],["StateGraphStep","Validate state transition path","state_graph_valid/reason","ce_state_graph, ce_audit"],["ResponseResolutionStep","Resolve and generate output payload","payload/last assistant json","ce_response, ce_prompt_template"],["MemoryStep","Write memory/session summary","memory.session_summary in context","ce_memory, ce_audit"],["PersistConversationStep","Persist final conversation and result","finalResult","ce_conversation"],["PipelineEndGuardStep","Timing audit + terminal guard","timings","ce_audit"]]}),"\n",(0,i.jsx)(n.admonition,{title:"Hook where you need precision",type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Before schema extraction: normalize inputs"}),"\n",(0,i.jsx)(n.li,{children:"After rules: inspect intent/state transition correctness"}),"\n",(0,i.jsx)(n.li,{children:"Before response resolution: inject display hints"}),"\n"]})}),"\n",(0,i.jsx)(a.f4,{type:"info",title:"Rule phases",children:(0,i.jsxs)(n.p,{children:["Rules execute by phase. Available native phases include ",(0,i.jsx)(n.code,{children:"PRE_RESPONSE_RESOLUTION"}),", ",(0,i.jsx)(n.code,{children:"POST_AGENT_INTENT"}),", ",(0,i.jsx)(n.code,{children:"POST_SCHEMA_EXTRACTION"}),", ",(0,i.jsx)(n.code,{children:"PRE_AGENT_MCP"}),", ",(0,i.jsx)(n.code,{children:"POST_AGENT_MCP"}),", and ",(0,i.jsx)(n.code,{children:"POST_TOOL_EXECUTION"}),"."]})}),"\n",(0,i.jsx)(a.f4,{type:"warning",title:"Don\u2019t hardcode transitions in steps",children:(0,i.jsxs)(n.p,{children:["Prefer transitions in ",(0,i.jsx)(n.code,{children:"ce_rule"})," unless absolutely framework-level behavior is required. This keeps domain behavior data-driven and testable via audit traces."]})}),"\n",(0,i.jsxs)(a.f4,{type:"info",title:"Prompt-template interaction metadata",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ce_prompt_template.interaction_mode"})," and ",(0,i.jsx)(n.code,{children:"ce_prompt_template.interaction_contract"})," are the preferred turn-semantics contract in v2.0.9+."]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SchemaExtractionStep"})," uses the scoped ",(0,i.jsx)(n.code,{children:"SCHEMA_JSON"})," template for extraction prompts; ",(0,i.jsx)(n.code,{children:"COLLECT"})," plus ",(0,i.jsx)(n.code,{children:'expects:["structured_input"]'})," is the recommended shape."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CorrectionStep"})," should rely on the active prompt template semantics (",(0,i.jsx)(n.code,{children:"CONFIRM"}),", ",(0,i.jsx)(n.code,{children:"PROCESSING"}),", and ",(0,i.jsx)(n.code,{children:"interaction_contract"})," capabilities such as ",(0,i.jsx)(n.code,{children:"affirm"}),", ",(0,i.jsx)(n.code,{children:"edit"}),", ",(0,i.jsx)(n.code,{children:"retry"}),") instead of parsing state-name substrings."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ResponseResolutionStep"})," still selects by ",(0,i.jsx)(n.code,{children:"intent_code + state_code + response_type"}),", but ",(0,i.jsx)(n.code,{children:"interaction_mode"})," helps document what kind of user interaction that template represents."]}),"\n"]})]}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"1"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"LoadOrCreateConversationStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Fetch or bootstrap conversation row",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"conversation, intent/state/context sync"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_conversation"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["This is the ",(0,i.jsx)(n.strong,{children:"initial bootstrap step"})," of the runtime engine. It uses the ",(0,i.jsx)(n.code,{children:"conversationId"})," provided in the HTTP request to lookup an existing ",(0,i.jsx)(n.code,{children:"CeConversation"})," row in the Postgres database."]}),(0,i.jsx)(n.p,{children:"If the conversation exists:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The context JSON is hydrated into the runtime ",(0,i.jsx)(n.code,{children:"EngineSession"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Previous ",(0,i.jsx)(n.code,{children:"intent"})," and ",(0,i.jsx)(n.code,{children:"state"})," codes are restored."]}),"\n",(0,i.jsx)(n.li,{children:"All stored memory summaries and pending actions are fetched from the database and loaded into memory."}),"\n"]}),(0,i.jsx)(n.p,{children:"If the conversation is new:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A new ",(0,i.jsx)(n.code,{children:"CeConversation"})," entity is instantiated."]}),"\n",(0,i.jsxs)(n.li,{children:["The intent and state default to ",(0,i.jsx)(n.code,{children:"UNKNOWN"}),"."]}),"\n"]}),(0,i.jsx)(n.p,{children:"This ensures that regardless of scale, the API is entirely stateless and can route requests to any pod."}),(0,i.jsx)(a.vl,{title:"LoadOrCreateConversationStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/LoadOrCreateConversationStep.java",defaultOpen:!0,children:"public StepResult execute(EngineSession session) {\n      UUID id = session.getConversationId();\n      CeConversation convo = conversationRepo.findById(id).orElseGet(() -> createNewConversation(id, conversationRepo));\n\n      convo.setLastUserText(session.getUserText());\n      convo.setUpdatedAt(OffsetDateTime.now());\n\n      session.setConversation(convo);\n      session.syncFromConversation();\n\n      return new StepResult.Continue();\n  }"}),(0,i.jsxs)(n.p,{children:["When the LLM path is used, ",(0,i.jsx)(n.code,{children:"DialogueActStep"})," now audits:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"DIALOGUE_ACT_LLM_INPUT"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"DIALOGUE_ACT_LLM_OUTPUT"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"DIALOGUE_ACT_LLM_ERROR"})}),"\n"]}),(0,i.jsxs)(n.p,{children:["It still emits the final classification checkpoint as ",(0,i.jsx)(n.code,{children:"DIALOGUE_ACT_CLASSIFIED"}),"."]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"2"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"CacheInspectAuditStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Conditionally audit cache snapshot",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"none"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"convengine.audit.cache-inspector"})," property"]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Dynamically runs if ",(0,i.jsx)(n.code,{children:"convengine.audit.cache-inspector"})," is true. It takes a complete JSON snapshot of the hydrated ",(0,i.jsx)(n.code,{children:"EngineSession"})," conversation cache tree and logs it under the ",(0,i.jsx)(n.code,{children:"CACHE_INSPECTION"})," priority stage before explicit user input audits are finalized."]}),(0,i.jsx)(a.vl,{title:"CacheInspectAuditStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/CacheInspectAuditStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put("cache_snapshot", objectMapper.valueToTree(session.getConversation()));\n      auditService.audit(ConvEngineAuditStage.CACHE_INSPECTION, session.getConversationId(), payload);\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"3"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"ResetConversationStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Early explicit reset",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"intent/state/context/input params reset"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"input flags, command text"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Checks ",(0,i.jsx)(n.code,{children:"EngineSession"})," properties to see if an explicit reset has been triggered by the invoking consumer (this is usually passed as a param like ",(0,i.jsx)(n.code,{children:"_reset=true"}),")."]}),(0,i.jsx)(n.p,{children:"When triggered, it clears:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"intent"})," and ",(0,i.jsx)(n.code,{children:"state"})," trackers."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"contextJson"})," (wiping all extracted schema facts)."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"inputParamsJson"}),"."]}),"\n"]}),(0,i.jsxs)(n.p,{children:["The session is marked as `RUNNING` again, but completely fresh. An audit event ",(0,i.jsx)(n.code,{children:"CONVERSATION_RESET"})," is logged."]}),(0,i.jsx)(a.vl,{title:"ResetConversationStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/ResetConversationStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (!shouldReset(session)) {\n          return new StepResult.Continue();\n      }\n\n      String reason = resetReason(session);\n      session.resetForConversationRestart();\n      session.getConversation().setStatus("RUNNING");\n      session.getConversation().setIntentCode("UNKNOWN");\n      session.getConversation().setStateCode("UNKNOWN");\n      session.getConversation().setContextJson("{}");\n      session.getConversation().setInputParamsJson("{}");\n      session.getConversation().setLastAssistantJson(null);\n      session.getConversation().setUpdatedAt(OffsetDateTime.now());\n      conversationRepository.save(session.getConversation());\n\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, reason);\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson());\n      audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload);\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"4"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"PersistConversationBootstrapStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Ensure conversation row persisted",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"none/metadata"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_conversation"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["A simple lifecycle checkpoint to ensure the conversation has a ",(0,i.jsx)(n.code,{children:"createdAt"})," timestamp. If the user session just started in ",(0,i.jsx)(n.code,{children:"LoadOrCreateConversationStep"}),", this step performs the initial ",(0,i.jsx)(n.code,{children:"INSERT (ce_conversation)"})," to the database to ensure foreign-key dependencies (like audit logs) don't fail later in the loop."]}),(0,i.jsx)(a.vl,{title:"PersistConversationBootstrapStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/PersistConversationBootstrapStep.java",defaultOpen:!0,children:"public StepResult execute(EngineSession session) {\n      if (session.getConversation().getCreatedAt() == null) {\n          session.getConversation().setCreatedAt(OffsetDateTime.now());\n          session.getConversation().setUpdatedAt(OffsetDateTime.now());\n          conversationRepo.save(session.getConversation());\n      }\n      return new StepResult.Continue();\n  }"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"5"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"AuditUserInputStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Persist user input audit",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"none"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Records the raw text query the user typed on this turn into the ",(0,i.jsx)(n.code,{children:"ce_audit"})," table. This is purely for debug tracing and business analytics. It binds the ",(0,i.jsx)(n.code,{children:"USER_INPUT"})," audit stage with the conversation ID and the text payload."]}),(0,i.jsx)(a.vl,{title:"AuditUserInputStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/AuditUserInputStep.java",defaultOpen:!0,children:"public StepResult execute(EngineSession session) {\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.TEXT, session.getUserText());\n      audit.audit(ConvEngineAuditStage.USER_INPUT, session.getConversationId(), payload);\n      return new StepResult.Continue();\n  }"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"6"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"PolicyEnforcementStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Policy block and stop",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"payload + stop result on block"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_policy"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Secures the pipeline against prohibited input using ",(0,i.jsx)(n.code,{children:"ce_policy"}),"."]}),(0,i.jsxs)(n.p,{children:["It reads all active rows from ",(0,i.jsx)(n.code,{children:"ce_policy"}),", executing either ",(0,i.jsx)(n.code,{children:"REGEX"}),", ",(0,i.jsx)(n.code,{children:"EXACT"}),", or ",(0,i.jsx)(n.code,{children:"LLM"})," rules against the user's raw text. If a match occurs:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The conversation is forced to a `BLOCKED` status."}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"StepResult.Stop()"})," is returned immediately, skipping all remaining NLP and intent steps."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"ce_policy.response_text"})," is loaded as the final payload shipped back to the consumer."]}),"\n"]}),(0,i.jsx)(a.vl,{title:"PolicyEnforcementStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/PolicyEnforcementStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      String userText = session.getUserText();\n\n      for (CePolicy policy : policyRepo.findByEnabledTrueOrderByPriorityAsc()) {\n          if (matches(policy.getRuleType(), policy.getPattern(), userText)) {\n              Map<String, Object> payload = new LinkedHashMap<>();\n              payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.POLICY_ID, policy.getPolicyId());\n              payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RULE_TYPE, policy.getRuleType());\n              payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.PATTERN, policy.getPattern());\n              audit.audit(ConvEngineAuditStage.POLICY_BLOCK, session.getConversationId(), payload);\n\n              session.getConversation().setStatus("BLOCKED");\n              session.getConversation().setLastAssistantJson(jsonText(policy.getResponseText()));\n              session.getConversation().setUpdatedAt(OffsetDateTime.now());\n              conversationRepo.save(session.getConversation());\n\n              EngineResult out = new EngineResult(\n                      session.getIntent(),\n                      session.getState(),\n                      new TextPayload(policy.getResponseText()),\n                      session.getContextJson()\n              );\n              return new StepResult.Stop(out);\n          }\n      }\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"7"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"DialogueActStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Classify user turn action type",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"dialogue_act in input params"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_config (dialogue act mode), ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:['This step attempts to classify the raw user text into an explicit conversational "act" through Regex, and optionally as fallback, a LLM request depending on the strictness of ',(0,i.jsx)(n.code,{children:"convengine.flow.dialogue-act.resolute"})," (e.g., ",(0,i.jsx)(n.code,{children:"REGEX_THEN_LLM"}),")."]}),(0,i.jsx)(n.p,{children:"Why this step exists:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["it turns raw free-form phrases like ",(0,i.jsx)(n.code,{children:"yes"}),", ",(0,i.jsx)(n.code,{children:"go ahead"}),", ",(0,i.jsx)(n.code,{children:"change amount to 350000"}),", or ",(0,i.jsx)(n.code,{children:"start over"})," into stable engine signals"]}),"\n",(0,i.jsx)(n.li,{children:"downstream steps should not branch on raw text because raw phrasing is inconsistent and expensive to reason about repeatedly"}),"\n",(0,i.jsx)(n.li,{children:"it reduces unnecessary intent/schema/LLM work for short operational turns"}),"\n",(0,i.jsxs)(n.li,{children:["it makes ",(0,i.jsx)(n.code,{children:"ce_rule"})," conditions deterministic by giving rules normalized fields instead of unstructured user text"]}),"\n"]}),(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"convengine.flow.queryRewrite.enabled=true"})," and the ",(0,i.jsx)(n.code,{children:"conversionHistory"})," is present, the step morphs its LLM request into a dual ",(0,i.jsx)(n.strong,{children:"Classifier & RAG Context Optimizer"}),". It supplies the ongoing conversation to the LLM to rewrite ambiguous pronouns into an explicit standalone search query, returning it as ",(0,i.jsx)(n.code,{children:'"standaloneQuery"'}),"."]}),(0,i.jsxs)(n.p,{children:["The core parameters for these prompts are dynamically loaded from ",(0,i.jsx)(n.code,{children:"ce_config"}),", allowing administrators to Hot-Swap classifier behaviors in production without recompiling Java arrays."]}),(0,i.jsx)(n.h3,{id:"supported-dialogue-acts",children:"Supported Dialogue Acts"}),(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Enum Name"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"AFFIRM"})}),(0,i.jsx)(n.td,{children:'The user expressed agreement or confirmation (e.g., "yes", "go ahead"). Can override Guardrails or execute Pending Actions.'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"NEGATE"})}),(0,i.jsx)(n.td,{children:'The user expressed rejection or cancellation (e.g., "no", "stop"). Can cancel active Interaction Policies.'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"EDIT"})}),(0,i.jsx)(n.td,{children:"The user wants to change previously supplied context or entity slots."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"RESET"})}),(0,i.jsx)(n.td,{children:"The user wants to clear memory and start completely fresh."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"QUESTION"})}),(0,i.jsx)(n.td,{children:"The user is asking a direct conversational question (triggers fallback intent workflows)."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"NEW_REQUEST"})}),(0,i.jsx)(n.td,{children:"The baseline generic classification. Engine routes normally."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"GREETING"})}),(0,i.jsx)(n.td,{children:'The user issued a pleasantry ("Hi", "Hello"). Typically bypassed by downstream Orchestrators to prevent expensive RAG queries.'})]})]})]}),(0,i.jsx)(n.h3,{id:"source-execution-profile",children:"Source Execution Profile"}),(0,i.jsx)(a.f4,{type:"tip",title:"Regex Guardrails",children:(0,i.jsxs)(n.p,{children:["The runtime still keeps a conservative regex guard for destructive resets. ",(0,i.jsx)(n.code,{children:"RESET"})," can be forced back to a ",(0,i.jsx)(n.code,{children:"REGEX_GUARD"})," result when the user text does not clearly match the reset regex. ",(0,i.jsx)(n.code,{children:"EDIT"})," is no longer globally downgraded in Java. Instead, the engine preserves regex and LLM candidate values, and a ",(0,i.jsx)(n.code,{children:"POST_DIALOGUE_ACT"})," rule pass can apply a DB-driven override using ",(0,i.jsx)(n.code,{children:"SET_DIALOGUE_ACT"})," when the workflow should trust the LLM candidate."]})}),(0,i.jsxs)(n.h3,{id:"why-post_dialogue_act-exists",children:["Why ",(0,i.jsx)(n.code,{children:"POST_DIALOGUE_ACT"})," exists"]}),(0,i.jsx)(n.p,{children:"The engine should stay conservative by default, but business workflows still need a safe override point."}),(0,i.jsx)(n.p,{children:"Examples:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["user says: ",(0,i.jsx)(n.code,{children:"Ohh wait, I missed one zero. Change amount to 350000."})]}),"\n",(0,i.jsxs)(n.li,{children:["regex may still classify this as ",(0,i.jsx)(n.code,{children:"NEW_REQUEST"})]}),"\n",(0,i.jsxs)(n.li,{children:["the LLM candidate may classify it as ",(0,i.jsx)(n.code,{children:"EDIT"})]}),"\n",(0,i.jsxs)(n.li,{children:["a ",(0,i.jsx)(n.code,{children:"POST_DIALOGUE_ACT"})," rule can inspect:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"inputParams.dialogue_act"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"inputParams.dialogue_act_source"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"inputParams.dialogue_act_llm_candidate"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"inputParams.dialogue_act_llm_standalone_query"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["then use ",(0,i.jsx)(n.code,{children:"SET_DIALOGUE_ACT"})," to restore ",(0,i.jsx)(n.code,{children:"EDIT"})," before ",(0,i.jsx)(n.code,{children:"InteractionPolicyStep"})]}),"\n"]}),(0,i.jsx)(n.p,{children:"This keeps:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"the default engine behavior safe"}),"\n",(0,i.jsx)(n.li,{children:"the override behavior DB-driven"}),"\n",(0,i.jsx)(n.li,{children:"the state model dynamic instead of hardcoded in Java"}),"\n"]}),(0,i.jsx)(a.vl,{title:"DialogueActStep.java (Simplified)",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/DialogueActStep.java",defaultOpen:!0,children:'@MustRunAfter(AuditUserInputStep.class)\n@MustRunBefore(IntentResolutionStep.class)\npublic class DialogueActStep implements EngineStep {\n\n  private final ConvEngineFlowConfig flowConfig;\n  private final CeConfigResolver configResolver;\n  \n  // Extracted from ce_config during Application Initialization\n  private Pattern REGEX_GREETING;\n  private Pattern REGEX_AFFIRM;\n  private Pattern REGEX_NEGATE;\n\n  private String SYSTEM_PROMPT;\n  private String QUERY_REWRITE_SYSTEM_PROMPT;\n  // ...\n\n  @PostConstruct\n  public void init() {\n      // Core Regex Evaluation Patterns mapped securely in ce_config\n      REGEX_GREETING = Pattern.compile(\n              configResolver.resolveString(this, "REGEX_GREETING", "^(\\s)*(hi|hello|hey|greetings|good morning|...)$"),\n              Pattern.CASE_INSENSITIVE\n      );\n\n      // Loads from ce_config where config_type="DialogueActStep" and config_key="SYSTEM_PROMPT".\n      SYSTEM_PROMPT = configResolver.resolveString(this, "SYSTEM_PROMPT", """\n              You are a dialogue-act classifier.\n              Return JSON only with:\n              {"dialogueAct":"AFFIRM|NEGATE|EDIT|RESET|QUESTION|NEW_REQUEST|GREETING","confidence":0.0}\n              """);\n              \n      // Loads the query-rewrite variant\n      QUERY_REWRITE_SYSTEM_PROMPT = configResolver.resolveString(this, "QUERY_REWRITE_SYSTEM_PROMPT", """\n                      You are a dialogue-act classifier and intelligent query search rewriter.\n                      Using the conversation history, rewrite the user\'s text into an explicit, standalone query that perfectly describes their intent without needing the conversation history context.\n                      Also classify their dialogue act.\n                      Return JSON only matching the exact schema.\n                      """);\n  }\n\n  @Override\n  public StepResult execute(EngineSession session) {\n      String userText = session.getUserText();\n\n      // 1. Regex Classification First\n      DialogueActResult regexResult = classifyByRegex(userText);\n      \n      // 2. Resolve final intention while preserving regex + LLM candidates\n      DialogueActResolution resolution = resolveByMode(session, userText, regexResult);\n      DialogueActResult resolved = resolution.resolved();\n\n      // 3. Persist regex, LLM candidate, guard metadata, and final decision\n      session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_REGEX, regexResult.act().name());\n      session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_LLM_CANDIDATE, ...);\n      session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT, resolved.act().name());\n      session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_CONFIDENCE, resolved.confidence());\n      \n      if (resolved.standaloneQuery() != null) {\n          session.putInputParam(ConvEngineInputParamKey.STANDALONE_QUERY, resolved.standaloneQuery());\n          session.setStandaloneQuery(resolved.standaloneQuery());\n      }\n\n      // 4. Let DB rules override the guarded result before policy routing\n      rulesStep.applyRules(session, "DialogueActStep", RulePhase.POST_DIALOGUE_ACT.name());\n\n      return new StepResult.Continue();\n  }\n}'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"8"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"InteractionPolicyStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Decide runtime policy before intent",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"policy_decision, skip_intent_resolution"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_config, session pending state"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Uses the identified ",(0,i.jsx)(n.code,{children:"DialogueAct"}),' to decide how the engine should route the turn. This step prevents the system from confusing follow-up answers (like saying "yes") with new intents.']}),(0,i.jsxs)(n.p,{children:["Before this step runs, the engine now executes a ",(0,i.jsx)(n.code,{children:"POST_DIALOGUE_ACT"})," rule pass. That lets DB rules override guarded dialogue-act outcomes using the regex result, the LLM candidate result, or the dedicated ",(0,i.jsx)(n.code,{children:"SET_DIALOGUE_ACT"})," action without hardcoding state names in Java."]}),(0,i.jsxs)(n.p,{children:["The output maps to the ",(0,i.jsx)(n.code,{children:"InteractionPolicyDecision"})," enum:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"EXECUTE_PENDING_ACTION"})}),": If the DialogueAct is ",(0,i.jsx)(n.code,{children:"AFFIRM"})," and there's a background API task waiting."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"REJECT_PENDING_ACTION"})}),": If ",(0,i.jsx)(n.code,{children:"NEGATE"})," and an action is waiting."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"FILL_PENDING_SLOT"})}),": If the user is currently answering a schema extraction question."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"RECLASSIFY_INTENT"})}),": If this is a ",(0,i.jsx)(n.code,{children:"NEW_REQUEST"}),"."]}),"\n"]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Evaluation Matrix Flow:"})}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Checks for context hints: ",(0,i.jsx)(n.code,{children:"hasPendingAction"}),", ",(0,i.jsx)(n.code,{children:"hasPendingSlot"}),", ",(0,i.jsx)(n.code,{children:"hasResolvedIntent"}),", ",(0,i.jsx)(n.code,{children:"hasResolvedState"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["First, it attempts a lookup using the ",(0,i.jsx)(n.code,{children:"resolveFromMatrix()"})," method against any custom configurations in your YAML properties."]}),"\n",(0,i.jsxs)(n.li,{children:["If no custom matrix decision applies, it checks boolean flags from the config.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isExecutePendingOnAffirm()"}),": If true, ",(0,i.jsx)(n.code,{children:"AFFIRM"})," + ",(0,i.jsx)(n.code,{children:"hasPendingAction"})," -> ",(0,i.jsx)(n.code,{children:"EXECUTE_PENDING_ACTION"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isRejectPendingOnNegate()"}),": If true, ",(0,i.jsx)(n.code,{children:"NEGATE"})," + ",(0,i.jsx)(n.code,{children:"hasPendingAction"})," -> ",(0,i.jsx)(n.code,{children:"REJECT_PENDING_ACTION"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isFillPendingSlotOnNonNewRequest()"}),": If true, ",(0,i.jsx)(n.code,{children:"!= NEW_REQUEST && != GREETING"})," + ",(0,i.jsx)(n.code,{children:"hasPendingSlot"})," -> ",(0,i.jsx)(n.code,{children:"FILL_PENDING_SLOT"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Most crucially, if any of these policy decisions trigger, it sets ",(0,i.jsx)(n.code,{children:"skipIntentResolution = true"}),". This stops Step 11 (",(0,i.jsx)(n.code,{children:"IntentResolutionStep"}),") from overriding the sticky intent. The payload is attached with ",(0,i.jsx)(n.code,{children:"POLICY_DECISION"}),"."]}),"\n"]}),(0,i.jsx)(a.vl,{title:"InteractionPolicyStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/InteractionPolicyStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      String dialogueActRaw = session.inputParamAsString(ConvEngineInputParamKey.DIALOGUE_ACT);\n      DialogueAct dialogueAct = parseDialogueAct(dialogueActRaw);\n      Map<String, Object> context = session.contextDict();\n      Map<String, Object> inputParams = session.getInputParams();\n\n      boolean hasPendingAction = hasValue(context.get("pending_action"))\n              || hasValue(context.get("pendingAction"))\n              || hasValue(inputParams.get("pending_action"))\n              || hasValue(inputParams.get("pendingAction"))\n              || hasValue(inputParams.get(ConvEngineInputParamKey.PENDING_ACTION_KEY))\n              || hasValue(inputParams.get("pending_action_task"))\n              || hasPendingActionFromRegistry(session);\n      boolean hasPendingSlot = hasValue(context.get("pending_slot"))\n              || hasValue(context.get("pendingSlot"));\n      boolean hasResolvedIntent = session.getIntent() != null\n              && !session.getIntent().isBlank()\n              && !"UNKNOWN".equalsIgnoreCase(session.getIntent());\n      boolean hasResolvedState = session.getState() != null\n              && !session.getState().isBlank()\n              && !"UNKNOWN".equalsIgnoreCase(session.getState());\n      boolean requireResolvedIntentAndState = flowConfig.getInteractionPolicy().isRequireResolvedIntentAndState();\n      boolean hasResolvedContext = !requireResolvedIntentAndState || (hasResolvedIntent && hasResolvedState);\n\n      InteractionPolicyDecision decision = InteractionPolicyDecision.RECLASSIFY_INTENT;\n      boolean skipIntentResolution = false;\n\n      if (hasResolvedContext) {\n          InteractionPolicyDecision matrixDecision = resolveFromMatrix(hasPendingAction, hasPendingSlot, dialogueAct);\n          if (matrixDecision != null) {\n              decision = matrixDecision;\n              skipIntentResolution = true;\n          } else if (flowConfig.getInteractionPolicy().isExecutePendingOnAffirm()\n                  && hasPendingAction\n                  && dialogueAct == DialogueAct.AFFIRM) {\n              decision = InteractionPolicyDecision.EXECUTE_PENDING_ACTION;\n              skipIntentResolution = true;\n          } else if (flowConfig.getInteractionPolicy().isRejectPendingOnNegate()\n                  && hasPendingAction\n                  && dialogueAct == DialogueAct.NEGATE) {\n              decision = InteractionPolicyDecision.REJECT_PENDING_ACTION;\n              skipIntentResolution = true;\n          } else if (flowConfig.getInteractionPolicy().isFillPendingSlotOnNonNewRequest()\n                  && hasPendingSlot\n                  && dialogueAct != DialogueAct.NEW_REQUEST) {\n              decision = InteractionPolicyDecision.FILL_PENDING_SLOT;\n              skipIntentResolution = true;\n          }\n      }\n\n      session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, decision.name());\n      session.putInputParam(ConvEngineInputParamKey.SKIP_INTENT_RESOLUTION, skipIntentResolution);\n\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put(ConvEnginePayloadKey.DIALOGUE_ACT, dialogueAct.name());\n      payload.put(ConvEnginePayloadKey.POLICY_DECISION, decision.name());\n      payload.put(ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, skipIntentResolution);\n      payload.put("hasPendingAction", hasPendingAction);\n      payload.put("hasPendingSlot", hasPendingSlot);\n      payload.put(ConvEnginePayloadKey.INTENT, session.getIntent());\n      payload.put(ConvEnginePayloadKey.STATE, session.getState());\n      audit.audit(ConvEngineAuditStage.INTERACTION_POLICY_DECIDED, session.getConversationId(), payload);\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"9"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"ActionLifecycleStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Maintain pending action runtime TTL/status",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"pending_action_runtime context"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_pending_action, ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Tracks time-to-live (TTL) for ",(0,i.jsx)(n.code,{children:"CePendingAction"}),' rows. If the user was asked "Are you sure you want to cancel?" 3 turns ago, but started talking about the weather instead, this step will mark the ',(0,i.jsx)(n.code,{children:"pending_action_runtime"})," as ",(0,i.jsx)(n.code,{children:"EXPIRED"}),"."]}),(0,i.jsxs)(n.p,{children:["Status transitions (Enum ",(0,i.jsx)(n.code,{children:"PendingActionStatus"}),"):"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"OPEN"}),": Task is created but waiting for user confirmation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"IN_PROGRESS"}),": The user affirmed, and the task is ready to execute."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"REJECTED"}),": The user negated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"EXPIRED"}),": The TTL turn limit was reached before the user confirmed."]}),"\n"]}),(0,i.jsx)(a.vl,{title:"ActionLifecycleStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/ActionLifecycleStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (!flowConfig.getActionLifecycle().isEnabled()) {\n          return new StepResult.Continue();\n      }\n\n      ObjectNode root = contextHelper.readRoot(session);\n      ObjectNode runtime = contextHelper.ensureObject(root, RUNTIME_NODE);\n      int currentTurn = session.conversionHistory().size() + 1;\n      long now = Instant.now().toEpochMilli();\n\n      PendingActionStatus currentStatus = PendingActionStatus.from(runtime.path("status").asText(null), null);\n      if (isExpired(runtime, currentTurn, now) && (currentStatus == PendingActionStatus.OPEN || currentStatus == PendingActionStatus.IN_PROGRESS)) {\n          runtime.put("status", PendingActionStatus.EXPIRED.name());\n          runtime.put("expired_turn", currentTurn);\n          runtime.put("expired_at_epoch_ms", now);\n          session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.EXPIRED.name());\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(\n                  "event", "EXPIRED",\n                  "status", PendingActionStatus.EXPIRED.name(),\n                  "turn", currentTurn\n          ));\n      }\n\n      String actionKey = resolveActionKey(session);\n      String actionRef = resolveActionReferenceFromTable(session, actionKey);\n      if (actionRef == null || actionRef.isBlank()) {\n          contextHelper.writeRoot(session, root);\n          return new StepResult.Continue();\n      }\n\n      boolean isNewRuntime = isRuntimeNew(runtime, actionKey, actionRef);\n      if (isNewRuntime) {\n          runtime.put("action_key", actionKey == null ? "" : actionKey);\n          runtime.put("action_ref", actionRef);\n          runtime.put("status", PendingActionStatus.OPEN.name());\n          runtime.put("created_turn", currentTurn);\n          runtime.put("created_at_epoch_ms", now);\n          runtime.put("expires_turn", flowConfig.getActionLifecycle().getTtlTurns() > 0\n                  ? currentTurn + flowConfig.getActionLifecycle().getTtlTurns()\n                  : -1);\n          runtime.put("expires_at_epoch_ms", flowConfig.getActionLifecycle().getTtlMinutes() > 0\n                  ? now + (flowConfig.getActionLifecycle().getTtlMinutes() * 60_000L)\n                  : -1);\n          session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.OPEN.name());\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(\n                  "event", "OPEN",\n                  "status", PendingActionStatus.OPEN.name(),\n                  "actionKey", actionKey,\n                  "actionRef", actionRef\n          ));\n      }\n\n      InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION));\n      if (decision == InteractionPolicyDecision.EXECUTE_PENDING_ACTION) {\n          runtime.put("status", PendingActionStatus.IN_PROGRESS.name());\n          runtime.put("in_progress_turn", currentTurn);\n          runtime.put("in_progress_at_epoch_ms", now);\n          session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.IN_PROGRESS.name());\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(\n                  "event", "IN_PROGRESS",\n                  "status", PendingActionStatus.IN_PROGRESS.name(),\n                  "actionKey", actionKey,\n                  "actionRef", actionRef\n          ));\n      } else if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) {\n          runtime.put("status", PendingActionStatus.REJECTED.name());\n          runtime.put("rejected_turn", currentTurn);\n          runtime.put("rejected_at_epoch_ms", now);\n          session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.REJECTED.name());\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(\n                  "event", "REJECTED",\n                  "status", PendingActionStatus.REJECTED.name(),\n                  "actionKey", actionKey,\n                  "actionRef", actionRef\n          ));\n      }\n\n      contextHelper.writeRoot(session, root);\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"10"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"DisambiguationStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Ask question when multiple actions fit",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"pending_clarification question/context"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_pending_action, ce_config, ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsx)(n.p,{children:'A smart conversational router. If multiple pending actions apply to the current context (e.g., "Cancel flight" vs "Cancel hotel" both valid), it pauses the pipeline.'}),(0,i.jsxs)(n.p,{children:["It dynamically builds a multiple-choice prompt (or LLM synthesis) asking the user to clarify which action they meant. It emits an ",(0,i.jsx)(n.code,{children:"ASSISTANT_OUTPUT"})," step, stalling the pipeline until the user clarifies."]}),(0,i.jsx)(a.vl,{title:"DisambiguationStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/DisambiguationStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (!flowConfig.getDisambiguation().isEnabled()) {\n          return new StepResult.Continue();\n      }\n      InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION));\n      if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION) {\n          return new StepResult.Continue();\n      }\n\n      String explicitActionKey = session.inputParamAsString(ConvEngineInputParamKey.PENDING_ACTION_KEY);\n      if (explicitActionKey != null && !explicitActionKey.isBlank()) {\n          return new StepResult.Continue();\n      }\n\n      List<CePendingAction> candidates = pendingActionRepository.findEligibleByIntentAndStateOrderByPriorityAsc(\n              session.getIntent(),\n              session.getState()\n      );\n      if (candidates == null || candidates.size() <= 1) {\n          return new StepResult.Continue();\n      }\n\n      int bestPriority = candidates.getFirst().getPriority() == null ? Integer.MAX_VALUE : candidates.getFirst().getPriority();\n      List<CePendingAction> top = candidates.stream()\n              .filter(c -> (c.getPriority() == null ? Integer.MAX_VALUE : c.getPriority()) == bestPriority)\n              .toList();\n      if (top.size() <= 1) {\n          return new StepResult.Continue();\n      }\n\n      Set<String> options = new LinkedHashSet<>();\n      for (CePendingAction row : top) {\n          if (row.getActionKey() == null || row.getActionKey().isBlank()) {\n              continue;\n          }\n          String option = row.getActionKey().trim();\n          if (row.getDescription() != null && !row.getDescription().isBlank()) {\n              option = option + " (" + row.getDescription().trim() + ")";\n          }\n          options.add(option);\n          if (options.size() >= Math.max(1, flowConfig.getDisambiguation().getMaxOptions())) {\n              break;\n          }\n      }\n      if (options.isEmpty()) {\n          return new StepResult.Continue();\n      }\n\n      QuestionResult questionResult = buildQuestion(session, top, options);\n      String question = questionResult.question();\n      session.setPendingClarificationQuestion(question);\n      session.setPendingClarificationReason("PENDING_ACTION_DISAMBIGUATION");\n      session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, InteractionPolicyDecision.RECLASSIFY_INTENT.name());\n      session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_DISAMBIGUATION_REQUIRED, true);\n\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put(ConvEnginePayloadKey.REASON, "MULTIPLE_PENDING_ACTIONS");\n      payload.put(ConvEnginePayloadKey.QUESTION, question);\n      payload.put(ConvEnginePayloadKey.CANDIDATE_COUNT, top.size());\n      payload.put(ConvEnginePayloadKey.OPTIONS, new ArrayList<>(options));\n      payload.put(ConvEnginePayloadKey.INTENT, session.getIntent());\n      payload.put(ConvEnginePayloadKey.STATE, session.getState());\n      payload.put(ConvEnginePayloadKey.QUESTION_SOURCE, questionResult.source());\n      audit.audit(ConvEngineAuditStage.DISAMBIGUATION_REQUIRED, session.getConversationId(), payload);\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"11"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"GuardrailStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Apply guardrails and approval rules",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"guardrail flags/sanitized text"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_config, ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["The last line of defense before intent triggers. Reads the ",(0,i.jsx)(n.code,{children:"ce_config"}),' guardrail thresholds and sanitize instructions.\nIf a command is flagged as "sensitive" (e.g., destructive actions like closing an account), it can force an explicit ',(0,i.jsx)(n.code,{children:"SENSITIVE_ACTION_APPROVAL_REQUIRED"})," pause, blocking the pipeline from executing tasks until MFA or explicit user verification is acquired."]}),(0,i.jsx)(a.vl,{title:"GuardrailStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/GuardrailStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (!flowConfig.getGuardrail().isEnabled()) {\n          return new StepResult.Continue();\n      }\n\n      String originalUserText = session.getUserText() == null ? "" : session.getUserText();\n      String sanitizedUserText = sanitize(originalUserText);\n      if (flowConfig.getGuardrail().isSanitizeInput()) {\n          session.putInputParam(ConvEngineInputParamKey.SANITIZED_USER_TEXT, sanitizedUserText);\n      }\n\n      boolean sensitive = matchesSensitivePattern(sanitizedUserText);\n      boolean approvalRequired = flowConfig.getGuardrail().isRequireApprovalForSensitiveActions() && sensitive;\n      boolean approvalGranted = isApprovalGranted(session);\n      boolean failClosed = flowConfig.getGuardrail().isApprovalGateFailClosed();\n      boolean denied = approvalRequired && (!approvalGranted || failClosed && !approvalGranted);\n\n      if (denied) {\n          session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_BLOCKED, true);\n          session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_REASON, "SENSITIVE_ACTION_APPROVAL_REQUIRED");\n          session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, InteractionPolicyDecision.RECLASSIFY_INTENT.name());\n          session.putInputParam(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION, true);\n          session.putInputParam(ConvEngineInputParamKey.SKIP_PENDING_ACTION_EXECUTION, true);\n\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put("result", "DENY");\n          payload.put("reason", "SENSITIVE_ACTION_APPROVAL_REQUIRED");\n          payload.put("sensitive", true);\n          payload.put("approvalGranted", approvalGranted);\n          payload.put("userText", sanitizedUserText);\n          payload.put("intent", session.getIntent());\n          payload.put("state", session.getState());\n          audit.audit(ConvEngineAuditStage.GUARDRAIL_DENY, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_BLOCKED, false);\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put("result", "ALLOW");\n      payload.put("sensitive", sensitive);\n      payload.put("approvalRequired", approvalRequired);\n      payload.put("approvalGranted", approvalGranted);\n      payload.put("intent", session.getIntent());\n      payload.put("state", session.getState());\n      audit.audit(ConvEngineAuditStage.GUARDRAIL_ALLOW, session.getConversationId(), payload);\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"12"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"IntentResolutionStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Resolve intent with classifier+agent",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"intent/state/clarification fields"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_intent, ce_intent_classifier, ce_config"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["The primary intent matching gateway. Uses the ",(0,i.jsx)(n.code,{children:"CompositeIntentResolver"})," (which merges Regex, Semantic Search, and LLM classifiers based off ",(0,i.jsx)(n.code,{children:"ce_intent_classifier"}),")."]}),(0,i.jsxs)(n.p,{children:["If the interaction policy decided we are in ",(0,i.jsx)(n.code,{children:"FILL_PENDING_SLOT"}),' mode, this step is bypassed entirely (referred to as a "Locked Intent").']}),(0,i.jsx)(n.p,{children:"Otherwise:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Queries ",(0,i.jsx)(n.code,{children:"ce_intent_classifier"})," for matches."]}),"\n",(0,i.jsxs)(n.li,{children:["Uses ",(0,i.jsx)(n.code,{children:"INTENT_RESOLVED"})," audit logs to map the ",(0,i.jsx)(n.code,{children:"intentCode"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Sets the context state to ",(0,i.jsx)(n.code,{children:"IDLE"})," (or whatever the initial configuration demands)."]}),"\n"]}),(0,i.jsx)(a.vl,{title:"IntentResolutionStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/IntentResolutionStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n\n      String previousIntent = session.getIntent();\n\n      Map<String, Object> startPayload = new LinkedHashMap<>();\n      startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.PREVIOUS_INTENT, previousIntent);\n      startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCKED, session.isIntentLocked());\n      startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCK_REASON, session.getIntentLockReason());\n      audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_START, session.getConversationId(), startPayload);\n\n      if (session.isIntentLocked() || isActiveSchemaCollection(session)) {\n          if (!session.isIntentLocked()) {\n              session.lockIntent("SCHEMA_INCOMPLETE");\n          }\n          session.clearClarification();\n          if (session.getConversation() != null) {\n              session.getConversation().setIntentCode(session.getIntent());\n              session.getConversation().setStateCode(session.getState());\n          }\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCKED, session.isIntentLocked());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCK_REASON, session.getIntentLockReason());\n          audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      if (shouldSkipResolutionForPolicy(session)) {\n          if (session.getConversation() != null) {\n              session.getConversation().setIntentCode(session.getIntent());\n              session.getConversation().setStateCode(session.getState());\n          }\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.DIALOGUE_ACT, session.inputParamAsString(ConvEngineInputParamKey.DIALOGUE_ACT));\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.POLICY_DECISION, session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION));\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, true);\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, "policy decision retained existing intent/state");\n          audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_POLICY, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      if (shouldSkipResolutionForStickyIntent(session)) {\n          if (session.getConversation() != null) {\n              session.getConversation().setIntentCode(session.getIntent());\n              session.getConversation().setStateCode(session.getState());\n          }\n          Map<String, Object> payload = existingIntentRetainedAuditPayload(session);\n          audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_STICKY_INTENT, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      CompositeIntentResolver.IntentResolutionResult result = intentResolver.resolveWithTrace(session);\n\n      if (result == null || result.resolvedIntent() == null) {\n          audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_NO_CHANGE, session.getConversationId(), Map.of());\n          return new StepResult.Continue();\n      }\n\n      if (!result.resolvedIntent().equals(previousIntent)) {\n          session.setIntent(result.resolvedIntent());\n      }\n      session.getConversation().setIntentCode(session.getIntent());\n      session.getConversation().setStateCode(session.getState());\n\n      audit.audit(\n              ConvEngineAuditStage.intentResolvedBy(result.source().name()),\n              session.getConversationId(),\n              result\n      );\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"13"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"ResetResolvedIntentStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Reset on configured reset intent",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"full reset"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_config RESET_INTENT_CODES"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["A quality of life check. If the resolved intent matches one of the ",(0,i.jsx)(n.code,{children:"RESET_INTENT_CODES"})," configured in Spring configuration (e.g. ",(0,i.jsx)(n.code,{children:"START_OVER"}),", ",(0,i.jsx)(n.code,{children:"RESET"}),"), this step immediately executes a session wipe akin to ",(0,i.jsx)(n.code,{children:"ResetConversationStep"}),", returning the conversation to a clean slate."]}),(0,i.jsx)(a.vl,{title:"ResetResolvedIntentStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/ResetResolvedIntentStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      String intent = session.getIntent();\n      if (intent == null || !resetIntentCodes.contains(intent.trim().toUpperCase())) {\n          return new StepResult.Continue();\n      }\n\n      session.resetForConversationRestart();\n      session.getConversation().setStatus("RUNNING");\n      session.getConversation().setIntentCode("UNKNOWN");\n      session.getConversation().setStateCode("UNKNOWN");\n      session.getConversation().setContextJson("{}");\n      session.getConversation().setInputParamsJson("{}");\n      session.getConversation().setLastAssistantJson(null);\n      session.getConversation().setUpdatedAt(OffsetDateTime.now());\n      conversationRepository.save(session.getConversation());\n\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, "INTENT_RESOLVED_RESET");\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.MATCHED_RESET_INTENT_CODES, resetIntentCodes);\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson());\n      audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload);\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"14"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"FallbackIntentStateStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Fill missing intent/state defaults",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"intent/state"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"none"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["A safety net. If the classifier fails to return any confidence, or an exception occurred, this step forcibly binds the native engine defaults to ",(0,i.jsx)(n.code,{children:"UNKNOWN"})," intent and ",(0,i.jsx)(n.code,{children:"UNKNOWN"})," state so that ",(0,i.jsx)(n.code,{children:"ce_rule"})," and ",(0,i.jsx)(n.code,{children:"ce_response"}),' tables can still define fallback messaging (e.g., "I didn\'t understand that").']}),(0,i.jsx)(a.vl,{title:"FallbackIntentStateStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/FallbackIntentStateStep.java",defaultOpen:!0,children:"public StepResult execute(EngineSession session) {\n\n      if (session.getIntent() == null) {\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.USER_TEXT, session.getUserText());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FALLBACK_INTENT, fallbackIntent);\n          audit.audit(ConvEngineAuditStage.INTENT_MISSING, session.getConversationId(), payload);\n          session.setIntent(fallbackIntent);\n      }\n\n      if (session.getState() == null) {\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.USER_TEXT, session.getUserText());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FALLBACK_STATE, fallbackState);\n          audit.audit(ConvEngineAuditStage.STATE_MISSING, session.getConversationId(), payload);\n          session.setState(fallbackState);\n      }\n\n      session.getConversation().setIntentCode(session.getIntent());\n      session.getConversation().setStateCode(session.getState());\n      return new StepResult.Continue();\n  }"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"15"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"AddContainerDataStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Fetch and attach container data",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"containerData/context merge"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_container_config"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Bridges static tenant/consumer configurations. Evaluates ",(0,i.jsx)(n.code,{children:"ce_container_config"})," to pull any global JSON context relevant to the intent and merges it directly into ",(0,i.jsx)(n.code,{children:"session.contextJson"}),'. This allows things like "Store Hours" or "Region Policies" to be globally attached to all LLM contexts without hardcoding.']}),(0,i.jsx)(a.vl,{title:"AddContainerDataStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/AddContainerDataStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n\n      List<CeContainerConfig> configs =\n              containerConfigRepo.findByIntentAndState(\n                      session.getIntent(),\n                      session.getState()\n              );\n\n      if (configs.isEmpty()) {\n          configs = containerConfigRepo.findFallbackByState(session.getState());\n      }\n\n      if (configs.isEmpty()) {\n          configs = containerConfigRepo.findGlobalFallback();\n      }\n\n      if (configs.isEmpty()) {\n          Map<String, Object> reasonMap = new HashMap<>();\n          reasonMap.put("reason", "no container configs for intent/state");\n          reasonMap.put("intent", session.getIntent());\n          reasonMap.put("state", session.getState());\n          audit.audit(\n                  "CONTAINER_DATA_SKIPPED",\n                  session.getConversationId(),\n                  reasonMap\n          );\n          return new StepResult.Continue();\n      }\n\n      ObjectNode containerRoot = mapper.createObjectNode();\n\n      for (CeContainerConfig cfg : configs) {\n\n          try {\n              Map<String, Object> inputParams = new HashMap<>();\n              String key = cfg.getInputParamName();\n              Object value = session.extractValueFromContext(key);\n              if(value == null) {\n                  value = session.getUserText();\n              }\n              inputParams.put(key, value);\n              if (session.getInputParams() != null) {\n                  inputParams.putAll(session.getInputParams());\n              }\n              if (session.getEngineContext().getInputParams() != null) {\n                  inputParams.putAll(session.getEngineContext().getInputParams());\n              }\n\n              PageInfoRequest pageInfo = PageInfoRequest.builder()\n                                              .userId("convengine")\n                                              .loggedInUserId("convengine")\n                                              .pageId(cfg.getPageId())\n                                              .sectionId(cfg.getSectionId())\n                                              .containerId(cfg.getContainerId())\n                                              .inputParams(inputParams)\n                                              .build();\n\n              ContainerComponentRequest req = new ContainerComponentRequest();\n              req.setPageInfo(List.of(pageInfo));\n              req.setRequestTypes(List.of(RequestType.CONTAINER));\n              interceptorExecutor.beforeExecute(req, session);\n              ContainerComponentResponse resp = ccfCoreService.execute(req);\n              resp = interceptorExecutor.afterExecute(resp, session);\n              // find classes with @ContainerDataTransformer(state, intent) to transform resp if needed\n              Map<String, Object> transformedData = transformerService.transformIfApplicable(resp, session, inputParams);\n              JsonNode responseNode = transformedData == null ? mapper.valueToTree(resp) : mapper.valueToTree(transformedData);\n              session.setContainerData(responseNode);\n              containerRoot.set(cfg.getInputParamName(), responseNode);\n              Map<String, Object> jsonMap = Map.of(\n                      "containerId", cfg.getContainerId(),\n                      "pageId", cfg.getPageId(),\n                      "sectionId", cfg.getSectionId(),\n                      "inputParam", cfg.getInputParamName(),\n                      "requestInput", inputParams,\n                      "response", responseNode\n              );\n              audit.audit(\n                      "CONTAINER_DATA_EXECUTED",\n                      session.getConversationId(),\n                      jsonMap\n              );\n\n          } catch (Exception e) {\n              Map<String, Object> errorJsonMap = new HashMap<>();\n              errorJsonMap.put("containerId", cfg.getContainerId());\n              errorJsonMap.put("error", e.getMessage());\n              audit.audit(\n                      "CONTAINER_DATA_FAILED",\n                      session.getConversationId(),\n                      errorJsonMap\n              );\n          }\n      }\n\n      if (!containerRoot.isEmpty()) {\n\n          // attach to session\n          session.setContainerDataJson(containerRoot.toString());\n          session.setHasContainerData(true);\n\n          // merge into conversation context\n          try {\n              ObjectNode ctx = (ObjectNode) mapper.readTree(session.getContextJson());\n              ctx.set("container_data", containerRoot);\n              session.setContextJson(mapper.writeValueAsString(ctx));\n              session.getConversation().setContextJson(session.getContextJson());\n          } catch (Exception ignore) {\n              // context merge failure should not break pipeline\n          }\n\n          audit.audit(\n                  "CONTAINER_DATA_ATTACHED",\n                  session.getConversationId(),\n                  containerRoot.toString()\n          );\n      }\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"16"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"PendingActionStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Execute/reject pending action task",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"pending_action_runtime status/result"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_pending_action, CeTaskExecutor, ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Executes Java code. If the InteractionPolicy is ",(0,i.jsx)(n.code,{children:"EXECUTE_PENDING_ACTION"})," and the status is ",(0,i.jsx)(n.code,{children:"IN_PROGRESS"}),", this step resolves the Spring Bean ID attached to the ",(0,i.jsx)(n.code,{children:"ce_pending_action"})," row."]}),(0,i.jsxs)(n.p,{children:["It invokes ",(0,i.jsx)(n.code,{children:"CeTaskExecutor.execute()"}),", runs the backend transaction (e.g. Stripe Refund), and captures the boolean/json result back into the engine ",(0,i.jsx)(n.code,{children:"EngineSession"})," context for downstream rules to evaluate."]}),(0,i.jsx)(a.vl,{title:"PendingActionStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/PendingActionStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_PENDING_ACTION_EXECUTION))\n              || Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.GUARDRAIL_BLOCKED))) {\n          Map<String, Object> payload = basePayload(session, InteractionPolicyDecision.RECLASSIFY_INTENT, null);\n          payload.put(ConvEnginePayloadKey.REASON, "pending action skipped by guardrail");\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_SKIPPED, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      String decisionRaw = session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION);\n      InteractionPolicyDecision decision = parseDecision(decisionRaw);\n      if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION\n              && decision != InteractionPolicyDecision.REJECT_PENDING_ACTION) {\n          return new StepResult.Continue();\n      }\n\n      Map<String, Object> context = session.contextDict();\n      Object pendingAction = context.get("pending_action");\n      if (pendingAction == null) {\n          pendingAction = context.get("pendingAction");\n      }\n\n      String actionKey = resolveActionKey(session, context, pendingAction);\n      String actionRef = resolveActionReference(session, pendingAction, actionKey);\n      if (actionRef == null || actionRef.isBlank()) {\n          Map<String, Object> payload = basePayload(session, decision, null);\n          payload.put("actionKey", actionKey);\n          payload.put(ConvEnginePayloadKey.REASON, actionKey == null || actionKey.isBlank()\n                  ? "pending action reference not found or ambiguous registry mapping"\n                  : "pending action reference not found");\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_SKIPPED, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) {\n          session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "REJECTED");\n          updateRuntimeStatus(session, PendingActionStatus.REJECTED);\n          Map<String, Object> payload = basePayload(session, decision, actionRef);\n          payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "REJECTED");\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_REJECTED, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      String[] taskRef = parseTaskReference(actionRef);\n      if (taskRef == null) {\n          session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "FAILED");\n          Map<String, Object> payload = basePayload(session, decision, actionRef);\n          payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "FAILED");\n          payload.put(ConvEnginePayloadKey.REASON, "invalid pending action reference");\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_FAILED, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      Object executionResult = ceTaskExecutor.execute(taskRef[0], taskRef[1], session);\n      if (executionResult == null) {\n          session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "FAILED");\n          Map<String, Object> payload = basePayload(session, decision, actionRef);\n          payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "FAILED");\n          payload.put(ConvEnginePayloadKey.REASON, "task execution returned null");\n          audit.audit(ConvEngineAuditStage.PENDING_ACTION_FAILED, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "EXECUTED");\n      updateRuntimeStatus(session, PendingActionStatus.EXECUTED);\n      Map<String, Object> payload = basePayload(session, decision, actionRef);\n      payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "EXECUTED");\n      payload.put("taskBean", taskRef[0]);\n      payload.put("taskMethods", taskRef[1]);\n      audit.audit(ConvEngineAuditStage.PENDING_ACTION_EXECUTED, session.getConversationId(), payload);\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"17"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"ToolOrchestrationStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Run tool_group based orchestration",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"tool_request/tool_result fields"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_tool, ce_mcp_tool, ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["The gateway for Model Context Protocol (MCP) tooling. If ",(0,i.jsx)(n.code,{children:"ce_tool"})," specifies that this intent requires a ",(0,i.jsx)(n.code,{children:"tool_group"}),", this step binds the request and delegates to an external executor. It pauses the LLM, executes the backend SQL or REST fetch, and dumps the massive JSON result into ",(0,i.jsx)(n.code,{children:"tool_result"})," dictionary in context."]}),(0,i.jsx)(a.vl,{title:"ToolOrchestrationStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/ToolOrchestrationStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (!flowConfig.getToolOrchestration().isEnabled()) {\n          return new StepResult.Continue();\n      }\n      if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION))) {\n          return new StepResult.Continue();\n      }\n\n      ToolRequest request = resolveRequest(session);\n      if (request == null) {\n          return new StepResult.Continue();\n      }\n\n      session.putInputParam(ConvEngineInputParamKey.TOOL_REQUEST, request.toMap());\n      audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_REQUEST, session.getConversationId(), request.toMap());\n\n      try {\n          CeMcpTool tool = request.toolCode() == null || request.toolCode().isBlank()\n                  ? null\n                  : registry.requireTool(request.toolCode(), session.getIntent(), session.getState());\n          String group = request.toolGroup();\n          if ((group == null || group.isBlank()) && tool != null) {\n              group = registry.normalizeToolGroup(tool.getToolGroup());\n          }\n          if (group == null || group.isBlank()) {\n              throw new IllegalStateException("tool_group is required when tool_code is not resolvable");\n          }\n\n          McpToolExecutor executor = resolveExecutor(group);\n          String resultJson = executor.execute(tool, request.args(), session);\n\n          Map<String, Object> result = new LinkedHashMap<>();\n          result.put("status", "SUCCESS");\n          result.put("tool_code", request.toolCode());\n          result.put("tool_group", group);\n          result.put("result", parseJsonOrString(resultJson));\n          session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);\n          session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "SUCCESS");\n          audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_RESULT, session.getConversationId(), result);\n\n          rulesStep.applyRules(session, "ToolOrchestrationStep PostTool", RulePhase.POST_TOOL_EXECUTION.name());\n      } catch (IllegalStateException e) {\n          if (e.getMessage() != null && e.getMessage().contains("Missing enabled MCP tool for current intent/state")) {\n              Map<String, Object> result = new LinkedHashMap<>();\n              result.put("status", "SKIPPED_SCOPE_MISMATCH");\n              result.put("tool_code", request.toolCode());\n              result.put("tool_group", request.toolGroup());\n              result.put("intent", session.getIntent());\n              result.put("state", session.getState());\n              session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);\n              session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "SKIPPED_SCOPE_MISMATCH");\n              audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_RESULT, session.getConversationId(), result);\n              return new StepResult.Continue();\n          }\n          Map<String, Object> result = new LinkedHashMap<>();\n          result.put("status", "ERROR");\n          result.put("tool_code", request.toolCode());\n          result.put("tool_group", request.toolGroup());\n          result.put("error", String.valueOf(e.getMessage()));\n          session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);\n          session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "ERROR");\n          audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_ERROR, session.getConversationId(), result);\n      } catch (Exception e) {\n          Map<String, Object> result = new LinkedHashMap<>();\n          result.put("status", "ERROR");\n          result.put("tool_code", request.toolCode());\n          result.put("tool_group", request.toolGroup());\n          result.put("error", String.valueOf(e.getMessage()));\n          session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);\n          session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "ERROR");\n          audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_ERROR, session.getConversationId(), result);\n      }\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"18"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"McpToolStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," MCP planner/tool loop",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"context_json.mcp.*"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_mcp_tool, ce_mcp_db_tool, ce_mcp_planner (fallback ce_config)"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Specifically iterates over ",(0,i.jsx)(n.code,{children:"ce_mcp_tool"})," bindings. Instead of static grouped tools, this triggers an agent planner that interprets the input, selects an MCP tool, writes the payload, and executes it. This is the core of dynamic tool use in ConvEngine V2."]}),(0,i.jsx)(a.vl,{title:"McpToolStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/McpToolStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION))\n              || Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.GUARDRAIL_BLOCKED))) {\n          session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "SKIPPED_BY_GUARDRAIL");\n          return new StepResult.Continue();\n      }\n\n      if (session.hasPendingClarification()) {\n          audit.audit(\n                  ConvEngineAuditStage.MCP_SKIPPED_PENDING_CLARIFICATION,\n                  session.getConversationId(),\n                  mapOf(\n                          "intent", session.getIntent(),\n                          "state", session.getState()\n                  )\n          );\n          return new StepResult.Continue();\n      }\n\n      List<CeMcpTool> tools = registry.listEnabledTools(session.getIntent(), session.getState());\n\n      if (CollectionUtils.isEmpty(tools)) {\n          session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "NO_TOOLS_FOR_SCOPE");\n          audit.audit(ConvEngineAuditStage.MCP_NO_TOOLS_AVAILABLE, session.getConversationId(),\n                  mapOf("intent", session.getIntent(), "state", session.getState()));\n          return new StepResult.Continue();\n      }\n\n      clearMcpContext(session);\n      List<McpObservation> observations = readObservationsFromContext(session);\n      boolean mcpTouched = false;\n\n      for (int i = 0; i < MAX_LOOPS; i++) {\n\n          McpPlan plan = planner.plan(session, tools, observations);\n          mcpTouched = true;\n          session.putInputParam(ConvEngineInputParamKey.MCP_ACTION, plan.action());\n          session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_CODE, plan.tool_code());\n          session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_ARGS, plan.args() == null ? Map.of() : plan.args());\n\n          if ("ANSWER".equalsIgnoreCase(plan.action())) {\n              // store final answer in contextJson; your ResponseResolutionStep can use it via derivation_hint\n              writeFinalAnswerToContext(session, plan.answer());\n              session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, plan.answer() == null ? "" : plan.answer());\n              session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "ANSWER");\n              audit.audit(\n                      ConvEngineAuditStage.MCP_FINAL_ANSWER,\n                      session.getConversationId(),\n                      mapOf("answer", plan.answer())\n              );\n              break;\n          }\n\n          if (!"CALL_TOOL".equalsIgnoreCase(plan.action())) {\n              writeFinalAnswerToContext(session, "I couldn\'t decide the next tool step safely.");\n              session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, "I couldn\'t decide the next tool step safely.");\n              session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "FALLBACK");\n              break;\n          }\n\n          String toolCode = plan.tool_code();\n          Map<String, Object> args = (plan.args() == null) ? Map.of() : plan.args();\n\n          audit.audit(\n                  ConvEngineAuditStage.MCP_TOOL_CALL,\n                  session.getConversationId(),\n                  mapOf("tool_code", toolCode, "args", args)\n          );\n\n          CeMcpTool tool = registry.requireTool(toolCode, session.getIntent(), session.getState());\n          String toolGroup = registry.normalizeToolGroup(tool.getToolGroup());\n          session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_GROUP, toolGroup);\n\n          try {\n              McpToolExecutor executor = resolveExecutor(toolGroup);\n              String rowsJson = executor.execute(tool, args, session);\n\n              observations.add(new McpObservation(toolCode, rowsJson));\n              writeObservationsToContext(session, observations);\n              session.putInputParam(ConvEngineInputParamKey.MCP_OBSERVATIONS, observations);\n              session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "TOOL_RESULT");\n\n              audit.audit(\n                  ConvEngineAuditStage.MCP_TOOL_RESULT,\n                  session.getConversationId(),\n                  mapOf("tool_code", toolCode, "tool_group", toolGroup, "rows", rowsJson)\n              );\n\n          } catch (Exception e) {\n              audit.audit(\n                      ConvEngineAuditStage.MCP_TOOL_ERROR,\n                      session.getConversationId(),\n                      mapOf("tool_code", toolCode, "tool_group", toolGroup, "error", String.valueOf(e.getMessage()))\n              );\n              writeFinalAnswerToContext(session, "Tool execution failed safely. Can you narrow the request?");\n              session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, "Tool execution failed safely. Can you narrow the request?");\n              session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "TOOL_ERROR");\n              break;\n          }\n      }\n\n      if (mcpTouched) {\n          rulesStep.applyRules(session, "McpToolStep", RulePhase.POST_AGENT_MCP.name());\n      }\n\n      session.syncToConversation();\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"19"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"SchemaExtractionStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Schema-driven extraction and lock handling",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"schema facts/context/lock"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_output_schema, ce_prompt_template"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Evaluates ",(0,i.jsx)(n.code,{children:"ce_output_schema"}),". It injects the missing required slots into an LLM extracting prompt using ",(0,i.jsx)(n.code,{children:"ce_prompt_template"}),". The LLM returns a structured JSON map. This step merges it with ",(0,i.jsx)(n.code,{children:"session.contextJson"}),"."]}),(0,i.jsx)(n.p,{children:"Prompt-template usage details:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["selects ",(0,i.jsx)(n.code,{children:"ce_prompt_template"})," with ",(0,i.jsx)(n.code,{children:"response_type=SCHEMA_JSON"})," for the same ",(0,i.jsx)(n.code,{children:"intent_code + state_code"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interaction_mode=COLLECT"})," is the recommended semantic marker for these templates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interaction_contract"})," can declare ",(0,i.jsx)(n.code,{children:'expects:["structured_input"]'})," so the template contract remains explicit in configuration"]}),"\n",(0,i.jsxs)(n.li,{children:["after merge, ",(0,i.jsx)(n.code,{children:"POST_SCHEMA_EXTRACTION"})," rules can move the state or set runtime flags"]}),"\n"]}),(0,i.jsxs)(n.p,{children:["It then runs ",(0,i.jsx)(n.code,{children:"missingFieldEvaluator.evaluate()"}),". If fields are missing, it sets ",(0,i.jsx)(n.code,{children:"session.setSchemaLocked(true)"}),"."]}),(0,i.jsx)(a.vl,{title:"SchemaExtractionStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/SchemaExtractionStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n\n      String intent = session.getIntent();\n      String state = session.getState();\n\n      CeOutputSchema schema = outputSchemaRepo.findAll().stream()\n              .filter(s -> Boolean.TRUE.equals(s.getEnabled()))\n              .filter(s -> equalsIgnoreCase(s.getIntentCode(), intent))\n              .filter(s -> equalsIgnoreCase(s.getStateCode(), state) || equalsIgnoreCase(s.getStateCode(), "ANY"))\n              .min((a, b) -> Integer.compare(priorityOf(a), priorityOf(b)))\n              .orElse(null);\n\n      if (schema != null) {\n          runExtraction(session, schema);\n      } else {\n          session.unlockIntent();\n          session.setResolvedSchema(null);\n          session.setSchemaComplete(false);\n          session.setSchemaHasAnyValue(false);\n          session.setMissingRequiredFields(new ArrayList<>());\n          session.setMissingFieldOptions(new LinkedHashMap<>());\n          session.addPromptTemplateVars();\n      }\n\n      session.syncFromConversation(true);\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"20"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"AutoAdvanceStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Compute schema status facts",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"schemaComplete/hasAny"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"resolved schema + context"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["In V1, rules had to manually check if schema extraction was done. In V2, this step computes the boolean flags ",(0,i.jsx)(n.code,{children:"schemaComplete"})," and ",(0,i.jsx)(n.code,{children:"hasAny"})," and binds them to the session context. This allows ",(0,i.jsx)(n.code,{children:"ce_rule"})," to simply trigger on ",(0,i.jsx)(n.code,{children:"schemaComplete == true"}),"."]}),(0,i.jsx)(a.vl,{title:"AutoAdvanceStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/AutoAdvanceStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n\n      if (session.getResolvedSchema() == null) {\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, "no schema resolved");\n          audit.audit(ConvEngineAuditStage.AUTO_ADVANCE_SKIPPED_NO_SCHEMA, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      String schemaJson = session.getResolvedSchema().getJsonSchema();\n      String contextJson = session.getContextJson();\n\n      boolean hasAnySchemaValue = JsonUtil.hasAnySchemaValue(contextJson, schemaJson);\n      boolean schemaComplete = JsonUtil.isSchemaComplete(schemaJson, contextJson);\n      session.setSchemaHasAnyValue(hasAnySchemaValue);\n      session.setSchemaComplete(schemaComplete);\n\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_COMPLETE, schemaComplete);\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.HAS_ANY_SCHEMA_VALUE, hasAnySchemaValue);\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n      audit.audit(ConvEngineAuditStage.AUTO_ADVANCE_FACTS, session.getConversationId(), payload);\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"21"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"RulesStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Match and apply transitions/actions",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"intent/state/input params"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_rule"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["The core state-machine driver. It queries ",(0,i.jsx)(n.code,{children:"ce_rule"})," for the current Intent and State.\nIt evaluates expressions (like ",(0,i.jsx)(n.code,{children:"JSON_PATH"})," or ",(0,i.jsx)(n.code,{children:"REGEX"}),") against the ",(0,i.jsx)(n.code,{children:"session.contextJson"}),"."]}),(0,i.jsxs)(n.p,{children:["If a rule matches, it executes the target ",(0,i.jsx)(n.code,{children:"action"})," (e.g. ",(0,i.jsx)(n.code,{children:"SET_STATE"})," to ",(0,i.jsx)(n.code,{children:"CONFIRMATION"}),", or ",(0,i.jsx)(n.code,{children:"SET_TASK"}),'). It loops until no more rules match, effectively "auto-advancing" state machine nodes.']}),(0,i.jsx)(a.vl,{title:"RulesStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/RulesStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      applyRules(session, "RulesStep", RulePhase.PRE_RESPONSE_RESOLUTION.name());\n      session.syncToConversation();\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"22"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"StateGraphStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Validate state transition path",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"state_graph_valid/reason"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_state_graph, ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["A strict validater. Checks ",(0,i.jsx)(n.code,{children:"ce_state_graph"})," to see if the transition that just occurred in ",(0,i.jsx)(n.code,{children:"RulesStep"})," was legally defined by the developer. If a rule jumped from ",(0,i.jsx)(n.code,{children:"IDLE"})," to ",(0,i.jsx)(n.code,{children:"CANCELLED"})," but there is no edge in the graph, this step logs an error and optionally reverts the state to prevent invalid transitions."]}),(0,i.jsx)(a.vl,{title:"StateGraphStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/StateGraphStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (!flowConfig.getStateGraph().isEnabled()) {\n          return new StepResult.Continue();\n      }\n      String fromState = session.getConversation() == null ? null : session.getConversation().getStateCode();\n      String toState = session.getState();\n\n      if (fromState == null || fromState.isBlank() || toState == null || toState.isBlank()\n              || fromState.equalsIgnoreCase(toState)) {\n          return new StepResult.Continue();\n      }\n\n      boolean allowed = isAllowedTransition(fromState, toState);\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put("fromState", fromState);\n      payload.put("toState", toState);\n      payload.put("intent", session.getIntent());\n      payload.put("validateOnly", true);\n\n      if (allowed) {\n          session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_VALID, true);\n          payload.put("allowed", true);\n          audit.audit(ConvEngineAuditStage.STATE_GRAPH_VALID, session.getConversationId(), payload);\n          return new StepResult.Continue();\n      }\n\n      payload.put("allowed", false);\n      payload.put("softBlock", flowConfig.getStateGraph().isSoftBlockOnViolation());\n      audit.audit(ConvEngineAuditStage.STATE_GRAPH_VIOLATION, session.getConversationId(), payload);\n      session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_VALID, false);\n      if (flowConfig.getStateGraph().isSoftBlockOnViolation()) {\n          session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_SOFT_BLOCK, true);\n      }\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"23"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"ResponseResolutionStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Resolve and generate output payload",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"payload/last assistant json"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_response, ce_prompt_template"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["The final output generator. Queries ",(0,i.jsx)(n.code,{children:"ce_response"})," for the current intent and state."]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"TEXT"}),": Returns a hardcoded string."]}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"DERIVED"}),": Loads ",(0,i.jsx)(n.code,{children:"ce_prompt_template"}),", injects the ",(0,i.jsx)(n.code,{children:"contextJson"}),", ",(0,i.jsx)(n.code,{children:"tool_result"}),", and ",(0,i.jsx)(n.code,{children:"schema"}),", and asks the LLM to write a fluid, contextual response to the user."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interaction_mode"})," does not change template lookup, but it should describe the intended turn semantics for the selected state (",(0,i.jsx)(n.code,{children:"CONFIRM"}),", ",(0,i.jsx)(n.code,{children:"PROCESSING"}),", ",(0,i.jsx)(n.code,{children:"FINAL"}),", etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interaction_contract"})," is where consumers should declare capabilities such as ",(0,i.jsx)(n.code,{children:"retry"})," on ",(0,i.jsx)(n.code,{children:"PROCESSING"})," prompts or ",(0,i.jsx)(n.code,{children:"affirm/edit"})," on ",(0,i.jsx)(n.code,{children:"CONFIRM"})," prompts\nSets ",(0,i.jsx)(n.code,{children:"session.getConversation().setLastAssistantJson()"})," with the payload."]}),"\n"]}),(0,i.jsx)(a.vl,{title:"ResponseResolutionStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/ResponseResolutionStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n\n      if(AgentIntentResolver.INTENT_COLLISION_STATE.equals(session.getState())) {\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n          audit.audit(\n                  ConvEngineAuditStage.INTENT_COLLISION_DETECTED,\n                  session.getConversationId(),\n                  payload\n          );\n          agentIntentCollisionResolver.resolve(session);\n          return new StepResult.Continue();\n      }\n\n      Optional<CeResponse> responseOptional = resolveResponse(session);\n\n      if(responseOptional.isEmpty()) {\n          Map<String, Object> payload = new LinkedHashMap<>();\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n          payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n          audit.audit(\n                  ConvEngineAuditStage.RESPONSE_MAPPING_NOT_FOUND,\n                  session.getConversationId(),\n                  payload\n          );\n          throw new ConversationEngineException(\n                  ConversationEngineErrorCode.RESPONSE_MAPPING_NOT_FOUND,\n                  "No response found for intent=" + session.getIntent() + ", state=" + session.getState()\n          );\n      }\n      CeResponse resp = responseOptional.get();\n      if (!matches(resp.getStateCode(), session.getState()) && !matches(resp.getStateCode(), "ANY")) {\n          session.setState(resp.getStateCode());\n          session.getConversation().setStateCode(resp.getStateCode());\n      }\n      Map<String, Object> responsePayload = new LinkedHashMap<>();\n      responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId());\n      responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n      responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n      audit.audit(\n              ConvEngineAuditStage.RESOLVE_RESPONSE,\n              session.getConversationId(),\n              responsePayload\n      );\n      List<ConversationTurn> conversationTurns = historyProvider.lastTurns(session.getConversationId(), 10);\n      session.setConversationHistory(conversationTurns);\n\n\n\n      CePromptTemplate template = null;\n      if(ResponseType.DERIVED.name().equalsIgnoreCase(resp.getResponseType())) {\n          template = promptRepo.findAll().stream()\n                  .filter(t -> Boolean.TRUE.equals(t.getEnabled()))\n                  .filter(t -> resp.getOutputFormat().equalsIgnoreCase(t.getResponseType()))\n                  .filter(t -> matchesOrNull(t.getIntentCode(), session.getIntent()))\n                  .filter(t -> matchesOrNull(t.getStateCode(), session.getState()) || matches(t.getStateCode(), "ANY"))\n                  .max(Comparator.comparingInt(t -> score(t, session)))\n                  .orElseThrow(() ->\n                          new IllegalStateException(\n                                  "No ce_prompt_template found for response_type=" +\n                                          resp.getOutputFormat() + ", intent=" + session.getIntent() + ", state=" + session.getState()\n                          )\n                  );\n      }\n      typeFactory\n              .get(resp.getResponseType())\n              .resolve(session, PromptTemplate.initFrom(template), ResponseTemplate.initFrom(resp));\n\n\n      OutputPayload transformedOutput = responseTransformerService.transformIfApplicable(session.getPayload(), session, session.getInputParams());\n      session.setPayload(transformedOutput);\n\n      Object payloadValue = switch (session.getPayload()) {\n          case TextPayload(String text) -> text;\n          case JsonPayload(String json) -> json;\n          case null -> null;\n      };\n\n      Map<String, Object> outputPayload = new LinkedHashMap<>();\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT, payloadValue);\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT_FORMAT, resp.getOutputFormat());\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_TYPE, resp.getResponseType());\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId());\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict());\n      outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_JSON, session.schemaJson());\n      audit.audit(ConvEngineAuditStage.ASSISTANT_OUTPUT, session.getConversationId(), outputPayload);\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"24"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"MemoryStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Write memory/session summary",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"memory.session_summary in context"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_memory, ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Evaluates the rolling history. If ",(0,i.jsx)(n.code,{children:"ce_memory"})," is configured, and ",(0,i.jsx)(n.code,{children:"recentTurns"})," exceeds the threshold, this step fires off a summarization prompt to the LLM. It compresses the last N turns into a dense paragraph and saves it as ",(0,i.jsx)(n.code,{children:"memory.session_summary"})," in the context JSON, enabling infinite-context retention without blowing up token limits."]}),(0,i.jsx)(a.vl,{title:"MemoryStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/MemoryStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n      if (!flowConfig.getMemory().isEnabled()) {\n          return new StepResult.Continue();\n      }\n\n      String recalled = null;\n      for (ConversationMemoryStore store : memoryStores) {\n          try {\n              String value = store.read(session);\n              if (value != null && !value.isBlank()) {\n                  recalled = value;\n                  break;\n              }\n          } catch (Exception ignored) {\n          }\n      }\n      if (recalled != null) {\n          session.putInputParam(ConvEngineInputParamKey.MEMORY_RECALL, recalled);\n      }\n\n      String summary = buildSummary(session);\n      if (summary.length() > flowConfig.getMemory().getSummaryMaxChars()) {\n          summary = summary.substring(0, flowConfig.getMemory().getSummaryMaxChars());\n      }\n      session.putInputParam(ConvEngineInputParamKey.MEMORY_SESSION_SUMMARY, summary);\n\n      ObjectNode root = contextHelper.readRoot(session);\n      ObjectNode memoryNode = contextHelper.ensureObject(root, "memory");\n      memoryNode.put("session_summary", summary);\n      if (recalled != null) {\n          memoryNode.put("recalled_summary", recalled);\n      }\n      contextHelper.writeRoot(session, root);\n\n      for (ConversationMemoryStore store : memoryStores) {\n          try {\n              store.write(session, summary);\n          } catch (Exception ignored) {\n          }\n      }\n\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put("summaryChars", summary.length());\n      payload.put("recalled", recalled != null);\n      payload.put("stores", memoryStores.size());\n      payload.put("intent", session.getIntent());\n      payload.put("state", session.getState());\n      audit.audit(ConvEngineAuditStage.MEMORY_UPDATED, session.getConversationId(), payload);\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"25"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"PersistConversationStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Persist final conversation and result",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"finalResult"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_conversation"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["The database commit step. Writes the ",(0,i.jsx)(n.code,{children:"CeConversation"})," row, saving the mutated ",(0,i.jsx)(n.code,{children:"contextJson"}),", ",(0,i.jsx)(n.code,{children:"inputParams"}),", new ",(0,i.jsx)(n.code,{children:"intentCode"}),", and ",(0,i.jsx)(n.code,{children:"stateCode"}),". The step is placed at the end so if an exception occurs mid-pipeline, the corrupted context is ignored and rolled back natively."]}),(0,i.jsx)(a.vl,{title:"PersistConversationStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/PersistConversationStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n\n      // --- sanity check ---\n      if (session.getPayload() == null) {\n          throw new ConversationEngineException(\n                  ConversationEngineErrorCode.PIPELINE_NO_RESPONSE_PAYLOAD,\n                  "Engine pipeline ended without payload. ResponseResolutionStep did not run."\n          );\n      }\n\n      // --- persist conversation ---\n      sanitizeConversationForPostgres(session);\n      session.getConversation().setStatus("RUNNING");\n      session.getConversation().setUpdatedAt(OffsetDateTime.now());\n      session.getConversation().setInputParamsJson(session.ejectInputParamsJson());\n      conversationRepo.save(session.getConversation());\n\n      // --- build FINAL EngineResult ---\n      EngineResult result = new EngineResult(\n              session.getIntent(),\n              session.getState(),\n              session.getPayload(),\n              session.getContextJson()\n      );\n\n      session.setFinalResult(result);\n\n      Map<String, Object> payload = new LinkedHashMap<>();\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());\n      payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FINAL_RESULT, result);\n      audit.audit(ConvEngineAuditStage.ENGINE_RETURN, session.getConversationId(), payload);\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)("div",{className:"ce-step-badge-list",role:"list",style:{marginBottom:"1rem"},children:(0,i.jsxs)("div",{className:"ce-step-badge-item",children:[(0,i.jsx)("span",{className:"ce-step-badge-index",children:"26"}),(0,i.jsx)("span",{className:"ce-step-badge-label",style:{fontSize:"1.2rem",fontWeight:"bold"},children:"PipelineEndGuardStep"})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Responsibility:"})," Timing audit + terminal guard",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Session Mutations:"})," ",(0,i.jsx)(n.code,{children:"timings"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Config/Table Dependencies:"})," ",(0,i.jsx)(n.code,{children:"ce_audit"})]}),"\n",(0,i.jsxs)(t,{open:!0,children:[(0,i.jsx)("summary",{children:"Detailed Execution Logic"}),(0,i.jsxs)(n.p,{children:["Timing and safety metrics. Audits the total millisecond execution time from Step 1 to 25. Fires the ",(0,i.jsx)(n.code,{children:"PIPELINE_COMPLETE"})," audit log. Verifies that the resulting payload isn't null."]}),(0,i.jsx)(a.vl,{title:"PipelineEndGuardStep.execute()",language:"java",filePath:"src/main/java/com/github/salilvnair/convengine/engine/steps/PipelineEndGuardStep.java",defaultOpen:!0,children:'public StepResult execute(EngineSession session) {\n\n      // Sort by start time just in case\n      session.getStepTimings().sort(Comparator.comparingLong(StepTiming::getStartedAtNs));\n\n      long totalMs = session.getStepTimings().stream().mapToLong(StepTiming::getDurationMs).sum();\n\n      // Log in app logs\n      String timingLine = session.getStepTimings().stream()\n              .map(t -> t.getStepName() + "=" + t.getDurationMs() + "ms" + (t.isSuccess() ? "" : "(ERR)"))\n              .reduce((a, b) -> a + ", " + b)\n              .orElse("");\n\n      log.info("ConvEngine timings convId={} total={}ms [{}]",\n              session.getConversationId(), totalMs, timingLine);\n\n      // Optional audit row (single compact record)\n      String payload = "{"totalMs":" + totalMs +\n              ","steps":"" + JsonUtil.escape(timingLine) + ""}";\n\n      audit.audit(ConvEngineAuditStage.PIPELINE_TIMING, session.getConversationId(), payload);\n\n      return new StepResult.Continue();\n  }'})]}),"\n",(0,i.jsx)(n.hr,{})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);