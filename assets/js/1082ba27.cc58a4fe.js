"use strict";(globalThis.webpackChunkconvengine_docs=globalThis.webpackChunkconvengine_docs||[]).push([[4],{6977(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>t,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"consumer/caching-and-persistence","title":"Caching & Persistence","description":"ConvEngine v2 is heavily optimized to decouple real-time generative latency from slow relational database I/O. The framework accomplishes this by utilizing Asynchronous Persistence Threads alongside Spring\'s Abstract CacheManager.","source":"@site/docs/v2/consumer/caching-and-persistence.mdx","sourceDirName":"consumer","slug":"/consumer/caching-and-persistence","permalink":"/docs/v2/consumer/caching-and-persistence","draft":false,"unlisted":false,"editUrl":"https://github.com/salilvnair/convengine-docs/tree/main/docs/v2/consumer/caching-and-persistence.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Caching & Persistence","sidebar_position":4}}');var r=i(4848),c=i(8453),s=i(9131);const t={title:"Caching & Persistence",sidebar_position:4},o="Caching & Persistence",l={},d=[{value:"Default Configuration (HashMap)",id:"default-configuration-hashmap",level:2},{value:"1. Ehcache 3 (JSR-107)",id:"1-ehcache-3-jsr-107",level:2},{value:"2. Caffeine Cache",id:"2-caffeine-cache",level:2},{value:"3. Redis",id:"3-redis",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"caching--persistence",children:"Caching & Persistence"})}),"\n",(0,r.jsxs)(n.p,{children:["ConvEngine v2 is heavily optimized to decouple real-time generative latency from slow relational database I/O. The framework accomplishes this by utilizing ",(0,r.jsx)(n.strong,{children:"Asynchronous Persistence Threads"})," alongside ",(0,r.jsx)(n.strong,{children:"Spring's Abstract CacheManager"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"To activate this optimization on your backend, add the following decorators to your application class:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(s.pu,{children:"@CeEnableCaching"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(s.pu,{children:"@CeEnableAsyncConversation"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.f4,{type:"tip",title:"How the abstraction works",children:(0,r.jsxs)(n.p,{children:["The actual datastore powering ",(0,r.jsx)(n.code,{children:"@CeEnableCaching"})," is ",(0,r.jsx)(n.strong,{children:"entirely controlled by the Consumer application"}),", not the ConvEngine framework. ConvEngine relies on the generic Spring `CacheManager` interface to save and load `CeConversation` instances via the `ce_conversation_cache` routing key."]})}),"\n",(0,r.jsx)(n.h2,{id:"default-configuration-hashmap",children:"Default Configuration (HashMap)"}),"\n",(0,r.jsxs)(n.p,{children:["By default, if you attach ",(0,r.jsx)(n.code,{children:"@CeEnableCaching"})," but do not import any external caching dependencies into your ",(0,r.jsx)(n.code,{children:"pom.xml"}),", Spring Boot falls back to a ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"ConcurrentMapCacheManager"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["This operates seamlessly out of the box. It holds conversation states inside a standard Java ",(0,r.jsx)(n.code,{children:"HashMap"})," residing in your server's active JVM memory."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Blazing fast (",(0,r.jsx)(n.code,{children:"0ms"})," read/write latency), requires zero configuration."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Cache is completely wiped if the Spring Boot application restarts or crashes; not horizontal-scale (multi-pod) friendly."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-ehcache-3-jsr-107",children:"1. Ehcache 3 (JSR-107)"}),"\n",(0,r.jsxs)(n.p,{children:["For robust, production-grade memory bounds, ",(0,r.jsx)(n.strong,{children:"Ehcache"})," is a highly recommended on-premise memory provider. It allows conversational payloads to spill over from the active ",(0,r.jsx)(n.code,{children:"heap"})," into ",(0,r.jsx)(n.code,{children:"offheap"})," memory to prevent JVM garbage collection thrashing during large multi-turn flows."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Dependency update (",(0,r.jsx)(n.code,{children:"pom.xml"}),")"]}),":"]}),"\n",(0,r.jsx)(s.vl,{title:"pom.xml",language:"xml",children:"<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n<dependency>\n  <groupId>javax.cache</groupId>\n  <artifactId>cache-api</artifactId>\n</dependency>\n<dependency>\n  <groupId>org.ehcache</groupId>\n  <artifactId>ehcache</artifactId>\n</dependency>"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["App configuration (",(0,r.jsx)(n.code,{children:"application.yml"}),")"]}),":"]}),"\n",(0,r.jsx)(s.vl,{title:"application.yml",language:"yaml",children:"spring:\ncache:\n  jcache:\n    config: classpath:ehcache.xml"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Provider specification (",(0,r.jsx)(n.code,{children:"src/main/resources/ehcache.xml"}),")"]}),":"]}),"\n",(0,r.jsx)(s.vl,{title:"ehcache.xml",language:"xml",children:'<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n      xmlns="http://www.ehcache.org/v3"\n      xmlns:jsr107="http://www.ehcache.org/v3/jsr107"\n      xsi:schemaLocation="\n          http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd\n          http://www.ehcache.org/v3/jsr107 http://www.ehcache.org/schema/ehcache-107-ext-3.0.xsd">\n\n  \x3c!-- This MUST exactly match ConvEngine\'s requested alias --\x3e\n  <cache alias="ce_conversation_cache">\n      <key-type>java.lang.String</key-type>\n      <value-type>com.github.salilvnair.convengine.entity.CeConversation</value-type>\n      <expiry>\n          <ttl unit="minutes">60</ttl>\n      </expiry>\n      <resources>\n          <heap unit="entries">2000</heap>\n          <offheap unit="MB">100</offheap>\n      </resources>\n  </cache>\n</config>'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-caffeine-cache",children:"2. Caffeine Cache"}),"\n",(0,r.jsxs)(n.p,{children:["If you prefer a highly optimized, high-performance local cache strictly contained inside the JVM (without off-heap spillage but statistically faster hit-rates than Ehcache), ",(0,r.jsx)(n.strong,{children:"Caffeine"})," is Spring Boot's default local provider replacement."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Dependency update (",(0,r.jsx)(n.code,{children:"pom.xml"}),")"]}),":"]}),"\n",(0,r.jsx)(s.vl,{title:"pom.xml",language:"xml",children:"<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n<dependency>\n  <groupId>com.github.ben-manes.caffeine</groupId>\n  <artifactId>caffeine</artifactId>\n</dependency>"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["App configuration (",(0,r.jsx)(n.code,{children:"application.yml"}),")"]}),":\nUnlike Ehcache, Caffeine can be fully initialized inside ",(0,r.jsx)(n.code,{children:"application.yml"})," without distinct XML files."]}),"\n",(0,r.jsx)(s.vl,{title:"application.yml",language:"yaml",children:"spring:\ncache:\n  type: caffeine\n  cache-names: ce_conversation_cache\n  caffeine:\n    # Max limits the cache to 5,000 conversational objects, expiring them 60 minutes after their last network write\n    spec: maximumSize=5000,expireAfterWrite=60m"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-redis",children:"3. Redis"}),"\n",(0,r.jsxs)(n.p,{children:["For horizontally scaled environments like Kubernetes (",(0,r.jsx)(n.code,{children:"k8s"}),") where your user traffic rotates across multiple server pods mid-conversation, you cannot use local memory (Ehcache/Caffeine). ",(0,r.jsx)(n.strong,{children:"Redis"})," binds ConvEngine's cache into an external centralized datastore."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Dependency update (",(0,r.jsx)(n.code,{children:"pom.xml"}),")"]}),":"]}),"\n",(0,r.jsx)(s.vl,{title:"pom.xml",language:"xml",children:"<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["App configuration (",(0,r.jsx)(n.code,{children:"application.yml"}),")"]}),":"]}),"\n",(0,r.jsx)(s.vl,{title:"application.yml",language:"yaml",children:'spring:\ndata:\n  redis:\n    host: localhost\n    port: 6379\ncache:\n  type: redis\n  redis:\n    time-to-live: 60m\n    cache-null-values: false\n    use-key-prefix: true\n    key-prefix: "convengine:"'}),"\n",(0,r.jsx)(s.f4,{type:"warning",title:"A note on serialization",children:(0,r.jsxs)(n.p,{children:["Because Redis runs outside the active server JVM, it relies on network transmission. You must ensure that your Spring application has a generic ",(0,r.jsx)(n.code,{children:"RedisTemplate"})," or Jackson-configured ",(0,r.jsx)(n.code,{children:"RedisCacheConfiguration"})," bean configured to serialize ",(0,r.jsx)(n.code,{children:"CeConversation"})," entities, otherwise Java will throw ",(0,r.jsx)(n.code,{children:"NotSerializableException"})," when attempting to push the object to the internet."]})})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);