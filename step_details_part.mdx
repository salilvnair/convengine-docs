
<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">1</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>LoadOrCreateConversationStep</span>
  </div>
</div>

**Responsibility:** Fetch or bootstrap conversation row  
**Session Mutations:** `conversation, intent/state/context sync`  
**Config/Table Dependencies:** `ce_conversation`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="LoadOrCreateConversationStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/LoadOrCreateConversationStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        UUID id = session.getConversationId();
        CeConversation convo = conversationRepo.findById(id).orElseGet(() -> createNewConversation(id, conversationRepo));

        convo.setLastUserText(session.getUserText());
        convo.setUpdatedAt(OffsetDateTime.now());

        session.setConversation(convo);
        session.syncFromConversation();

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">2</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ResetConversationStep</span>
  </div>
</div>

**Responsibility:** Early explicit reset  
**Session Mutations:** `intent/state/context/input params reset`  
**Config/Table Dependencies:** `input flags, command text`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="ResetConversationStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/ResetConversationStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (!shouldReset(session)) {
            return new StepResult.Continue();
        }

        String reason = resetReason(session);
        session.resetForConversationRestart();
        session.getConversation().setStatus("RUNNING");
        session.getConversation().setIntentCode("UNKNOWN");
        session.getConversation().setStateCode("UNKNOWN");
        session.getConversation().setContextJson("{}");
        session.getConversation().setInputParamsJson("{}");
        session.getConversation().setLastAssistantJson(null);
        session.getConversation().setUpdatedAt(OffsetDateTime.now());
        conversationRepository.save(session.getConversation());

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, reason);
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson());
        audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">3</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PersistConversationBootstrapStep</span>
  </div>
</div>

**Responsibility:** Ensure conversation row persisted  
**Session Mutations:** `none/metadata`  
**Config/Table Dependencies:** `ce_conversation`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="PersistConversationBootstrapStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/PersistConversationBootstrapStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (session.getConversation().getCreatedAt() == null) {
            session.getConversation().setCreatedAt(OffsetDateTime.now());
            session.getConversation().setUpdatedAt(OffsetDateTime.now());
            conversationRepo.save(session.getConversation());
        }
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">4</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>AuditUserInputStep</span>
  </div>
</div>

**Responsibility:** Persist user input audit  
**Session Mutations:** `none`  
**Config/Table Dependencies:** `ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="AuditUserInputStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/AuditUserInputStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.TEXT, session.getUserText());
        audit.audit(ConvEngineAuditStage.USER_INPUT, session.getConversationId(), payload);
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">5</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PolicyEnforcementStep</span>
  </div>
</div>

**Responsibility:** Policy block and stop  
**Session Mutations:** `payload + stop result on block`  
**Config/Table Dependencies:** `ce_policy`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="PolicyEnforcementStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/PolicyEnforcementStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        String userText = session.getUserText();

        for (CePolicy policy : policyRepo.findByEnabledTrueOrderByPriorityAsc()) {
            if (matches(policy.getRuleType(), policy.getPattern(), userText)) {
                Map<String, Object> payload = new LinkedHashMap<>();
                payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.POLICY_ID, policy.getPolicyId());
                payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RULE_TYPE, policy.getRuleType());
                payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.PATTERN, policy.getPattern());
                audit.audit(ConvEngineAuditStage.POLICY_BLOCK, session.getConversationId(), payload);

                session.getConversation().setStatus("BLOCKED");
                session.getConversation().setLastAssistantJson(jsonText(policy.getResponseText()));
                session.getConversation().setUpdatedAt(OffsetDateTime.now());
                conversationRepo.save(session.getConversation());

                EngineResult out = new EngineResult(
                        session.getIntent(),
                        session.getState(),
                        new TextPayload(policy.getResponseText()),
                        session.getContextJson()
                );
                return new StepResult.Stop(out);
            }
        }

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">6</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>DialogueActStep</span>
  </div>
</div>

**Responsibility:** Classify user turn action type  
**Session Mutations:** `dialogue_act in input params`  
**Config/Table Dependencies:** `ce_config (dialogue act mode), ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="DialogueActStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/DialogueActStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        DialogueActResolveMode resolveMode = DialogueActResolveMode.from(
                flowConfig.getDialogueAct().getResolute(),
                DialogueActResolveMode.REGEX_THEN_LLM
        );
        double regexConfidenceThresholdForLlm = flowConfig.getDialogueAct().getLlmThreshold();
        String userText = session.getUserText() == null ? "" : session.getUserText().trim();

        DialogueActResult regexResult = classifyByRegex(userText);
        DialogueActResult resolved = resolveByMode(session, userText, regexResult, resolveMode, regexConfidenceThresholdForLlm);

        session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT, resolved.act().name());
        session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_CONFIDENCE, resolved.confidence());
        session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_SOURCE, resolved.source());

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(ConvEnginePayloadKey.USER_TEXT, session.getUserText());
        payload.put(ConvEnginePayloadKey.DIALOGUE_ACT, resolved.act().name());
        payload.put(ConvEnginePayloadKey.DIALOGUE_ACT_CONFIDENCE, resolved.confidence());
        payload.put(ConvEnginePayloadKey.DIALOGUE_ACT_SOURCE, resolved.source());
        payload.put("dialogueActResolveMode", resolveMode.name());
        payload.put(ConvEnginePayloadKey.INTENT, session.getIntent());
        payload.put(ConvEnginePayloadKey.STATE, session.getState());
        audit.audit(ConvEngineAuditStage.DIALOGUE_ACT_CLASSIFIED, session.getConversationId(), payload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">7</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>InteractionPolicyStep</span>
  </div>
</div>

**Responsibility:** Decide runtime policy before intent  
**Session Mutations:** `policy_decision, skip_intent_resolution`  
**Config/Table Dependencies:** `ce_config, session pending state`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="InteractionPolicyStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/InteractionPolicyStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        String dialogueActRaw = session.inputParamAsString(ConvEngineInputParamKey.DIALOGUE_ACT);
        DialogueAct dialogueAct = parseDialogueAct(dialogueActRaw);
        Map<String, Object> context = session.contextDict();
        Map<String, Object> inputParams = session.getInputParams();

        boolean hasPendingAction = hasValue(context.get("pending_action"))
                || hasValue(context.get("pendingAction"))
                || hasValue(inputParams.get("pending_action"))
                || hasValue(inputParams.get("pendingAction"))
                || hasValue(inputParams.get(ConvEngineInputParamKey.PENDING_ACTION_KEY))
                || hasValue(inputParams.get("pending_action_task"))
                || hasPendingActionFromRegistry(session);
        boolean hasPendingSlot = hasValue(context.get("pending_slot"))
                || hasValue(context.get("pendingSlot"));
        boolean hasResolvedIntent = session.getIntent() != null
                && !session.getIntent().isBlank()
                && !"UNKNOWN".equalsIgnoreCase(session.getIntent());
        boolean hasResolvedState = session.getState() != null
                && !session.getState().isBlank()
                && !"UNKNOWN".equalsIgnoreCase(session.getState());
        boolean requireResolvedIntentAndState = flowConfig.getInteractionPolicy().isRequireResolvedIntentAndState();
        boolean hasResolvedContext = !requireResolvedIntentAndState || (hasResolvedIntent && hasResolvedState);

        InteractionPolicyDecision decision = InteractionPolicyDecision.RECLASSIFY_INTENT;
        boolean skipIntentResolution = false;

        if (hasResolvedContext) {
            InteractionPolicyDecision matrixDecision = resolveFromMatrix(hasPendingAction, hasPendingSlot, dialogueAct);
            if (matrixDecision != null) {
                decision = matrixDecision;
                skipIntentResolution = true;
            } else if (flowConfig.getInteractionPolicy().isExecutePendingOnAffirm()
                    && hasPendingAction
                    && dialogueAct == DialogueAct.AFFIRM) {
                decision = InteractionPolicyDecision.EXECUTE_PENDING_ACTION;
                skipIntentResolution = true;
            } else if (flowConfig.getInteractionPolicy().isRejectPendingOnNegate()
                    && hasPendingAction
                    && dialogueAct == DialogueAct.NEGATE) {
                decision = InteractionPolicyDecision.REJECT_PENDING_ACTION;
                skipIntentResolution = true;
            } else if (flowConfig.getInteractionPolicy().isFillPendingSlotOnNonNewRequest()
                    && hasPendingSlot
                    && dialogueAct != DialogueAct.NEW_REQUEST) {
                decision = InteractionPolicyDecision.FILL_PENDING_SLOT;
                skipIntentResolution = true;
            }
        }

        session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, decision.name());
        session.putInputParam(ConvEngineInputParamKey.SKIP_INTENT_RESOLUTION, skipIntentResolution);

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(ConvEnginePayloadKey.DIALOGUE_ACT, dialogueAct.name());
        payload.put(ConvEnginePayloadKey.POLICY_DECISION, decision.name());
        payload.put(ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, skipIntentResolution);
        payload.put("hasPendingAction", hasPendingAction);
        payload.put("hasPendingSlot", hasPendingSlot);
        payload.put(ConvEnginePayloadKey.INTENT, session.getIntent());
        payload.put(ConvEnginePayloadKey.STATE, session.getState());
        audit.audit(ConvEngineAuditStage.INTERACTION_POLICY_DECIDED, session.getConversationId(), payload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">8</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ActionLifecycleStep</span>
  </div>
</div>

**Responsibility:** Maintain pending action runtime TTL/status  
**Session Mutations:** `pending_action_runtime context`  
**Config/Table Dependencies:** `ce_pending_action, ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="ActionLifecycleStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/ActionLifecycleStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (!flowConfig.getActionLifecycle().isEnabled()) {
            return new StepResult.Continue();
        }

        ObjectNode root = contextHelper.readRoot(session);
        ObjectNode runtime = contextHelper.ensureObject(root, RUNTIME_NODE);
        int currentTurn = session.conversionHistory().size() + 1;
        long now = Instant.now().toEpochMilli();

        PendingActionStatus currentStatus = PendingActionStatus.from(runtime.path("status").asText(null), null);
        if (isExpired(runtime, currentTurn, now) && (currentStatus == PendingActionStatus.OPEN || currentStatus == PendingActionStatus.IN_PROGRESS)) {
            runtime.put("status", PendingActionStatus.EXPIRED.name());
            runtime.put("expired_turn", currentTurn);
            runtime.put("expired_at_epoch_ms", now);
            session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.EXPIRED.name());
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(
                    "event", "EXPIRED",
                    "status", PendingActionStatus.EXPIRED.name(),
                    "turn", currentTurn
            ));
        }

        String actionKey = resolveActionKey(session);
        String actionRef = resolveActionReferenceFromTable(session, actionKey);
        if (actionRef == null || actionRef.isBlank()) {
            contextHelper.writeRoot(session, root);
            return new StepResult.Continue();
        }

        boolean isNewRuntime = isRuntimeNew(runtime, actionKey, actionRef);
        if (isNewRuntime) {
            runtime.put("action_key", actionKey == null ? "" : actionKey);
            runtime.put("action_ref", actionRef);
            runtime.put("status", PendingActionStatus.OPEN.name());
            runtime.put("created_turn", currentTurn);
            runtime.put("created_at_epoch_ms", now);
            runtime.put("expires_turn", flowConfig.getActionLifecycle().getTtlTurns() > 0
                    ? currentTurn + flowConfig.getActionLifecycle().getTtlTurns()
                    : -1);
            runtime.put("expires_at_epoch_ms", flowConfig.getActionLifecycle().getTtlMinutes() > 0
                    ? now + (flowConfig.getActionLifecycle().getTtlMinutes() * 60_000L)
                    : -1);
            session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.OPEN.name());
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(
                    "event", "OPEN",
                    "status", PendingActionStatus.OPEN.name(),
                    "actionKey", actionKey,
                    "actionRef", actionRef
            ));
        }

        InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION));
        if (decision == InteractionPolicyDecision.EXECUTE_PENDING_ACTION) {
            runtime.put("status", PendingActionStatus.IN_PROGRESS.name());
            runtime.put("in_progress_turn", currentTurn);
            runtime.put("in_progress_at_epoch_ms", now);
            session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.IN_PROGRESS.name());
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(
                    "event", "IN_PROGRESS",
                    "status", PendingActionStatus.IN_PROGRESS.name(),
                    "actionKey", actionKey,
                    "actionRef", actionRef
            ));
        } else if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) {
            runtime.put("status", PendingActionStatus.REJECTED.name());
            runtime.put("rejected_turn", currentTurn);
            runtime.put("rejected_at_epoch_ms", now);
            session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.REJECTED.name());
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf(
                    "event", "REJECTED",
                    "status", PendingActionStatus.REJECTED.name(),
                    "actionKey", actionKey,
                    "actionRef", actionRef
            ));
        }

        contextHelper.writeRoot(session, root);
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">9</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>DisambiguationStep</span>
  </div>
</div>

**Responsibility:** Ask question when multiple actions fit  
**Session Mutations:** `pending_clarification question/context`  
**Config/Table Dependencies:** `ce_pending_action, ce_config, ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="DisambiguationStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/DisambiguationStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (!flowConfig.getDisambiguation().isEnabled()) {
            return new StepResult.Continue();
        }
        InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION));
        if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION) {
            return new StepResult.Continue();
        }

        String explicitActionKey = session.inputParamAsString(ConvEngineInputParamKey.PENDING_ACTION_KEY);
        if (explicitActionKey != null && !explicitActionKey.isBlank()) {
            return new StepResult.Continue();
        }

        List<CePendingAction> candidates = pendingActionRepository.findEligibleByIntentAndStateOrderByPriorityAsc(
                session.getIntent(),
                session.getState()
        );
        if (candidates == null || candidates.size() <= 1) {
            return new StepResult.Continue();
        }

        int bestPriority = candidates.getFirst().getPriority() == null ? Integer.MAX_VALUE : candidates.getFirst().getPriority();
        List<CePendingAction> top = candidates.stream()
                .filter(c -> (c.getPriority() == null ? Integer.MAX_VALUE : c.getPriority()) == bestPriority)
                .toList();
        if (top.size() <= 1) {
            return new StepResult.Continue();
        }

        Set<String> options = new LinkedHashSet<>();
        for (CePendingAction row : top) {
            if (row.getActionKey() == null || row.getActionKey().isBlank()) {
                continue;
            }
            String option = row.getActionKey().trim();
            if (row.getDescription() != null && !row.getDescription().isBlank()) {
                option = option + " (" + row.getDescription().trim() + ")";
            }
            options.add(option);
            if (options.size() >= Math.max(1, flowConfig.getDisambiguation().getMaxOptions())) {
                break;
            }
        }
        if (options.isEmpty()) {
            return new StepResult.Continue();
        }

        QuestionResult questionResult = buildQuestion(session, top, options);
        String question = questionResult.question();
        session.setPendingClarificationQuestion(question);
        session.setPendingClarificationReason("PENDING_ACTION_DISAMBIGUATION");
        session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, InteractionPolicyDecision.RECLASSIFY_INTENT.name());
        session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_DISAMBIGUATION_REQUIRED, true);

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(ConvEnginePayloadKey.REASON, "MULTIPLE_PENDING_ACTIONS");
        payload.put(ConvEnginePayloadKey.QUESTION, question);
        payload.put(ConvEnginePayloadKey.CANDIDATE_COUNT, top.size());
        payload.put(ConvEnginePayloadKey.OPTIONS, new ArrayList<>(options));
        payload.put(ConvEnginePayloadKey.INTENT, session.getIntent());
        payload.put(ConvEnginePayloadKey.STATE, session.getState());
        payload.put(ConvEnginePayloadKey.QUESTION_SOURCE, questionResult.source());
        audit.audit(ConvEngineAuditStage.DISAMBIGUATION_REQUIRED, session.getConversationId(), payload);
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">10</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>GuardrailStep</span>
  </div>
</div>

**Responsibility:** Apply guardrails and approval rules  
**Session Mutations:** `guardrail flags/sanitized text`  
**Config/Table Dependencies:** `ce_config, ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="GuardrailStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/GuardrailStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (!flowConfig.getGuardrail().isEnabled()) {
            return new StepResult.Continue();
        }

        String originalUserText = session.getUserText() == null ? "" : session.getUserText();
        String sanitizedUserText = sanitize(originalUserText);
        if (flowConfig.getGuardrail().isSanitizeInput()) {
            session.putInputParam(ConvEngineInputParamKey.SANITIZED_USER_TEXT, sanitizedUserText);
        }

        boolean sensitive = matchesSensitivePattern(sanitizedUserText);
        boolean approvalRequired = flowConfig.getGuardrail().isRequireApprovalForSensitiveActions() && sensitive;
        boolean approvalGranted = isApprovalGranted(session);
        boolean failClosed = flowConfig.getGuardrail().isApprovalGateFailClosed();
        boolean denied = approvalRequired && (!approvalGranted || failClosed && !approvalGranted);

        if (denied) {
            session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_BLOCKED, true);
            session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_REASON, "SENSITIVE_ACTION_APPROVAL_REQUIRED");
            session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, InteractionPolicyDecision.RECLASSIFY_INTENT.name());
            session.putInputParam(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION, true);
            session.putInputParam(ConvEngineInputParamKey.SKIP_PENDING_ACTION_EXECUTION, true);

            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put("result", "DENY");
            payload.put("reason", "SENSITIVE_ACTION_APPROVAL_REQUIRED");
            payload.put("sensitive", true);
            payload.put("approvalGranted", approvalGranted);
            payload.put("userText", sanitizedUserText);
            payload.put("intent", session.getIntent());
            payload.put("state", session.getState());
            audit.audit(ConvEngineAuditStage.GUARDRAIL_DENY, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_BLOCKED, false);
        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put("result", "ALLOW");
        payload.put("sensitive", sensitive);
        payload.put("approvalRequired", approvalRequired);
        payload.put("approvalGranted", approvalGranted);
        payload.put("intent", session.getIntent());
        payload.put("state", session.getState());
        audit.audit(ConvEngineAuditStage.GUARDRAIL_ALLOW, session.getConversationId(), payload);
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">11</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>IntentResolutionStep</span>
  </div>
</div>

**Responsibility:** Resolve intent with classifier+agent  
**Session Mutations:** `intent/state/clarification fields`  
**Config/Table Dependencies:** `ce_intent, ce_intent_classifier, ce_config`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="IntentResolutionStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/IntentResolutionStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        String previousIntent = session.getIntent();

        Map<String, Object> startPayload = new LinkedHashMap<>();
        startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.PREVIOUS_INTENT, previousIntent);
        startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCKED, session.isIntentLocked());
        startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCK_REASON, session.getIntentLockReason());
        audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_START, session.getConversationId(), startPayload);

        if (session.isIntentLocked() || isActiveSchemaCollection(session)) {
            if (!session.isIntentLocked()) {
                session.lockIntent("SCHEMA_INCOMPLETE");
            }
            session.clearClarification();
            if (session.getConversation() != null) {
                session.getConversation().setIntentCode(session.getIntent());
                session.getConversation().setStateCode(session.getState());
            }
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCKED, session.isIntentLocked());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCK_REASON, session.getIntentLockReason());
            audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        if (shouldSkipResolutionForPolicy(session)) {
            if (session.getConversation() != null) {
                session.getConversation().setIntentCode(session.getIntent());
                session.getConversation().setStateCode(session.getState());
            }
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.DIALOGUE_ACT, session.inputParamAsString(ConvEngineInputParamKey.DIALOGUE_ACT));
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.POLICY_DECISION, session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION));
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, true);
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, "policy decision retained existing intent/state");
            audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_POLICY, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        if (shouldSkipResolutionForStickyIntent(session)) {
            if (session.getConversation() != null) {
                session.getConversation().setIntentCode(session.getIntent());
                session.getConversation().setStateCode(session.getState());
            }
            Map<String, Object> payload = existingIntentRetainedAuditPayload(session);
            audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_STICKY_INTENT, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        CompositeIntentResolver.IntentResolutionResult result = intentResolver.resolveWithTrace(session);

        if (result == null || result.resolvedIntent() == null) {
            audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_NO_CHANGE, session.getConversationId(), Map.of());
            return new StepResult.Continue();
        }

        if (!result.resolvedIntent().equals(previousIntent)) {
            session.setIntent(result.resolvedIntent());
        }
        session.getConversation().setIntentCode(session.getIntent());
        session.getConversation().setStateCode(session.getState());

        audit.audit(
                ConvEngineAuditStage.intentResolvedBy(result.source().name()),
                session.getConversationId(),
                result
        );

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">12</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ResetResolvedIntentStep</span>
  </div>
</div>

**Responsibility:** Reset on configured reset intent  
**Session Mutations:** `full reset`  
**Config/Table Dependencies:** `ce_config RESET_INTENT_CODES`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="ResetResolvedIntentStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/ResetResolvedIntentStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        String intent = session.getIntent();
        if (intent == null || !resetIntentCodes.contains(intent.trim().toUpperCase())) {
            return new StepResult.Continue();
        }

        session.resetForConversationRestart();
        session.getConversation().setStatus("RUNNING");
        session.getConversation().setIntentCode("UNKNOWN");
        session.getConversation().setStateCode("UNKNOWN");
        session.getConversation().setContextJson("{}");
        session.getConversation().setInputParamsJson("{}");
        session.getConversation().setLastAssistantJson(null);
        session.getConversation().setUpdatedAt(OffsetDateTime.now());
        conversationRepository.save(session.getConversation());

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, "INTENT_RESOLVED_RESET");
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.MATCHED_RESET_INTENT_CODES, resetIntentCodes);
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson());
        audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">13</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>FallbackIntentStateStep</span>
  </div>
</div>

**Responsibility:** Fill missing intent/state defaults  
**Session Mutations:** `intent/state`  
**Config/Table Dependencies:** `none`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="FallbackIntentStateStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/FallbackIntentStateStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        if (session.getIntent() == null) {
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.USER_TEXT, session.getUserText());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FALLBACK_INTENT, fallbackIntent);
            audit.audit(ConvEngineAuditStage.INTENT_MISSING, session.getConversationId(), payload);
            session.setIntent(fallbackIntent);
        }

        if (session.getState() == null) {
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.USER_TEXT, session.getUserText());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FALLBACK_STATE, fallbackState);
            audit.audit(ConvEngineAuditStage.STATE_MISSING, session.getConversationId(), payload);
            session.setState(fallbackState);
        }

        session.getConversation().setIntentCode(session.getIntent());
        session.getConversation().setStateCode(session.getState());
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">14</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>AddContainerDataStep</span>
  </div>
</div>

**Responsibility:** Fetch and attach container data  
**Session Mutations:** `containerData/context merge`  
**Config/Table Dependencies:** `ce_container_config`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="AddContainerDataStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/AddContainerDataStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        List<CeContainerConfig> configs =
                containerConfigRepo.findByIntentAndState(
                        session.getIntent(),
                        session.getState()
                );

        if (configs.isEmpty()) {
            configs = containerConfigRepo.findFallbackByState(session.getState());
        }

        if (configs.isEmpty()) {
            configs = containerConfigRepo.findGlobalFallback();
        }

        if (configs.isEmpty()) {
            Map<String, Object> reasonMap = new HashMap<>();
            reasonMap.put("reason", "no container configs for intent/state");
            reasonMap.put("intent", session.getIntent());
            reasonMap.put("state", session.getState());
            audit.audit(
                    "CONTAINER_DATA_SKIPPED",
                    session.getConversationId(),
                    reasonMap
            );
            return new StepResult.Continue();
        }

        ObjectNode containerRoot = mapper.createObjectNode();

        for (CeContainerConfig cfg : configs) {

            try {
                Map<String, Object> inputParams = new HashMap<>();
                String key = cfg.getInputParamName();
                Object value = session.extractValueFromContext(key);
                if(value == null) {
                    value = session.getUserText();
                }
                inputParams.put(key, value);
                if (session.getInputParams() != null) {
                    inputParams.putAll(session.getInputParams());
                }
                if (session.getEngineContext().getInputParams() != null) {
                    inputParams.putAll(session.getEngineContext().getInputParams());
                }

                PageInfoRequest pageInfo = PageInfoRequest.builder()
                                                .userId("convengine")
                                                .loggedInUserId("convengine")
                                                .pageId(cfg.getPageId())
                                                .sectionId(cfg.getSectionId())
                                                .containerId(cfg.getContainerId())
                                                .inputParams(inputParams)
                                                .build();

                ContainerComponentRequest req = new ContainerComponentRequest();
                req.setPageInfo(List.of(pageInfo));
                req.setRequestTypes(List.of(RequestType.CONTAINER));
                interceptorExecutor.beforeExecute(req, session);
                ContainerComponentResponse resp = ccfCoreService.execute(req);
                resp = interceptorExecutor.afterExecute(resp, session);
                // find classes with @ContainerDataTransformer(state, intent) to transform resp if needed
                Map<String, Object> transformedData = transformerService.transformIfApplicable(resp, session, inputParams);
                JsonNode responseNode = transformedData == null ? mapper.valueToTree(resp) : mapper.valueToTree(transformedData);
                session.setContainerData(responseNode);
                containerRoot.set(cfg.getInputParamName(), responseNode);
                Map<String, Object> jsonMap = Map.of(
                        "containerId", cfg.getContainerId(),
                        "pageId", cfg.getPageId(),
                        "sectionId", cfg.getSectionId(),
                        "inputParam", cfg.getInputParamName(),
                        "requestInput", inputParams,
                        "response", responseNode
                );
                audit.audit(
                        "CONTAINER_DATA_EXECUTED",
                        session.getConversationId(),
                        jsonMap
                );

            } catch (Exception e) {
                Map<String, Object> errorJsonMap = new HashMap<>();
                errorJsonMap.put("containerId", cfg.getContainerId());
                errorJsonMap.put("error", e.getMessage());
                audit.audit(
                        "CONTAINER_DATA_FAILED",
                        session.getConversationId(),
                        errorJsonMap
                );
            }
        }

        if (!containerRoot.isEmpty()) {

            // attach to session
            session.setContainerDataJson(containerRoot.toString());
            session.setHasContainerData(true);

            // merge into conversation context
            try {
                ObjectNode ctx = (ObjectNode) mapper.readTree(session.getContextJson());
                ctx.set("container_data", containerRoot);
                session.setContextJson(mapper.writeValueAsString(ctx));
                session.getConversation().setContextJson(session.getContextJson());
            } catch (Exception ignore) {
                // context merge failure should not break pipeline
            }

            audit.audit(
                    "CONTAINER_DATA_ATTACHED",
                    session.getConversationId(),
                    containerRoot.toString()
            );
        }

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">15</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PendingActionStep</span>
  </div>
</div>

**Responsibility:** Execute/reject pending action task  
**Session Mutations:** `pending_action_runtime status/result`  
**Config/Table Dependencies:** `ce_pending_action, CeTaskExecutor, ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="PendingActionStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/PendingActionStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_PENDING_ACTION_EXECUTION))
                || Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.GUARDRAIL_BLOCKED))) {
            Map<String, Object> payload = basePayload(session, InteractionPolicyDecision.RECLASSIFY_INTENT, null);
            payload.put(ConvEnginePayloadKey.REASON, "pending action skipped by guardrail");
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_SKIPPED, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        String decisionRaw = session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION);
        InteractionPolicyDecision decision = parseDecision(decisionRaw);
        if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION
                && decision != InteractionPolicyDecision.REJECT_PENDING_ACTION) {
            return new StepResult.Continue();
        }

        Map<String, Object> context = session.contextDict();
        Object pendingAction = context.get("pending_action");
        if (pendingAction == null) {
            pendingAction = context.get("pendingAction");
        }

        String actionKey = resolveActionKey(session, context, pendingAction);
        String actionRef = resolveActionReference(session, pendingAction, actionKey);
        if (actionRef == null || actionRef.isBlank()) {
            Map<String, Object> payload = basePayload(session, decision, null);
            payload.put("actionKey", actionKey);
            payload.put(ConvEnginePayloadKey.REASON, actionKey == null || actionKey.isBlank()
                    ? "pending action reference not found or ambiguous registry mapping"
                    : "pending action reference not found");
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_SKIPPED, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) {
            session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "REJECTED");
            updateRuntimeStatus(session, PendingActionStatus.REJECTED);
            Map<String, Object> payload = basePayload(session, decision, actionRef);
            payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "REJECTED");
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_REJECTED, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        String[] taskRef = parseTaskReference(actionRef);
        if (taskRef == null) {
            session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "FAILED");
            Map<String, Object> payload = basePayload(session, decision, actionRef);
            payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "FAILED");
            payload.put(ConvEnginePayloadKey.REASON, "invalid pending action reference");
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_FAILED, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        Object executionResult = ceTaskExecutor.execute(taskRef[0], taskRef[1], session);
        if (executionResult == null) {
            session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "FAILED");
            Map<String, Object> payload = basePayload(session, decision, actionRef);
            payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "FAILED");
            payload.put(ConvEnginePayloadKey.REASON, "task execution returned null");
            audit.audit(ConvEngineAuditStage.PENDING_ACTION_FAILED, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, "EXECUTED");
        updateRuntimeStatus(session, PendingActionStatus.EXECUTED);
        Map<String, Object> payload = basePayload(session, decision, actionRef);
        payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, "EXECUTED");
        payload.put("taskBean", taskRef[0]);
        payload.put("taskMethods", taskRef[1]);
        audit.audit(ConvEngineAuditStage.PENDING_ACTION_EXECUTED, session.getConversationId(), payload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">16</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ToolOrchestrationStep</span>
  </div>
</div>

**Responsibility:** Run tool_group based orchestration  
**Session Mutations:** `tool_request/tool_result fields`  
**Config/Table Dependencies:** `ce_tool, ce_mcp_tool, ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="ToolOrchestrationStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/ToolOrchestrationStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (!flowConfig.getToolOrchestration().isEnabled()) {
            return new StepResult.Continue();
        }
        if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION))) {
            return new StepResult.Continue();
        }

        ToolRequest request = resolveRequest(session);
        if (request == null) {
            return new StepResult.Continue();
        }

        session.putInputParam(ConvEngineInputParamKey.TOOL_REQUEST, request.toMap());
        audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_REQUEST, session.getConversationId(), request.toMap());

        try {
            CeMcpTool tool = request.toolCode() == null || request.toolCode().isBlank()
                    ? null
                    : registry.requireTool(request.toolCode(), session.getIntent(), session.getState());
            String group = request.toolGroup();
            if ((group == null || group.isBlank()) && tool != null) {
                group = registry.normalizeToolGroup(tool.getToolGroup());
            }
            if (group == null || group.isBlank()) {
                throw new IllegalStateException("tool_group is required when tool_code is not resolvable");
            }

            McpToolExecutor executor = resolveExecutor(group);
            String resultJson = executor.execute(tool, request.args(), session);

            Map<String, Object> result = new LinkedHashMap<>();
            result.put("status", "SUCCESS");
            result.put("tool_code", request.toolCode());
            result.put("tool_group", group);
            result.put("result", parseJsonOrString(resultJson));
            session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);
            session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "SUCCESS");
            audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_RESULT, session.getConversationId(), result);

            rulesStep.applyRules(session, "ToolOrchestrationStep PostTool", RulePhase.TOOL_POST_EXECUTION.name());
        } catch (IllegalStateException e) {
            if (e.getMessage() != null && e.getMessage().contains("Missing enabled MCP tool for current intent/state")) {
                Map<String, Object> result = new LinkedHashMap<>();
                result.put("status", "SKIPPED_SCOPE_MISMATCH");
                result.put("tool_code", request.toolCode());
                result.put("tool_group", request.toolGroup());
                result.put("intent", session.getIntent());
                result.put("state", session.getState());
                session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);
                session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "SKIPPED_SCOPE_MISMATCH");
                audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_RESULT, session.getConversationId(), result);
                return new StepResult.Continue();
            }
            Map<String, Object> result = new LinkedHashMap<>();
            result.put("status", "ERROR");
            result.put("tool_code", request.toolCode());
            result.put("tool_group", request.toolGroup());
            result.put("error", String.valueOf(e.getMessage()));
            session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);
            session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "ERROR");
            audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_ERROR, session.getConversationId(), result);
        } catch (Exception e) {
            Map<String, Object> result = new LinkedHashMap<>();
            result.put("status", "ERROR");
            result.put("tool_code", request.toolCode());
            result.put("tool_group", request.toolGroup());
            result.put("error", String.valueOf(e.getMessage()));
            session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result);
            session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, "ERROR");
            audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_ERROR, session.getConversationId(), result);
        }
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">17</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>McpToolStep</span>
  </div>
</div>

**Responsibility:** MCP planner/tool loop  
**Session Mutations:** `context_json.mcp.*`  
**Config/Table Dependencies:** `ce_mcp_tool, ce_mcp_db_tool, ce_config`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="McpToolStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/McpToolStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION))
                || Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.GUARDRAIL_BLOCKED))) {
            session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "SKIPPED_BY_GUARDRAIL");
            return new StepResult.Continue();
        }

        if (session.hasPendingClarification()) {
            audit.audit(
                    ConvEngineAuditStage.MCP_SKIPPED_PENDING_CLARIFICATION,
                    session.getConversationId(),
                    mapOf(
                            "intent", session.getIntent(),
                            "state", session.getState()
                    )
            );
            return new StepResult.Continue();
        }

        List<CeMcpTool> tools = registry.listEnabledTools(session.getIntent(), session.getState());

        if (CollectionUtils.isEmpty(tools)) {
            session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "NO_TOOLS_FOR_SCOPE");
            audit.audit(ConvEngineAuditStage.MCP_NO_TOOLS_AVAILABLE, session.getConversationId(),
                    mapOf("intent", session.getIntent(), "state", session.getState()));
            return new StepResult.Continue();
        }

        clearMcpContext(session);
        List<McpObservation> observations = readObservationsFromContext(session);
        boolean mcpTouched = false;

        for (int i = 0; i < MAX_LOOPS; i++) {

            McpPlan plan = planner.plan(session, tools, observations);
            mcpTouched = true;
            session.putInputParam(ConvEngineInputParamKey.MCP_ACTION, plan.action());
            session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_CODE, plan.tool_code());
            session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_ARGS, plan.args() == null ? Map.of() : plan.args());

            if ("ANSWER".equalsIgnoreCase(plan.action())) {
                // store final answer in contextJson; your ResponseResolutionStep can use it via derivation_hint
                writeFinalAnswerToContext(session, plan.answer());
                session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, plan.answer() == null ? "" : plan.answer());
                session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "ANSWER");
                audit.audit(
                        ConvEngineAuditStage.MCP_FINAL_ANSWER,
                        session.getConversationId(),
                        mapOf("answer", plan.answer())
                );
                break;
            }

            if (!"CALL_TOOL".equalsIgnoreCase(plan.action())) {
                writeFinalAnswerToContext(session, "I couldn't decide the next tool step safely.");
                session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, "I couldn't decide the next tool step safely.");
                session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "FALLBACK");
                break;
            }

            String toolCode = plan.tool_code();
            Map<String, Object> args = (plan.args() == null) ? Map.of() : plan.args();

            audit.audit(
                    ConvEngineAuditStage.MCP_TOOL_CALL,
                    session.getConversationId(),
                    mapOf("tool_code", toolCode, "args", args)
            );

            CeMcpTool tool = registry.requireTool(toolCode, session.getIntent(), session.getState());
            String toolGroup = registry.normalizeToolGroup(tool.getToolGroup());
            session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_GROUP, toolGroup);

            try {
                McpToolExecutor executor = resolveExecutor(toolGroup);
                String rowsJson = executor.execute(tool, args, session);

                observations.add(new McpObservation(toolCode, rowsJson));
                writeObservationsToContext(session, observations);
                session.putInputParam(ConvEngineInputParamKey.MCP_OBSERVATIONS, observations);
                session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "TOOL_RESULT");

                audit.audit(
                    ConvEngineAuditStage.MCP_TOOL_RESULT,
                    session.getConversationId(),
                    mapOf("tool_code", toolCode, "tool_group", toolGroup, "rows", rowsJson)
                );

            } catch (Exception e) {
                audit.audit(
                        ConvEngineAuditStage.MCP_TOOL_ERROR,
                        session.getConversationId(),
                        mapOf("tool_code", toolCode, "tool_group", toolGroup, "error", String.valueOf(e.getMessage()))
                );
                writeFinalAnswerToContext(session, "Tool execution failed safely. Can you narrow the request?");
                session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, "Tool execution failed safely. Can you narrow the request?");
                session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, "TOOL_ERROR");
                break;
            }
        }

        if (mcpTouched) {
            rulesStep.applyRules(session, "McpToolStep", RulePhase.AGENT_POST_MCP.name());
        }

        session.syncToConversation();
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">18</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>SchemaExtractionStep</span>
  </div>
</div>

**Responsibility:** Schema-driven extraction and lock handling  
**Session Mutations:** `schema facts/context/lock`  
**Config/Table Dependencies:** `ce_output_schema, ce_prompt_template`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="SchemaExtractionStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/SchemaExtractionStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        String intent = session.getIntent();
        String state = session.getState();

        CeOutputSchema schema = outputSchemaRepo.findAll().stream()
                .filter(s -> Boolean.TRUE.equals(s.getEnabled()))
                .filter(s -> equalsIgnoreCase(s.getIntentCode(), intent))
                .filter(s -> equalsIgnoreCase(s.getStateCode(), state) || equalsIgnoreCase(s.getStateCode(), "ANY"))
                .min((a, b) -> Integer.compare(priorityOf(a), priorityOf(b)))
                .orElse(null);

        if (schema != null) {
            runExtraction(session, schema);
        } else {
            session.unlockIntent();
            session.setResolvedSchema(null);
            session.setSchemaComplete(false);
            session.setSchemaHasAnyValue(false);
            session.setMissingRequiredFields(new ArrayList<>());
            session.setMissingFieldOptions(new LinkedHashMap<>());
            session.addPromptTemplateVars();
        }

        session.syncFromConversation(true);
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">19</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>AutoAdvanceStep</span>
  </div>
</div>

**Responsibility:** Compute schema status facts  
**Session Mutations:** `schemaComplete/hasAny`  
**Config/Table Dependencies:** `resolved schema + context`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="AutoAdvanceStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/AutoAdvanceStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        if (session.getResolvedSchema() == null) {
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, "no schema resolved");
            audit.audit(ConvEngineAuditStage.AUTO_ADVANCE_SKIPPED_NO_SCHEMA, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        String schemaJson = session.getResolvedSchema().getJsonSchema();
        String contextJson = session.getContextJson();

        boolean hasAnySchemaValue = JsonUtil.hasAnySchemaValue(contextJson, schemaJson);
        boolean schemaComplete = JsonUtil.isSchemaComplete(schemaJson, contextJson);
        session.setSchemaHasAnyValue(hasAnySchemaValue);
        session.setSchemaComplete(schemaComplete);

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_COMPLETE, schemaComplete);
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.HAS_ANY_SCHEMA_VALUE, hasAnySchemaValue);
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
        audit.audit(ConvEngineAuditStage.AUTO_ADVANCE_FACTS, session.getConversationId(), payload);
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">20</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>RulesStep</span>
  </div>
</div>

**Responsibility:** Match and apply transitions/actions  
**Session Mutations:** `intent/state/input params`  
**Config/Table Dependencies:** `ce_rule`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="RulesStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/RulesStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        applyRules(session, "RulesStep", RulePhase.PIPELINE_RULES.name());
        session.syncToConversation();
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">21</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>StateGraphStep</span>
  </div>
</div>

**Responsibility:** Validate state transition path  
**Session Mutations:** `state_graph_valid/reason`  
**Config/Table Dependencies:** `ce_state_graph, ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="StateGraphStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/StateGraphStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (!flowConfig.getStateGraph().isEnabled()) {
            return new StepResult.Continue();
        }
        String fromState = session.getConversation() == null ? null : session.getConversation().getStateCode();
        String toState = session.getState();

        if (fromState == null || fromState.isBlank() || toState == null || toState.isBlank()
                || fromState.equalsIgnoreCase(toState)) {
            return new StepResult.Continue();
        }

        boolean allowed = isAllowedTransition(fromState, toState);
        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put("fromState", fromState);
        payload.put("toState", toState);
        payload.put("intent", session.getIntent());
        payload.put("validateOnly", true);

        if (allowed) {
            session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_VALID, true);
            payload.put("allowed", true);
            audit.audit(ConvEngineAuditStage.STATE_GRAPH_VALID, session.getConversationId(), payload);
            return new StepResult.Continue();
        }

        payload.put("allowed", false);
        payload.put("softBlock", flowConfig.getStateGraph().isSoftBlockOnViolation());
        audit.audit(ConvEngineAuditStage.STATE_GRAPH_VIOLATION, session.getConversationId(), payload);
        session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_VALID, false);
        if (flowConfig.getStateGraph().isSoftBlockOnViolation()) {
            session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_SOFT_BLOCK, true);
        }
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">22</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ResponseResolutionStep</span>
  </div>
</div>

**Responsibility:** Resolve and generate output payload  
**Session Mutations:** `payload/last assistant json`  
**Config/Table Dependencies:** `ce_response, ce_prompt_template`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="ResponseResolutionStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/ResponseResolutionStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        if(AgentIntentResolver.INTENT_COLLISION_STATE.equals(session.getState())) {
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
            audit.audit(
                    ConvEngineAuditStage.INTENT_COLLISION_DETECTED,
                    session.getConversationId(),
                    payload
            );
            agentIntentCollisionResolver.resolve(session);
            return new StepResult.Continue();
        }

        Optional<CeResponse> responseOptional = resolveResponse(session);

        if(responseOptional.isEmpty()) {
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
            payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
            audit.audit(
                    ConvEngineAuditStage.RESPONSE_MAPPING_NOT_FOUND,
                    session.getConversationId(),
                    payload
            );
            throw new ConversationEngineException(
                    ConversationEngineErrorCode.RESPONSE_MAPPING_NOT_FOUND,
                    "No response found for intent=" + session.getIntent() + ", state=" + session.getState()
            );
        }
        CeResponse resp = responseOptional.get();
        if (!matches(resp.getStateCode(), session.getState()) && !matches(resp.getStateCode(), "ANY")) {
            session.setState(resp.getStateCode());
            session.getConversation().setStateCode(resp.getStateCode());
        }
        Map<String, Object> responsePayload = new LinkedHashMap<>();
        responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId());
        responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
        responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
        audit.audit(
                ConvEngineAuditStage.RESOLVE_RESPONSE,
                session.getConversationId(),
                responsePayload
        );
        List<ConversationTurn> conversationTurns = historyProvider.lastTurns(session.getConversationId(), 10);
        session.setConversationHistory(conversationTurns);



        CePromptTemplate template = null;
        if(ResponseType.DERIVED.name().equalsIgnoreCase(resp.getResponseType())) {
            template = promptRepo.findAll().stream()
                    .filter(t -> Boolean.TRUE.equals(t.getEnabled()))
                    .filter(t -> resp.getOutputFormat().equalsIgnoreCase(t.getResponseType()))
                    .filter(t -> matchesOrNull(t.getIntentCode(), session.getIntent()))
                    .filter(t -> matchesOrNull(t.getStateCode(), session.getState()) || matches(t.getStateCode(), "ANY"))
                    .max(Comparator.comparingInt(t -> score(t, session)))
                    .orElseThrow(() ->
                            new IllegalStateException(
                                    "No ce_prompt_template found for response_type=" +
                                            resp.getOutputFormat() + ", intent=" + session.getIntent() + ", state=" + session.getState()
                            )
                    );
        }
        typeFactory
                .get(resp.getResponseType())
                .resolve(session, PromptTemplate.initFrom(template), ResponseTemplate.initFrom(resp));


        OutputPayload transformedOutput = responseTransformerService.transformIfApplicable(session.getPayload(), session, session.getInputParams());
        session.setPayload(transformedOutput);

        Object payloadValue = switch (session.getPayload()) {
            case TextPayload(String text) -> text;
            case JsonPayload(String json) -> json;
            case null -> null;
        };

        Map<String, Object> outputPayload = new LinkedHashMap<>();
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT, payloadValue);
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT_FORMAT, resp.getOutputFormat());
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_TYPE, resp.getResponseType());
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId());
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict());
        outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_JSON, session.schemaJson());
        audit.audit(ConvEngineAuditStage.ASSISTANT_OUTPUT, session.getConversationId(), outputPayload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">23</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>MemoryStep</span>
  </div>
</div>

**Responsibility:** Write memory/session summary  
**Session Mutations:** `memory.session_summary in context`  
**Config/Table Dependencies:** `ce_memory, ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="MemoryStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/MemoryStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {
        if (!flowConfig.getMemory().isEnabled()) {
            return new StepResult.Continue();
        }

        String recalled = null;
        for (ConversationMemoryStore store : memoryStores) {
            try {
                String value = store.read(session);
                if (value != null && !value.isBlank()) {
                    recalled = value;
                    break;
                }
            } catch (Exception ignored) {
            }
        }
        if (recalled != null) {
            session.putInputParam(ConvEngineInputParamKey.MEMORY_RECALL, recalled);
        }

        String summary = buildSummary(session);
        if (summary.length() > flowConfig.getMemory().getSummaryMaxChars()) {
            summary = summary.substring(0, flowConfig.getMemory().getSummaryMaxChars());
        }
        session.putInputParam(ConvEngineInputParamKey.MEMORY_SESSION_SUMMARY, summary);

        ObjectNode root = contextHelper.readRoot(session);
        ObjectNode memoryNode = contextHelper.ensureObject(root, "memory");
        memoryNode.put("session_summary", summary);
        if (recalled != null) {
            memoryNode.put("recalled_summary", recalled);
        }
        contextHelper.writeRoot(session, root);

        for (ConversationMemoryStore store : memoryStores) {
            try {
                store.write(session, summary);
            } catch (Exception ignored) {
            }
        }

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put("summaryChars", summary.length());
        payload.put("recalled", recalled != null);
        payload.put("stores", memoryStores.size());
        payload.put("intent", session.getIntent());
        payload.put("state", session.getState());
        audit.audit(ConvEngineAuditStage.MEMORY_UPDATED, session.getConversationId(), payload);
        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">24</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PersistConversationStep</span>
  </div>
</div>

**Responsibility:** Persist final conversation and result  
**Session Mutations:** `finalResult`  
**Config/Table Dependencies:** `ce_conversation`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="PersistConversationStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/PersistConversationStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        // --- sanity check ---
        if (session.getPayload() == null) {
            throw new ConversationEngineException(
                    ConversationEngineErrorCode.PIPELINE_NO_RESPONSE_PAYLOAD,
                    "Engine pipeline ended without payload. ResponseResolutionStep did not run."
            );
        }

        // --- persist conversation ---
        sanitizeConversationForPostgres(session);
        session.getConversation().setStatus("RUNNING");
        session.getConversation().setUpdatedAt(OffsetDateTime.now());
        session.getConversation().setInputParamsJson(session.ejectInputParamsJson());
        conversationRepo.save(session.getConversation());

        // --- build FINAL EngineResult ---
        EngineResult result = new EngineResult(
                session.getIntent(),
                session.getState(),
                session.getPayload(),
                session.getContextJson()
        );

        session.setFinalResult(result);

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent());
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState());
        payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FINAL_RESULT, result);
        audit.audit(ConvEngineAuditStage.ENGINE_RETURN, session.getConversationId(), payload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---

<div className="ce-step-badge-list" role="list" style={{ marginBottom: '1rem' }}>
  <div className="ce-step-badge-item">
    <span className="ce-step-badge-index">25</span>
    <span className="ce-step-badge-label" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PipelineEndGuardStep</span>
  </div>
</div>

**Responsibility:** Timing audit + terminal guard  
**Session Mutations:** `timings`  
**Config/Table Dependencies:** `ce_audit`  

<details open>
<summary>Detailed Execution Logic</summary>

This step executes dynamically in the pipeline loop. Depending on engine configuration, specific dependencies are inspected to resolve the outcome. 
If conditions require the pipeline to halt early, it generates a `Stop` result. Otherwise, it emits a `Continue` mutation affecting the `EngineSession`.

<CodeBlockToggle title="PipelineEndGuardStep.execute()" language="java" filePath="src/main/java/com/github/salilvnair/convengine/engine/steps/PipelineEndGuardStep.java" defaultOpen={true}>
{`public StepResult execute(EngineSession session) {

        // Sort by start time just in case
        session.getStepTimings().sort(Comparator.comparingLong(StepTiming::getStartedAtNs));

        long totalMs = session.getStepTimings().stream().mapToLong(StepTiming::getDurationMs).sum();

        // Log in app logs
        String timingLine = session.getStepTimings().stream()
                .map(t -> t.getStepName() + "=" + t.getDurationMs() + "ms" + (t.isSuccess() ? "" : "(ERR)"))
                .reduce((a, b) -> a + ", " + b)
                .orElse("");

        log.info("ConvEngine timings convId={} total={}ms [{}]",
                session.getConversationId(), totalMs, timingLine);

        // Optional audit row (single compact record)
        String payload = "{\"totalMs\":" + totalMs +
                ",\"steps\":\"" + JsonUtil.escape(timingLine) + "\"}";

        audit.audit(ConvEngineAuditStage.PIPELINE_TIMING, session.getConversationId(), payload);

        return new StepResult.Continue();
    }`}
</CodeBlockToggle>
</details>

---
