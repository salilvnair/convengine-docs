[
  {
    "id": "api/audit-trace.mdx",
    "version": "v2",
    "title": "audit trace",
    "permalink": "/docs/v2/api/audit-trace",
    "content": "Audit Trace API Endpoint GET /api/v1/conversation/audit/ /trace Response shape ], \"stages\": [ } ] } } Why this endpoint exists separates timeline from raw audit payload parsing easier UI rendering for runbooks and debug tools complements ce_conversation_history , which stores normalized user/AI turns even when audit persistence runs deferred preserves both domain and technical stages Use both endpoints together: /audit/ for raw forensic payload, /audit/ /trace for step flow visualization.",
    "rawContent": "# Audit Trace API ## Endpoint GET /api/v1/conversation/audit/{conversationId}/trace ## Response shape <CodeBlockToggle title=\"Trace response\" language=\"json\" defaultOpen={true}> { { \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"steps\": [ { \"step\": \"IntentResolutionStep\", \"stepClass\": \"com.github.salilvnair.convengine.engine.steps.IntentResolutionStep\", \"status\": \"OK\", \"startedAt\": \"2026-02-14T10:22:01.102Z\", \"endedAt\": \"2026-02-14T10:22:01.147Z\", \"durationMs\": 45, \"error\": null, \"stages\": [] } ], \"stages\": [ { \"auditId\": 12031, \"stage\": \"STEP_ENTER\", \"createdAt\": \"2026-02-14T10:22:01.102Z\", \"payload\": { \"step\": \"IntentResolutionStep\" } } ] } } </CodeBlockToggle> ## Why this endpoint exists - separates timeline from raw audit payload parsing - easier UI rendering for runbooks and debug tools - complements ce_conversation_history , which stores normalized user/AI turns even when audit persistence runs deferred - preserves both domain and technical stages <Highlight type=\"tip\" title=\"Best practice\"> Use both endpoints together: /audit/{id} for raw forensic payload, /audit/{id}/trace for step-flow visualization. </Highlight>",
    "excerpt": "Audit Trace API Endpoint GET /api/v1/conversation/audit/ /trace Response shape ], \"stages\": [ } ] } } Why this endpoint exists separates timeline from raw audit payload parsing easier UI rendering for runbooks and debug …"
  },
  {
    "id": "api/java-api.mdx",
    "version": "v2",
    "title": "java api",
    "permalink": "/docs/v2/api/java-api",
    "content": "Java API (Core Contracts) Entry points } } } } } default void write(EngineSession session, String summary) } } Flow configuration API Extension contracts ResponseTransformerHandler ContainerDataTransformerHandler rule task execution pathway via SET_TASK pending action execution via CeTaskExecutor tool adapters through McpToolExecutor implementations",
    "rawContent": "# Java API (Core Contracts) ## Entry points <DbTable title=\"Primary interfaces\" columns={[\"Type\", \"Package\", \"Role\"]} rows={[ [\"ConversationalEngine\", \"engine.core\", \"Main process method\"], [\"LlmClient\", \"llm.core\", \"LLM adapter contract\"], [\"EngineStep\", \"engine.pipeline\", \"Step unit contract\"], [\"EngineStepHook\", \"engine.hook\", \"Step interception contract\"], [\"McpToolExecutor\", \"engine.mcp.executor\", \"Tool-group executor contract\"], [\"ConversationMemoryStore\", \"engine.memory\", \"Pluggable memory adapter\"], [\"CeTask\", \"engine.task\", \"Task contract for pending/rule execution\"], ]} /> <CodeBlockToggle title=\"ConversationalEngine\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.core\"> { public interface ConversationalEngine { EngineResult process(EngineContext engineContext); } } </CodeBlockToggle> <CodeBlockToggle title=\"LlmClient\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.llm.core\"> { public interface LlmClient { String generateText(String hint, String contextJson); String generateJson(String hint, String jsonSchema, String contextJson); float[] generateEmbedding(String input); } } </CodeBlockToggle> <CodeBlockToggle title=\"EngineStep.Name enum (current)\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\"> { public interface EngineStep { enum Name { AuditUserInputStep, DialogueActStep, InteractionPolicyStep, ActionLifecycleStep, DisambiguationStep, GuardrailStep, IntentResolutionStep, AddContainerDataStep, SchemaExtractionStep, PendingActionStep, ToolOrchestrationStep, StateGraphStep, ResponseResolutionStep, MemoryStep, AutoAdvanceStep, McpToolStep, LoadOrCreateConversationStep, FallbackIntentStateStep, PersistConversationBootstrapStep, ResetConversationStep, PersistConversationStep, PipelineEndGuardStep, ResetResolvedIntentStep, PolicyEnforcementStep, RulesStep, Unknown; } } } </CodeBlockToggle> <CodeBlockToggle title=\"McpToolExecutor\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.mcp.executor\"> { public interface McpToolExecutor { String toolGroup(); String execute(CeMcpTool tool, Map<String, Object> args, EngineSession session); } } </CodeBlockToggle> <CodeBlockToggle title=\"ConversationMemoryStore\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.memory\"> { public interface ConversationMemoryStore { default String read(EngineSession session) { return null; } default void write(EngineSession session, String summary) {} } } </CodeBlockToggle> ## Flow configuration API <DbTable title=\"Configuration classes\" columns={[\"Class\", \"Purpose\"]} rows={[ [\"ConvEngineFlowConfig\", \"Runtime controls for dialogue/policy/lifecycle/guardrail/tool/stategraph/disambiguation/memory\"], [\"ConvEngineEntityConfig\", \"Dynamic table name mapping via convengine.tables\"], [\"ConvEngineAuditConfig\", \"Audit behavior controls\"], ]} /> ## Extension contracts - <MethodRef>ResponseTransformerHandler</MethodRef> - <MethodRef>ContainerDataTransformerHandler</MethodRef> - rule task execution pathway via <MethodRef>SET_TASK</MethodRef> - pending action execution via CeTaskExecutor - tool adapters through McpToolExecutor implementations",
    "excerpt": "Java API (Core Contracts) Entry points } } } } } default void write(EngineSession session, String summary) } } Flow configuration API Extension contracts ResponseTransformerHandler ContainerDataTransformerHandler rule ta…"
  },
  {
    "id": "api/rest-api.mdx",
    "version": "v2",
    "title": "rest api",
    "permalink": "/docs/v2/api/rest-api",
    "content": "REST API Base /api/v1/conversation Endpoints POST /message } } , \"context\": \" \" } } Experimental endpoint (feature flagged) Base: /api/v1/conversation/experimental POST /generate sql Enable with: } ' } } generate sql is designed for non transactional configuration tables ( ce_config , ce_intent , ce_rule , ce_prompt_template , ce_response , ce_output_schema , ce_container_config , optional MCP tables). It does not generate runtime conversation/audit data. Generated SQL should be reviewed before use. The endpoint applies safety checks but does not replace human review.",
    "rawContent": "# REST API ## Base <FileRef>/api/v1/conversation</FileRef> ## Endpoints <DbTable title=\"Conversation endpoints\" columns={[\"Method\", \"Path\", \"Purpose\"]} rows={[ [\"POST\", \"/message\", \"Process one turn and return payload\"], [\"GET\", \"/audit/{conversationId}\", \"Raw audit rows for conversation\"], [\"GET\", \"/audit/{conversationId}/trace\", \"Normalized step+stage timeline\"], ]} /> ## POST <FileRef>/message</FileRef> <CodeBlockToggle title=\"Request body\" language=\"json\" defaultOpen={true}> { { \"conversationId\": \"uuid-optional\", \"message\": \"Track request REQ-778102\", \"reset\": false, \"inputParams\": { \"tenant\": \"acme\" } } } </CodeBlockToggle> <CodeBlockToggle title=\"Success response\" language=\"json\" defaultOpen={true}> { { \"success\": true, \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"intent\": \"REQUEST_TRACKER\", \"state\": \"IDLE\", \"payload\": { \"type\": \"TEXT\", \"value\": \"Request REQ-778102 is IN_REVIEW.\" }, \"context\": \"{...}\" } } </CodeBlockToggle> ## Experimental endpoint (feature-flagged) Base: <FileRef>/api/v1/conversation/experimental</FileRef> - <MethodRef>POST /generate-sql</MethodRef> Enable with: <CodeBlockToggle title=\"application.yml (feature flag)\" language=\"yaml\"> { convengine: experimental: enabled: true } </CodeBlockToggle> <Tabs groupId=\"experimental-generate-sql\"> <TabItem value=\"postman\" label=\"Postman\" default> <DbTable title=\"Postman setup\" columns={[\"Field\", \"Value\"]} rows={[ [\"Method\", \"POST\"], [\"URL\", \"http://localhost:8080/api/v1/conversation/experimental/generate-sql\"], [\"Headers\", \"Content-Type: application/json\"], [\"Body Mode\", \"raw (JSON)\"], ]} /> <CodeBlockToggle title=\"Postman body (JSON)\" language=\"json\"> { { \"scenario\": \"Build disconnect electricity workflow\", \"domain\": \"utilities\", \"constraints\": \"Collect account number before action\", \"includeMcp\": true } } </CodeBlockToggle> </TabItem> <TabItem value=\"curl\" label=\"curl\"> <CodeBlockToggle title=\"curl request\" language=\"bash\"> { curl -X POST \"http://localhost:8080/api/v1/conversation/experimental/generate-sql\" \\\\ -H \"Content-Type: application/json\" \\\\ -d '{ \"scenario\": \"Build disconnect electricity workflow\", \"domain\": \"utilities\", \"constraints\": \"Collect account number before action\", \"includeMcp\": true }' } </CodeBlockToggle> </TabItem> </Tabs> <CodeBlockToggle title=\"/experimental/generate-sql success response\" language=\"json\"> { { \"success\": true, \"sql\": \"INSERT INTO ce_config ...;\\\\nINSERT INTO ce_intent ...;\", \"warnings\": [], \"note\": \"Experimental output: review before applying in production.\" } } </CodeBlockToggle> <Highlight type=\"info\" title=\"Generation scope\"> generate-sql is designed for non-transactional configuration tables ( ce_config , ce_intent , ce_rule , ce_prompt_template , ce_response , ce_output_schema , ce_container_config , optional MCP tables). It does not generate runtime conversation/audit data. </Highlight> <Highlight type=\"warning\" title=\"Experimental output\"> Generated SQL should be reviewed before use. The endpoint applies safety checks but does not replace human review. </Highlight>",
    "excerpt": "REST API Base /api/v1/conversation Endpoints POST /message } } , \"context\": \" \" } } Experimental endpoint (feature flagged) Base: /api/v1/conversation/experimental POST /generate sql Enable with: } ' } } generate sql is …"
  },
  {
    "id": "api/stream-api.mdx",
    "version": "v2",
    "title": "stream api",
    "permalink": "/docs/v2/api/stream-api",
    "content": "Stream API (Socket) Base transport endpoints Conversation turns are submitted through POST /api/v1/conversation/message . Socket/SSE channels stream audit stages for that same conversationId . SSE subscription ; source.addEventListener(\"STEP_ENTER\", (event) = ); source.addEventListener(\"ASSISTANT_OUTPUT\", (event) = ); } STOMP subscription , }); client.activate(); } Socket audit payload contract } } } Socket + Audit API usage 1. Call POST /api/v1/conversation/message with conversationId . 2. Subscribe to SSE/STOMP for live stages. 3. Query GET /api/v1/conversation/audit/ '} for raw events. 4. Query GET /api/v1/conversation/audit/ '}/trace for normalized step timeline. Use REST endpoints for deterministic request/response behavior, and use streaming endpoints for observability UX.",
    "rawContent": "# Stream API (Socket) ## Base transport endpoints <DbTable title=\"Streaming endpoints\" columns={[\"Transport\", \"Endpoint / Destination\", \"Purpose\"]} rows={[ [\"SSE\", \"GET /api/v1/conversation/stream/{conversationId}\", \"Server-sent live audit events for one conversation\"], [\"STOMP WS\", \"WS handshake: /ws-convengine\", \"WebSocket endpoint for STOMP clients\"], [\"STOMP topic\", \"/topic/convengine/audit/{conversationId}\", \"Conversation-scoped audit stream destination\"], ]} /> <Highlight type=\"info\" title=\"Flow contract\"> Conversation turns are submitted through <MethodRef>POST /api/v1/conversation/message</MethodRef>. Socket/SSE channels stream audit stages for that same <MethodRef>conversationId</MethodRef>. </Highlight> ## SSE subscription <CodeBlockToggle title=\"SSE client (browser)\" language=\"javascript\"> { const conversationId = \"9bf7540a-b129-4685-a120-730e8a0cb94b\"; const source = new EventSource( \"/api/v1/conversation/stream/\" + conversationId ); source.onmessage = (event) => { // fallback event channel console.log(\"SSE message:\", event.data); }; source.addEventListener(\"STEP_ENTER\", (event) => { console.log(\"STEP_ENTER:\", JSON.parse(event.data)); }); source.addEventListener(\"ASSISTANT_OUTPUT\", (event) => { console.log(\"ASSISTANT_OUTPUT:\", JSON.parse(event.data)); }); } </CodeBlockToggle> ## STOMP subscription <CodeBlockToggle title=\"STOMP client (JS)\" language=\"javascript\"> { // npm i @stomp/stompjs sockjs-client const conversationId = \"9bf7540a-b129-4685-a120-730e8a0cb94b\"; const client = new Client({ webSocketFactory: () => new SockJS(\"/ws-convengine\"), reconnectDelay: 5000, onConnect: () => { client.subscribe( \"/topic/convengine/audit/\" + conversationId, (message) => console.log(\"STOMP audit:\", JSON.parse(message.body)) ); }, }); client.activate(); } </CodeBlockToggle> ## Socket audit payload contract <CodeBlockToggle title=\"SSE/STOMP audit event payload\" language=\"json\"> { { \"auditId\": 12031, \"stage\": \"STEP_ENTER\", \"createdAt\": \"2026-02-14T10:22:01.102Z\", \"payload\": { \"_meta\": { \"stage\": \"STEP_ENTER\", \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"intent\": \"FAQ\", \"state\": \"IDLE\" } } } } </CodeBlockToggle> ## Socket + Audit API usage 1. Call <FileRef>POST /api/v1/conversation/message</FileRef> with conversationId . 2. Subscribe to SSE/STOMP for live stages. 3. Query <FileRef>GET /api/v1/conversation/audit/{'{conversationId}'}</FileRef> for raw events. 4. Query <FileRef>GET /api/v1/conversation/audit/{'{conversationId}'}/trace</FileRef> for normalized step timeline. <Highlight type=\"tip\" title=\"Operational recommendation\"> Use REST endpoints for deterministic request/response behavior, and use streaming endpoints for observability UX. </Highlight>",
    "excerpt": "Stream API (Socket) Base transport endpoints Conversation turns are submitted through POST /api/v1/conversation/message . Socket/SSE channels stream audit stages for that same conversationId . SSE subscription ; source.a…"
  },
  {
    "id": "architecture.mdx",
    "version": "v2",
    "title": "architecture",
    "permalink": "/docs/v2/architecture",
    "content": "Architecture Layers API + Transport Layer ConversationController request ingress + validation + correlation ids SSE / STOMP event transport for audit streams Runtime Pipeline Layer DefaultConversationalEngine EnginePipelineFactory (DAG sort + wrappers + timing + step hooks) EngineSession (per turn mutable state) Decision + Control Layer (v2) dialogue act: DialogueActStep policy: InteractionPolicyStep pending action lifecycle: ActionLifecycleStep , DisambiguationStep , PendingActionStep guard + transition validation: GuardrailStep , StateGraphStep core intent/schema/rules/response path Tooling Layer ToolOrchestrationStep (unified tool request/execute/result contract) McpToolStep (planner loop + CALL_TOOL / ANSWER ) Persistence + Audit Layer JPA repositories on ce_ ce_conversation , ce_audit , ce_memory write path Request Path (high level) Builds EngineContext from conversationId , message , inputParams , optional reset flag. EngineSessionFactory creates session and history provider injects last turns. Dialogue act + interaction policy + pending action lifecycle decide whether to execute task, clarify, or continue standard intent flow. Intent/schema/rules/response steps produce deterministic state transition + assistant payload. Final payload is persisted and returned as TEXT/JSON response, with full audit trail. Code references } } } :::tip Intervention point You can intercept any step via EngineStepHook ( beforeStep , afterStep , onStepError ) without forking the engine. ::: Rules execute by phase in v2: PIPELINE_RULES , AGENT_POST_INTENT , MCP_POST_LLM , and TOOL_POST_EXECUTION . Keep business transitions in ce_rule and state graph config, not hardcoded in steps, so behavior remains data driven and auditable.",
    "rawContent": "# Architecture ## Layers ### API + Transport Layer - <MethodRef>ConversationController</MethodRef> - request ingress + validation + correlation ids - SSE / STOMP event transport for audit streams ### Runtime Pipeline Layer - <MethodRef>DefaultConversationalEngine</MethodRef> - <MethodRef>EnginePipelineFactory</MethodRef> (DAG sort + wrappers + timing + step hooks) - <MethodRef>EngineSession</MethodRef> (per-turn mutable state) ### Decision + Control Layer (v2) - dialogue act: <MethodRef>DialogueActStep</MethodRef> - policy: <MethodRef>InteractionPolicyStep</MethodRef> - pending action lifecycle: <MethodRef>ActionLifecycleStep</MethodRef>, <MethodRef>DisambiguationStep</MethodRef>, <MethodRef>PendingActionStep</MethodRef> - guard + transition validation: <MethodRef>GuardrailStep</MethodRef>, <MethodRef>StateGraphStep</MethodRef> - core intent/schema/rules/response path ### Tooling Layer - <MethodRef>ToolOrchestrationStep</MethodRef> (unified tool request/execute/result contract) - <MethodRef>McpToolStep</MethodRef> (planner loop + CALL_TOOL / ANSWER ) ### Persistence + Audit Layer - JPA repositories on <FileRef>ce_*</FileRef> - <FileRef>ce_conversation</FileRef>, <FileRef>ce_audit</FileRef>, <FileRef>ce_memory</FileRef> write path ## Request Path (high-level) <FlowStep step=\"1\" title=\"Controller receives request\"> Builds <MethodRef>EngineContext</MethodRef> from <MethodRef>conversationId</MethodRef>, <MethodRef>message</MethodRef>, <MethodRef>inputParams</MethodRef>, optional <MethodRef>reset</MethodRef> flag. </FlowStep> <FlowStep step=\"2\" title=\"Engine opens session\"> <MethodRef>EngineSessionFactory</MethodRef> creates session and history provider injects last turns. </FlowStep> <FlowStep step=\"3\" title=\"v2 control steps run\"> Dialogue act + interaction policy + pending-action lifecycle decide whether to execute task, clarify, or continue standard intent flow. </FlowStep> <FlowStep step=\"4\" title=\"Core flow resolves output\"> Intent/schema/rules/response steps produce deterministic state transition + assistant payload. </FlowStep> <FlowStep step=\"5\" title=\"Persist + return result\"> Final payload is persisted and returned as TEXT/JSON response, with full audit trail. </FlowStep> ## Code references <CodeBlockToggle title=\"Engine entrypoint\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" defaultOpen={false} > { @Override public EngineResult process(EngineContext engineContext) { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } } </CodeBlockToggle> <CodeBlockToggle title=\"Pipeline execution loop\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java\" > { for (EngineStep step : steps) { StepResult r = step.execute(session); if (r instanceof StepResult.Stop(EngineResult result)) { return result; } } } </CodeBlockToggle> :::tip Intervention point You can intercept any step via <MethodRef>EngineStepHook</MethodRef> (<MethodRef>beforeStep</MethodRef>, <MethodRef>afterStep</MethodRef>, <MethodRef>onStepError</MethodRef>) without forking the engine. ::: <Highlight type=\"info\" title=\"v2 control phases\"> Rules execute by phase in v2: <MethodRef>PIPELINE_RULES</MethodRef>, <MethodRef>AGENT_POST_INTENT</MethodRef>, <MethodRef>MCP_POST_LLM</MethodRef>, and <MethodRef>TOOL_POST_EXECUTION</MethodRef>. </Highlight> <Highlight type=\"warning\" title=\"Deterministic boundary\"> Keep business transitions in <FileRef>ce_rule</FileRef> and state graph config, not hardcoded in steps, so behavior remains data-driven and auditable. </Highlight>",
    "excerpt": "Architecture Layers API + Transport Layer ConversationController request ingress + validation + correlation ids SSE / STOMP event transport for audit streams Runtime Pipeline Layer DefaultConversationalEngine EnginePipel…"
  },
  {
    "id": "consumer/annotations-reference.mdx",
    "version": "v2",
    "title": "annotations reference",
    "permalink": "/docs/v2/consumer/annotations-reference",
    "content": "Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. Consumer entry annotations } } } stream is an annotation parameter on @EnableConvEngine , not a YAML key. Keep it aligned with convengine.transport.sse.enabled and convengine.transport.stomp.enabled . Extension annotations (consumer customization) } } } } @Override public ContainerComponentResponse intercept(ContainerComponentResponse response, EngineSession session) } } If a class uses @ResponseTransformer or @ContainerDataTransformer but does not implement the required handler interface, startup fails. Internal pipeline annotations (advanced / framework contributors) } } Pipeline requires exactly one @ConversationBootstrapStep and one @TerminalStep . Misuse can break startup DAG validation. Quick recommendations for consumers 1. Use only @EnableConvEngine initially. 2. Add @ResponseTransformer or container annotations only when you have a concrete customization need. 3. Avoid pipeline DAG annotations unless you are intentionally adding custom engine steps and can test full ordering. 4. Keep annotation usage paired with integration tests for one real conversation flow. See , , and for end to end integration context.",
    "rawContent": "# Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. ## Consumer entry annotations <DbTable title=\"Use these in your consumer app\" columns={[\"Annotation\", \"Target\", \"Purpose\", \"Typical usage\"]} rows={[ [\" @EnableConvEngine(stream = true|false) \", \"Spring Boot app class\", \"Bootstraps ConvEngine auto-configuration and stream setting.\", \"Always required to activate framework.\"], [\" @EnableConvEngineAsyncAuditDispatch \", \"Spring config/app class\", \"Forces async audit dispatch marker mode.\", \"Use when you intentionally want async listener dispatch.\"], [\" @EnableConvEngineStompBrokerRelay \", \"Spring config/app class\", \"Forces STOMP broker relay marker mode.\", \"Use when deploying with external STOMP broker relay.\"], ]} /> <CodeBlockToggle title=\"Basic enablement\" language=\"java\"> { @SpringBootApplication @EnableConvEngine(stream = true) public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> <CodeBlockToggle title=\"Optional relay + async markers\" language=\"java\"> { @Configuration @EnableConvEngineAsyncAuditDispatch @EnableConvEngineStompBrokerRelay public class ConvEngineFeatureFlags { } } </CodeBlockToggle> <Highlight type=\"info\" title=\"How stream mode works\"> stream is an annotation parameter on @EnableConvEngine , not a YAML key. Keep it aligned with convengine.transport.sse.enabled and convengine.transport.stomp.enabled . </Highlight> ## Extension annotations (consumer customization) <DbTable title=\"Extension points\" columns={[\"Annotation\", \"Must implement\", \"Purpose\", \"Key parameters\"]} rows={[ [\" @ResponseTransformer \", \" ResponseTransformerHandler \", \"Last-mile payload shaping by intent/state.\", \" intent , state \"], [\" @ContainerDataTransformer \", \" ContainerDataTransformerHandler \", \"Transforms CCF container data before session attach.\", \" intent , state \"], [\" @ContainerDataInterceptor \", \" ContainerDataRequestInterceptor and/or ContainerDataResponseInterceptor \", \"Intercepts CCF request/response around execution.\", \" intent , state , order \"], ]} /> <CodeBlockToggle title=\"Response transformer example\" language=\"java\"> { @Component @ResponseTransformer(intent = \"REQUEST_TRACKER\", state = \"IDLE\") public class TrackerResponseTransformer implements ResponseTransformerHandler { @Override public OutputPayload transform(OutputPayload responsePayload, EngineSession session, Map<String, Object> inputParams) { return responsePayload; } } } </CodeBlockToggle> <CodeBlockToggle title=\"Container transformer example\" language=\"java\"> { @Component @ContainerDataTransformer(intent = \"DISCONNECT_ELECTRICITY\", state = \"COLLECTING\") public class DisconnectContainerTransformer implements ContainerDataTransformerHandler { @Override public Map<String, Object> transform(ContainerComponentResponse response, EngineSession session, Map<String, Object> inputParams) { return Map.of(\"normalized\", response); } } } </CodeBlockToggle> <CodeBlockToggle title=\"Container interceptor example\" language=\"java\"> { @Component @ContainerDataInterceptor(intent = \"*\", state = \"*\", order = 10) public class TraceContainerInterceptor implements ContainerDataRequestInterceptor, ContainerDataResponseInterceptor { @Override public void intercept(ContainerComponentRequest request, EngineSession session) { // mutate request if needed } @Override public ContainerComponentResponse intercept(ContainerComponentResponse response, EngineSession session) { return response; } } } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Transformer/interceptor registration rules\"> If a class uses @ResponseTransformer or @ContainerDataTransformer but does not implement the required handler interface, startup fails. </Highlight> ## Internal pipeline annotations (advanced / framework contributors) <DbTable title=\"Engine DAG annotations\" columns={[\"Annotation\", \"Role\", \"Who should use it\"]} rows={[ [\" @MustRunAfter(...) \", \"Declares DAG dependency: step runs after listed steps.\", \"Framework contributors adding new EngineStep beans.\"], [\" @MustRunBefore(...) \", \"Declares DAG dependency: step runs before listed steps.\", \"Framework contributors adding new EngineStep beans.\"], [\" @RequiresConversationPersisted \", \"Forces ordering after bootstrap persistence step.\", \"Framework/internal step authors.\"], [\" @ConversationBootstrapStep \", \"Marks the single bootstrap step in pipeline.\", \"Framework internals only.\"], [\" @TerminalStep \", \"Marks the single terminal step in pipeline.\", \"Framework internals only.\"], [\" @PromptVar \", \"Maps fields in internal prompt context models to template aliases.\", \"Framework internals only; not for consumer app classes.\"], ]} /> <CodeBlockToggle title=\"Custom step with ordering\" language=\"java\"> { @Component @RequiresConversationPersisted @MustRunAfter(IntentResolutionStep.class) @MustRunBefore(ResponseResolutionStep.class) public class CustomValidationStep implements EngineStep { @Override public StepResult execute(EngineSession session) { return new StepResult.Continue(); } } } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Important constraints\"> Pipeline requires exactly one @ConversationBootstrapStep and one @TerminalStep . Misuse can break startup DAG validation. </Highlight> ## Quick recommendations for consumers 1. Use only @EnableConvEngine initially. 2. Add @ResponseTransformer or container annotations only when you have a concrete customization need. 3. Avoid pipeline DAG annotations unless you are intentionally adding custom engine steps and can test full ordering. 4. Keep annotation usage paired with integration tests for one real conversation flow. <Highlight type=\"info\" title=\"Related pages\"> See [Consumer Guide](/docs/v2/consumer/), [New Consumer Onboarding](/docs/v2/consumer/new-consumer-onboarding), and [Extensions](/docs/v2/consumer/extensions) for end-to-end integration context. </Highlight>",
    "excerpt": "Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. Consumer entry annotations } } } stream is an annotation parameter on @EnableConvEngine , not …"
  },
  {
    "id": "consumer/backend-integration.mdx",
    "version": "v2",
    "title": "backend integration",
    "permalink": "/docs/v2/consumer/backend-integration",
    "content": "Backend Integration This page uses your demo repos directly: backend reference: convengine demo UI reference: zapper ui What each demo proves convengine demo : Spring Boot consumer setup, transport mode config, step hooks, LLM wiring. zapper ui : conversation client, SSE subscription, audit timeline UI. Add @EnableConvEngine and provide required beans. Use profile yaml ( sse , stomp , both ) to switch runtime behavior. Frontend posts to message endpoint and listens to SSE/STOMP for audit updates. convengine demo: Core app bootstrap ) @EntityScan(basePackages = ) @EnableJpaRepositories(basePackages = ) public class ConvengineDemoApplication } } @Bean public ObjectMapper objectMapper() } } convengine demo: Runtime config model: gpt 4.1 base url: https://api.openai.com lmstudio: api key: \\$ model: openai/gpt oss 20b base url: http://localhost:1234 transport: sse: enabled: true emitter timeout ms: 1800000 stomp: enabled: false endpoint: /ws convengine app destination prefix: /app topic prefix: /topic audit destination base: /topic/convengine/audit allowed origin pattern: \" \" sock js: true broker: mode: SIMPLE relay destination prefixes: /topic,/queue relay host: localhost relay port: 61613 client login: \"\" client passcode: \"\" system login: \"\" system passcode: \"\" virtual host: \"\" system heartbeat send interval ms: 10000 system heartbeat receive interval ms: 10000 audit: enabled: true level: ALL include stages: [] exclude stages: [] persistence: mode: IMMEDIATE jdbc batch size: 200 max buffered events: 5000 flush stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final step names: PipelineEndGuardStep flush on stop outcome: true dispatch: async enabled: false worker threads: 2 queue capacity: 2000 rejection policy: CALLER_RUNS keep alive seconds: 60 rate limit: enabled: false max events: 200 window ms: 1000 per conversation: true per stage: true max tracked buckets: 20000 } Keep broker.mode: SIMPLE and audit.dispatch.async enabled: false for baseline. Enable relay and async in non prod first, then tune queue capacity , rejection policy , and rate limit using audit volume. convengine demo: Transport + Hook diagnostics public static class StepHook } } } } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) @Override public void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) @Override public void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) } } zapper ui: How frontend consumes backend ); return () = stream.close(); }, [conversationId]); } ]); // Typing indicator shown while request is in flight } 1. Start backend ( convengine demo ) with profile sse , stomp , or both . 2. Start zapper ui and point API base to backend URL. 3. Send message, verify live timeline from stream + detailed payloads from audit API.",
    "rawContent": "# Backend Integration This page uses your demo repos directly: - backend reference: <FileRef>convengine-demo</FileRef> - UI reference: <FileRef>zapper-ui</FileRef> ## What each demo proves - <FileRef>convengine-demo</FileRef>: Spring Boot consumer setup, transport mode config, step hooks, LLM wiring. - <FileRef>zapper-ui</FileRef>: conversation client, SSE subscription, audit timeline UI. <FlowStep step=\"1\" title=\"Enable ConvEngine in backend\"> Add <MethodRef>@EnableConvEngine</MethodRef> and provide required beans. </FlowStep> <FlowStep step=\"2\" title=\"Configure transport mode\"> Use profile yaml ( sse , stomp , both ) to switch runtime behavior. </FlowStep> <FlowStep step=\"3\" title=\"Connect frontend\"> Frontend posts to message endpoint and listens to SSE/STOMP for audit updates. </FlowStep> ## convengine-demo: Core app bootstrap <CodeBlockToggle title=\"ConvengineDemoApplication.java\" language=\"java\" packagePath=\"com.github.salilvnair\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/ConvengineDemoApplication.java\" > { @SpringBootApplication @ComponentScan(basePackages = {\"com.github.salilvnair.convengdemo\"}) @EntityScan(basePackages = {\"com.github.salilvnair.convengdemo.entity\"}) @EnableJpaRepositories(basePackages = {\"com.github.salilvnair.convengdemo.repo\"}) public class ConvengineDemoApplication { public static void main(String[] args) { SpringApplication.run(ConvengineDemoApplication.class, args); } } } </CodeBlockToggle> <CodeBlockToggle title=\"ConvEngineConfig.java\" language=\"java\" packagePath=\"com.github.salilvnair.convengdemo.config\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/ConvEngineConfig.java\" > { @Configuration @EnableConvEngine @EnableConvEngineAsyncAuditDispatch // optional @EnableConvEngineStompBrokerRelay // optional @EnableCcfCore public class ConvEngineConfig { @Bean public RestWebServiceFacade restWebServiceFacade() { return new RestWebServiceFacade(); } @Bean public ObjectMapper objectMapper() { return new ObjectMapper(); } } } </CodeBlockToggle> ## convengine-demo: Runtime config <CodeBlockToggle title=\"application.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application.yml\" > { server: port: 8080 spring: datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd convengine: demo: stream-mode: SSE step-hook: enabled: true tables: AUDIT: CE_AUDIT CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE VALIDATION_SNAPSHOT: CE_VALIDATION_SNAPSHOT llm: provider: openai temperature: 0.3 openai: api-key: \\${OPENAI_API_KEY\\} model: gpt-4.1 base-url: https://api.openai.com lmstudio: api-key: \\${LMSTUDIO_API_KEY\\} model: openai/gpt-oss-20b base-url: http://localhost:1234 transport: sse: enabled: true emitter-timeout-ms: 1800000 stomp: enabled: false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 } </CodeBlockToggle> <CodeBlockToggle title=\"application-sse.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-sse.yml\"> { convengine: demo: stream-mode: SSE transport: sse: enabled: true stomp: enabled: false } </CodeBlockToggle> <CodeBlockToggle title=\"application-stomp.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-stomp.yml\"> { convengine: demo: stream-mode: STOMP transport: sse: enabled: false stomp: enabled: true } </CodeBlockToggle> <CodeBlockToggle title=\"application-both.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-both.yml\"> { convengine: demo: stream-mode: BOTH transport: sse: enabled: true stomp: enabled: true } </CodeBlockToggle> <Highlight type=\"tip\" title=\"Relay + async audit rollout\"> Keep broker.mode: SIMPLE and audit.dispatch.async-enabled: false for baseline. Enable relay and async in non-prod first, then tune queue-capacity , rejection-policy , and rate-limit using audit volume. </Highlight> ## convengine-demo: Transport + Hook diagnostics <CodeBlockToggle title=\"DemoTransportProperties.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/DemoTransportProperties.java\" > { @Component @ConfigurationProperties(prefix = \"convengine.demo\") public class DemoTransportProperties { private StreamMode streamMode = StreamMode.SSE; private StepHook stepHook = new StepHook(); public enum StreamMode { SSE, STOMP, BOTH } public static class StepHook { private boolean enabled = true; } } } </CodeBlockToggle> <CodeBlockToggle title=\"ConvEngineTransportStartupLogger.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/ConvEngineTransportStartupLogger.java\" > { @Component @RequiredArgsConstructor public class ConvEngineTransportStartupLogger { private final DemoTransportProperties demoTransportProperties; private final ConvEngineTransportConfig transportConfig; private final Environment environment; @EventListener(ApplicationReadyEvent.class) public void logTransportConfiguration() { boolean sseEnabled = transportConfig.getSse().isEnabled(); boolean stompEnabled = transportConfig.getStomp().isEnabled(); // validates mode and prints endpoints } } } </CodeBlockToggle> <CodeBlockToggle title=\"DemoEngineStepHook.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/DemoEngineStepHook.java\" > { @Component @RequiredArgsConstructor public class DemoEngineStepHook implements EngineStepHook { private static final Set<EngineStep.Name> TRACKED_STEPS = Set.of( EngineStep.Name.IntentResolutionStep, EngineStep.Name.SchemaExtractionStep, EngineStep.Name.RulesStep, EngineStep.Name.ResponseResolutionStep ); @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return demoTransportProperties.getStepHook().isEnabled() && TRACKED_STEPS.contains(stepName); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { /* logs */ } @Override public void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) { /* logs */ } @Override public void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) { /* logs */ } } } </CodeBlockToggle> ## zapper-ui: How frontend consumes backend <CodeBlockToggle title=\"convengine.api.js (zapper-ui)\" language=\"js\" filePath=\"zapper-ui/src/api/convengine.api.js\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; // STOMP scaffold commented for optional enablement } </CodeBlockToggle> <CodeBlockToggle title=\"App.jsx (zapper-ui)\" language=\"jsx\" filePath=\"zapper-ui/src/App.jsx\" > { useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion(v => v + 1), onEvent: () => setAuditVersion(v => v + 1), }); return () => stream.close(); }, [conversationId]); } </CodeBlockToggle> <CodeBlockToggle title=\"ChatPanel.jsx (zapper-ui)\" language=\"jsx\" filePath=\"zapper-ui/src/components/ChatPanel.jsx\" > { const res = await sendMessage(conversationId, userText); setMessages(m => [...m, { role: \"assistant\", text: assistantText }]); // Typing indicator shown while request is in-flight } </CodeBlockToggle> <Highlight type=\"info\" title=\"Backend + UI runbook\"> 1. Start backend ( convengine-demo ) with profile <MethodRef>sse</MethodRef>, <MethodRef>stomp</MethodRef>, or <MethodRef>both</MethodRef>. 2. Start <FileRef>zapper-ui</FileRef> and point API base to backend URL. 3. Send message, verify live timeline from stream + detailed payloads from audit API. </Highlight> <CodeBlockToggle title=\"Run commands\" language=\"bash\" defaultOpen={false}> { # backend (convengine-demo) ./mvnw spring-boot:run -Dspring-boot.run.profiles=sse # or ./mvnw spring-boot:run -Dspring-boot.run.profiles=stomp # or ./mvnw spring-boot:run -Dspring-boot.run.profiles=both # frontend (zapper-ui) npm install npm run dev } </CodeBlockToggle>",
    "excerpt": "Backend Integration This page uses your demo repos directly: backend reference: convengine demo UI reference: zapper ui What each demo proves convengine demo : Spring Boot consumer setup, transport mode config, step hook…"
  },
  {
    "id": "consumer/configuration.mdx",
    "version": "v2",
    "title": "configuration",
    "permalink": "/docs/v2/consumer/configuration",
    "content": "Consumer Configuration (v2) Core namespaces convengine.flow. (runtime behavior tuning) convengine.audit. convengine.transport. convengine.experimental. Flow config (v2) yaml convengine: flow: dialogue act: resolute: REGEX_THEN_LLM REGEX_ONLY | REGEX_THEN_LLM | LLM_ONLY llm threshold: 0.90 interaction policy: execute pending on affirm: true reject pending on negate: true fill pending slot on non new request: true require resolved intent and state: true matrix: \"PENDING_ACTION:AFFIRM\": EXECUTE_PENDING_ACTION \"PENDING_ACTION:NEGATE\": REJECT_PENDING_ACTION \"PENDING_SLOT:QUESTION\": FILL_PENDING_SLOT action lifecycle: enabled: true ttl turns: 3 ttl minutes: 30 disambiguation: enabled: true max options: 5 guardrail: enabled: true sanitize input: true require approval for sensitive actions: false approval gate fail closed: false sensitive patterns: [] state graph: enabled: true soft block on violation: false allowed transitions: tool orchestration: enabled: true memory: enabled: true summary max chars: 1200 recent turns for summary: 3 Why this matters This config controls v2 behavior without requiring consumer side hardcoded Java branching for common dialogue/action patterns.",
    "rawContent": "# Consumer Configuration (v2) ## Core namespaces - convengine.flow.* (runtime behavior tuning) - convengine.audit.* - convengine.transport.* - convengine.experimental.* ## Flow config (v2) yaml convengine: flow: dialogue-act: resolute: REGEX_THEN_LLM # REGEX_ONLY | REGEX_THEN_LLM | LLM_ONLY llm-threshold: 0.90 interaction-policy: execute-pending-on-affirm: true reject-pending-on-negate: true fill-pending-slot-on-non-new-request: true require-resolved-intent-and-state: true matrix: \"PENDING_ACTION:AFFIRM\": EXECUTE_PENDING_ACTION \"PENDING_ACTION:NEGATE\": REJECT_PENDING_ACTION \"PENDING_SLOT:QUESTION\": FILL_PENDING_SLOT action-lifecycle: enabled: true ttl-turns: 3 ttl-minutes: 30 disambiguation: enabled: true max-options: 5 guardrail: enabled: true sanitize-input: true require-approval-for-sensitive-actions: false approval-gate-fail-closed: false sensitive-patterns: [] state-graph: enabled: true soft-block-on-violation: false allowed-transitions: {} tool-orchestration: enabled: true memory: enabled: true summary-max-chars: 1200 recent-turns-for-summary: 3 ## Why this matters This config controls v2 behavior without requiring consumer-side hardcoded Java branching for common dialogue/action patterns.",
    "excerpt": "Consumer Configuration (v2) Core namespaces convengine.flow. (runtime behavior tuning) convengine.audit. convengine.transport. convengine.experimental. Flow config (v2) yaml convengine: flow: dialogue act: resolute: REGE…"
  },
  {
    "id": "consumer/extensions.mdx",
    "version": "v2",
    "title": "extensions",
    "permalink": "/docs/v2/consumer/extensions",
    "content": "Extension Points and Intervention Scenarios EngineStepHook intervene between any steps Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } :::tip Where to use this Use hooks when you need low friction runtime intervention without forking framework steps. ::: ContainerDataTransformer reshape container response Real scenario: CCF returns nested payload; you flatten to schema friendly map. } } ResponseTransformer post process final payload Real scenario: Add support team escalation footer for high severity disconnect failures. return responsePayload; } } } ContainerDataInterceptor intercept request/response around CCF Real scenario: add tenant metadata and redact a field before persistence. Rule Action Playbook ( SET_TASK , SET_JSON , GET_CONTEXT , GET_SESSION ) These actions execute inside RulesStep.execute(...) and mutate the live EngineSession . Set ce_rule.phase based on where you want the action to run: PIPELINE_RULES : normal RulesStep pass. AGENT_POST_INTENT : post intent pass inside AgentIntentResolver . SET_TASK execute consumer Java methods from rule Use this when a rule match must trigger consumer side business logic (incident raise, tracker lookup, eligibility fetch, etc). Set ce_rule.action to SET_TASK and provide bean/method mapping in action_value . Bean must be a Spring bean with the configured bean name and implement CeRuleTask . Methods are invoked with (EngineSession session, CeRule rule) . public void attachEta(EngineSession session, CeRule rule) } } Downstream prompt/response can read new context/inputParams (for example requestStatus , lastUpdated , eta_hours ). SET_JSON move JSONPath value into input params Use this to extract one value from runtime session JSON into a flat prompt var. SET_JSON writes to session.putInputParam(\"error_code\", value) . It does not change session.contextJson unless your subsequent task/hook updates context explicitly. GET_CONTEXT snapshot context into input params Use this when prompt templates or tasks need full context as a single variable. If action_value is blank, engine uses default key context . GET_SESSION snapshot session facts into input params Use this for advanced derived responses that need runtime flags ( schemaComplete , intentLocked , missingRequiredFields , etc). If action_value is blank, engine uses default key session . SET_TASK methods run during rule execution. Keep methods deterministic and idempotent. For side effecting calls (ticket creation, webhook dispatch), guard with strict rule conditions and add idempotency keys from conversationId . Resolvers engine/rule/type/provider/SetTaskActionResolver.java engine/rule/type/provider/SetJsonActionResolver.java engine/rule/type/provider/GetContextActionResolver.java engine/rule/type/provider/GetSessionActionResolver.java Task invocation engine/rule/task/CeRuleTaskExecutor.java Execution loop engine/steps/RulesStep.java Custom action resolver ( RuleActionResolver ) Consumer can define a brand new rule action without changing framework core. Implement RuleActionResolver and return your action name from action() . @Override public void resolve(EngineSession session, CeRule rule) } } Set ce_rule.action to your custom token (case insensitive lookup), for example ENRICH_TIER . No manual factory config is needed. RuleActionResolverFactory auto registration behavior auto discovers all Spring beans implementing RuleActionResolver and maps by action().toUpperCase() .",
    "rawContent": "# Extension Points and Intervention Scenarios <div className=\"ce-extensions-page\"> ## EngineStepHook - intervene between any steps {#1-enginestephook---intervene-between-any-steps} Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. <CodeBlockToggle title=\"EngineStepHook example\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\"> { @Component public class LogAnalysisHintHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName && \"LOG_ANALYSIS\".equalsIgnoreCase(session.getIntent()); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"log_source_priority\", \"APM_FIRST\"); } } } </CodeBlockToggle> :::tip Where to use this Use hooks when you need low-friction runtime intervention without forking framework steps. ::: ## ContainerDataTransformer - reshape container response {#2-containerdatatransformer---reshape-container-response} Real scenario: CCF returns nested payload; you flatten to schema-friendly map. <CodeBlockToggle title=\"ContainerDataTransformer example\" language=\"java\" packagePath=\"com.zapper.convengine.transformers\"> { @Component @ContainerDataTransformer(intent = \"REQUEST_TRACKER\", state = \"IDLE\") public class RequestTrackerContainerTransformer implements ContainerDataTransformerHandler { @Override public Map<String, Object> transform(ContainerComponentResponse response, EngineSession session, Map<String, Object> inputParams) { Map<String, Object> out = new LinkedHashMap<>(); out.put(\"ticket_id\", inputParams.get(\"ticketId\")); out.put(\"status\", \"IN_REVIEW\"); return out; } } } </CodeBlockToggle> ## ResponseTransformer - post-process final payload {#3-responsetransformer---post-process-final-payload} Real scenario: Add support-team escalation footer for high-severity disconnect failures. <CodeBlockToggle title=\"ResponseTransformer example\" language=\"java\" packagePath=\"com.zapper.convengine.transformers\"> { @Component @ResponseTransformer(intent = \"DISCONNECT_ELECTRICITY\", state = \"FAILED\") public class DisconnectFailureResponseTransformer implements ResponseTransformerHandler { @Override public OutputPayload transform(OutputPayload responsePayload, EngineSession session, Map<String, Object> inputParams) { if (responsePayload instanceof TextPayload(String text)) { return new TextPayload(text + \"\\\\nIf this is urgent, call support at +1-800-000-0000.\"); } return responsePayload; } } } </CodeBlockToggle> ## ContainerDataInterceptor - intercept request/response around CCF {#4-containerdatainterceptor---intercept-requestresponse-around-ccf} Real scenario: add tenant metadata and redact a field before persistence. <CodeBlockToggle title=\"Interceptor scenario (concept)\" language=\"text\"> { Before Execute: - inject tenantId/requestId - attach observability headers After Execute: - redact sensitive node from raw container payload - enrich session input params for downstream rule checks } </CodeBlockToggle> ## Rule Action Playbook ( SET_TASK , SET_JSON , GET_CONTEXT , GET_SESSION ) {#5-rule-action-playbook-set_task-set_json-get_context-get_session} These actions execute inside <MethodRef>RulesStep.execute(...)</MethodRef> and mutate the live <MethodRef>EngineSession</MethodRef>. Set <MethodRef>ce_rule.phase</MethodRef> based on where you want the action to run: - <MethodRef>PIPELINE_RULES</MethodRef>: normal <MethodRef>RulesStep</MethodRef> pass. - <MethodRef>AGENT_POST_INTENT</MethodRef>: post-intent pass inside <MethodRef>AgentIntentResolver</MethodRef>. <DbTable title=\"Action value format (exact runtime behavior)\" columns={[\"Action\", \"action_value format\", \"Engine behavior\"]} rows={[ [\"SET_TASK\", \"beanName:methodName or beanName:methodA,methodB\", \"Invokes Spring bean methods via CeRuleTaskExecutor\"], [\"SET_JSON\", \"targetKey:jsonPath\", \"Extracts JSONPath from session eject and stores into inputParams[targetKey]\"], [\"GET_CONTEXT\", \"targetKey (optional)\", \"Stores session.contextDict() into inputParams[targetKey] (default key=context)\"], [\"GET_SESSION\", \"targetKey (optional)\", \"Stores session.sessionDict() into inputParams[targetKey] (default key=session)\"], ]} /> ### SET_TASK - execute consumer Java methods from rule {#51-set_task---execute-consumer-java-methods-from-rule} Use this when a rule match must trigger consumer-side business logic (incident raise, tracker lookup, eligibility fetch, etc). <FlowStep step=\"1\" title=\"Create ce_rule row\"> Set <MethodRef>ce_rule.action</MethodRef> to <MethodRef>SET_TASK</MethodRef> and provide bean/method mapping in <MethodRef>action_value</MethodRef>. </FlowStep> <CodeBlockToggle title=\"SET_TASK rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'ANY', 'REGEX', '(?i).*track.*request.*', 'SET_TASK', 'requestTrackerTask:loadStatus,attachEta', 10, true, 'Load tracker status + ETA from consumer service'); } </CodeBlockToggle> <FlowStep step=\"2\" title=\"Implement task bean\"> Bean must be a Spring bean with the configured bean name and implement <MethodRef>CeRuleTask</MethodRef>. Methods are invoked with <MethodRef>(EngineSession session, CeRule rule)</MethodRef>. </FlowStep> <CodeBlockToggle title=\"Consumer task bean (Java)\" language=\"java\" packagePath=\"com.zapper.convengine.tasks\" filePath=\"src/main/java/com/acme/convengine/tasks/RequestTrackerTask.java\" > { @Component(\"requestTrackerTask\") public class RequestTrackerTask implements CeRuleTask { public void loadStatus(EngineSession session, CeRule rule) { String requestId = String.valueOf(session.getInputParams().getOrDefault(\"requestId\", \"\")); // fetch from your DB/service session.putInputParam(\"requestStatus\", \"APPROVAL_PENDING\"); session.putInputParam(\"lastUpdated\", \"2026-02-10T11:40:00Z\"); } public void attachEta(EngineSession session, CeRule rule) { session.putInputParam(\"eta_hours\", 12); } } } </CodeBlockToggle> <FlowStep step=\"3\" title=\"Use in response generation\"> Downstream prompt/response can read new context/inputParams (for example requestStatus , lastUpdated , eta_hours ). </FlowStep> ### SET_JSON - move JSONPath value into input params {#52-set_json---move-jsonpath-value-into-input-params} Use this to extract one value from runtime session JSON into a flat prompt var. <CodeBlockToggle title=\"SET_JSON rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'LOG_ANALYSIS', 'ANY', 'JSON_PATH', '$.schemaJson.errorCode != null', 'SET_JSON', 'error_code:$.schemaJson.errorCode', 20, true, 'Expose extracted errorCode as prompt var'); } </CodeBlockToggle> <Highlight type=\"info\" title=\"What exactly gets updated\"> SET_JSON writes to <MethodRef>session.putInputParam(\"error_code\", value)</MethodRef>. It does not change session.contextJson unless your subsequent task/hook updates context explicitly. </Highlight> ### GET_CONTEXT - snapshot context into input params {#53-get_context---snapshot-context-into-input-params} Use this when prompt templates or tasks need full context as a single variable. <CodeBlockToggle title=\"GET_CONTEXT rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'ANY', 'REGEX', '(?i).*status.*', 'GET_CONTEXT', 'ctx_snapshot', 30, true, 'Expose full context to prompt/task layer'); } </CodeBlockToggle> If action_value is blank, engine uses default key context . ### GET_SESSION - snapshot session facts into input params {#54-get_session---snapshot-session-facts-into-input-params} Use this for advanced derived responses that need runtime flags ( schemaComplete , intentLocked , missingRequiredFields , etc). <CodeBlockToggle title=\"GET_SESSION rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'DISCONNECT_ELECTRICITY', 'ANY', 'JSON_PATH', '$.schemaComplete == false', 'GET_SESSION', 'session_snapshot', 40, true, 'Expose full runtime session facts for follow-up prompt decisions'); } </CodeBlockToggle> If action_value is blank, engine uses default key session . <Highlight type=\"warning\" title=\"Operational guardrails\"> SET_TASK methods run during rule execution. Keep methods deterministic and idempotent. For side-effecting calls (ticket creation, webhook dispatch), guard with strict rule conditions and add idempotency keys from <MethodRef>conversationId</MethodRef>. </Highlight> <Highlight type=\"tip\" title=\"Where to trace this in code\"> <div className=\"ce-chip-groups\"> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Resolvers</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/SetTaskActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/SetJsonActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/GetContextActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/GetSessionActionResolver.java</FileRef></span> </div> </div> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Task invocation</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/rule/task/CeRuleTaskExecutor.java</FileRef></span> </div> </div> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Execution loop</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/steps/RulesStep.java</FileRef></span> </div> </div> </div> </Highlight> ### Custom action resolver ( RuleActionResolver ) {#55-custom-action-resolver-ruleactionresolver} Consumer can define a brand-new rule action without changing framework core. <FlowStep step=\"1\" title=\"Create custom resolver bean\"> Implement <MethodRef>RuleActionResolver</MethodRef> and return your action name from <MethodRef>action()</MethodRef>. </FlowStep> <CodeBlockToggle title=\"Custom RuleActionResolver example\" language=\"java\" packagePath=\"com.zapper.convengine.rules\" filePath=\"src/main/java/com/acme/convengine/rules/EnrichCustomerTierActionResolver.java\" > { @Component public class EnrichCustomerTierActionResolver implements RuleActionResolver { @Override public String action() { return \"ENRICH_TIER\"; } @Override public void resolve(EngineSession session, CeRule rule) { // action_value example: customerTier:PREMIUM String raw = rule.getActionValue() == null ? \"\" : rule.getActionValue(); String[] parts = raw.split(\":\", 2); String key = parts.length > 0 && !parts[0].isBlank() ? parts[0] : \"customerTier\"; String value = parts.length > 1 ? parts[1] : \"STANDARD\"; session.putInputParam(key, value); } } } </CodeBlockToggle> <FlowStep step=\"2\" title=\"Use action in ce_rule\"> Set <MethodRef>ce_rule.action</MethodRef> to your custom token (case-insensitive lookup), for example <MethodRef>ENRICH_TIER</MethodRef>. </FlowStep> <CodeBlockToggle title=\"ce_rule row for custom action\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'REGEX', '(?i).*vip.*', 'ENRICH_TIER', 'customerTier:PREMIUM', 5, true, 'Mark VIP tier for downstream response logic'); } </CodeBlockToggle> <Highlight type=\"tip\" title=\"Auto-registration behavior\"> No manual factory config is needed. <DocTermPopup term=\"Auto-registration behavior\">RuleActionResolverFactory auto-registration behavior</DocTermPopup> auto-discovers all Spring beans implementing <MethodRef>RuleActionResolver</MethodRef> and maps by <MethodRef>action().toUpperCase()</MethodRef>. </Highlight> </div>",
    "excerpt": "Extension Points and Intervention Scenarios EngineStepHook intervene between any steps Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. @Override public void beforeStep(EngineS…"
  },
  {
    "id": "consumer/index.mdx",
    "version": "v2",
    "title": "index",
    "permalink": "/docs/v2/consumer",
    "content": "Consumer Integration (v2) What changed in v2 integration Configure behavior via convengine.flow. Use ce_pending_action for confirmable actions Prefer rules/policy over custom Java branching Add tool executors through tool group adapters Minimum setup @EnableConvEngine LlmClient implementation DDL + seed for required ce_ tables response/rule rows for initial and terminal states",
    "rawContent": "# Consumer Integration (v2) ## What changed in v2 integration - Configure behavior via convengine.flow.* - Use ce_pending_action for confirmable actions - Prefer rules/policy over custom Java branching - Add tool executors through tool-group adapters ## Minimum setup - @EnableConvEngine - LlmClient implementation - DDL + seed for required ce_* tables - response/rule rows for initial and terminal states",
    "excerpt": "Consumer Integration (v2) What changed in v2 integration Configure behavior via convengine.flow. Use ce_pending_action for confirmable actions Prefer rules/policy over custom Java branching Add tool executors through too…"
  },
  {
    "id": "consumer/new-consumer-onboarding.mdx",
    "version": "v2",
    "title": "new consumer onboarding",
    "permalink": "/docs/v2/consumer/new-consumer-onboarding",
    "content": "New Consumer Onboarding This is the practical playbook for teams integrating ConvEngine for the first time. Follow this sequence to avoid the common mistakes: wrong data routing, stale intent carry over, unsafe prompt exposure, and concurrency drift. What a new consumer must decide first Step by step onboarding Enable @EnableConvEngine , provide one production grade LlmClient bean with strict timeout and retry policy. Seed minimum rows for intents, classifiers, responses, prompt templates, and required ce_config flags. Apply conservative defaults for reset behavior, sticky intent, rule phases, MCP safety, and prompt variable exposure. Validate multi turn transitions, reset continuity, missing field loops, and same conversation concurrency behavior. Move from non prod to prod only after all correctness/security/scalability gates pass. Minimum integration checklist Apply src/main/resources/sql/ddl_postgres.sql (legacy: src/main/resources/sql/ddl.sql ). Apply src/main/resources/sql/ddl_oracle.sql . Apply src/main/resources/sql/ddl_sqlite.sql . Recommended baseline config (new consumers) Do not begin with broad MCP usage, many DERIVED intents, and aggressive rule chains together. Start deterministic, then expand one capability at a time. Correctness focused test pack (required) Production readiness gates New intent rollout template (repeatable) 1. Add ce_intent and classifiers for the new intent. 2. Add response mapping ( EXACT first). 3. Add schema + prompt template only if extraction is needed. 4. Add minimal rules with explicit phase and priority. 5. Run scenario tests for this intent (normal, reset, switch, collision, concurrent). 6. Promote with rollback snapshot. Common new consumer mistakes After this page, continue with for table level setup, for all annotation usage, and for implementation roadmap.",
    "rawContent": "# New Consumer Onboarding This is the practical playbook for teams integrating ConvEngine for the first time. Follow this sequence to avoid the common mistakes: wrong data routing, stale intent carry-over, unsafe prompt exposure, and concurrency drift. ## What a new consumer must decide first <DbTable title=\"Day-0 decisions\" columns={[\"Decision\", \"Why it matters\", \"Recommended default\"]} rows={[ [\"Transport\", \"Determines runtime event delivery and operational complexity.\", \"Start with SSE only; enable STOMP relay later.\"], [\"Intent continuity\", \"Controls whether intent re-resolves each turn.\", \"Start with STICKY_INTENT=true , but add explicit switch UX.\"], [\"Response mode\", \"Defines determinism vs model flexibility.\", \"Start with EXACT for critical intents; add DERIVED gradually.\"], [\"Concurrency policy\", \"Prevents same-conversation race corruption.\", \"Serialize by conversationId at API layer from day one.\"], [\"Prompt exposure policy\", \"Controls data leakage and prompt contamination risk.\", \"Use allowlist of prompt vars; do not expose raw input maps.\"], ]} /> ## Step-by-step onboarding <FlowStep step=\"1\" title=\"Bootstrap framework and LLM adapter\"> Enable <MethodRef>@EnableConvEngine</MethodRef>, provide one production-grade <MethodRef>LlmClient</MethodRef> bean with strict timeout and retry policy. </FlowStep> <FlowStep step=\"2\" title=\"Create baseline control-plane data\"> Seed minimum rows for intents, classifiers, responses, prompt templates, and required ce_config flags. </FlowStep> <FlowStep step=\"3\" title=\"Lock down safety defaults\"> Apply conservative defaults for reset behavior, sticky-intent, rule phases, MCP safety, and prompt-variable exposure. </FlowStep> <FlowStep step=\"4\" title=\"Run correctness tests before UI rollout\"> Validate multi-turn transitions, reset continuity, missing-field loops, and same-conversation concurrency behavior. </FlowStep> <FlowStep step=\"5\" title=\"Promote with release gates\"> Move from non-prod to prod only after all correctness/security/scalability gates pass. </FlowStep> ## Minimum integration checklist <DbTable title=\"Must-have implementation tasks\" columns={[\"Area\", \"Task\", \"Done when\"]} rows={[ [\"Spring wiring\", \"Enable ConvEngine + define LlmClient bean.\", \" /message works and returns payload for seeded FAQ intent.\"], [\"Schema\", \"Apply DDL and create indexes from ConvEngine schema.\", \"All ce_* tables present and writable.\"], [\"Seed data\", \"Insert minimal rows for one end-to-end intent.\", \"One deterministic turn passes with expected intent/state.\"], [\"Audit usage\", \"Wire audit API/stream into debugging workflow.\", \"Every test case is verified against trace timeline.\"], [\"Concurrency guard\", \"Prevent parallel writes for same conversation.\", \"Load test shows no state drift under concurrent same-ID requests.\"], [\"Prompt hygiene\", \"Allowlist exposed template vars.\", \"No sensitive/internal keys appear in rendered prompts.\"], ]} /> <Tabs groupId=\"consumer-ddl-dialect\"> <TabItem value=\"postgres\" label=\"Postgres\" default> Apply <FileRef>src/main/resources/sql/ddl_postgres.sql</FileRef> (legacy: <FileRef>src/main/resources/sql/ddl.sql</FileRef>). </TabItem> <TabItem value=\"oracle\" label=\"Oracle\"> Apply <FileRef>src/main/resources/sql/ddl_oracle.sql</FileRef>. </TabItem> <TabItem value=\"sqlite\" label=\"SQLite\"> Apply <FileRef>src/main/resources/sql/ddl_sqlite.sql</FileRef>. </TabItem> </Tabs> ## Recommended baseline config (new consumers) <CodeBlockToggle title=\"Safe starter config (ConvEngine + CCF mappings)\" language=\"yaml\"> { convengine: transport: sse: enabled: true stomp: enabled: false audit: enabled: true level: STANDARD dispatch: async-enabled: false # ConvEngine dynamic table mapping tables: AUDIT: CE_AUDIT CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE VALIDATION_SNAPSHOT: CE_VALIDATION_SNAPSHOT ccf: core: # CCF Core dynamic table mapping tables: PAGE_COMMON_QUERY: ZP_PAGE_COMMON_QUERY SECTION_INFO: ZP_SECTION_INFO CONTAINER_INFO: ZP_CONTAINER_INFO CONTAINER_FIELD_INFO: ZP_CONTAINER_FIELD_INFO CONTAINER_QUERY_INFO: ZP_CONTAINER_QUERY_INFO # In ce_config # IntentResolutionStep.STICKY_INTENT=true # ResetResolvedIntentStep.RESET_INTENT_CODES=RESET_SESSION,START_OVER # AgentIntentResolver.MIN_CONFIDENCE=0.60 } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Do not start with max flexibility\"> Do not begin with broad MCP usage, many DERIVED intents, and aggressive rule chains together. Start deterministic, then expand one capability at a time. </Highlight> ## Correctness-focused test pack (required) <DbTable title=\"Pre-production test scenarios\" columns={[\"Scenario\", \"What to verify\", \"Failure signal\"]} rows={[ [\"Sticky intent shift\", \"New-topic user input triggers expected re-resolution/switch behavior.\", \"Repeated wrong-intent responses with skip stages.\"], [\"Reset semantics\", \"All reset paths clear context/intent/state consistently.\", \"Old fields survive after reset turn.\"], [\"Rule collisions\", \"Only intended rule wins for same turn.\", \"Unexpected multi-pass intent/state mutation.\"], [\"Schema loop\", \"Missing fields converge in bounded turns.\", \"Infinite clarification or inconsistent required field set.\"], [\"Concurrent same ID\", \"No last-write-wins drift under parallel requests.\", \"Contradictory final state for same conversation timeline.\"], [\"Model bad JSON\", \"Invalid model output fails safely and deterministically.\", \"Silent state corruption or unbounded fallback noise.\"], ]} /> ## Production readiness gates <DbTable title=\"Go-live gates\" columns={[\"Gate\", \"Requirement\"]} rows={[ [\"Data correctness\", \"Illegal intent/state transitions are blocked or quarantined.\"], [\"Security\", \"Prompt var allowlist and secret redaction enabled.\"], [\"Concurrency\", \"Same-conversation serialization or optimistic locking in place.\"], [\"Observability\", \"Team can reconstruct one bad turn end-to-end from trace.\"], [\"Scalability\", \"P95 stable under target QPS with production-like config volume.\"], [\"Rollback\", \"Config rollback procedure tested for bad rule/prompt deployment.\"], ]} /> ## New intent rollout template (repeatable) 1. Add ce_intent and classifiers for the new intent. 2. Add response mapping ( EXACT first). 3. Add schema + prompt template only if extraction is needed. 4. Add minimal rules with explicit phase and priority. 5. Run scenario tests for this intent (normal, reset, switch, collision, concurrent). 6. Promote with rollback snapshot. ## Common new-consumer mistakes <DbTable title=\"Avoid these early mistakes\" columns={[\"Mistake\", \"Impact\", \"Fix\"]} rows={[ [\"Using DERIVED everywhere from day one\", \"Higher variance and harder debugging.\", \"Use EXACT for critical flows first.\"], [\"No conversation-level concurrency control\", \"State drift and non-deterministic results.\", \"Serialize by conversation ID or add optimistic locking.\"], [\"Treating prompt vars as free-form\", \"Data leakage and unintended model behavior.\", \"Explicit prompt-var allowlist and validation.\"], [\"Shipping config changes without tests\", \"Production regressions from rule/template misconfig.\", \"Introduce lint + fixture tests + staged promotion.\"], [\"Skipping trace review\", \"Root cause unclear when output is wrong.\", \"Make trace review mandatory in QA signoff.\"], ]} /> <Highlight type=\"info\" title=\"Where to read next\"> After this page, continue with [Configuration](/docs/v2/consumer/configuration) for table-level setup, [Annotations Reference](/docs/v2/consumer/annotations-reference) for all annotation usage, and [Improvement Backlog](/docs/v2/deep-dive/improvement-backlog) for implementation roadmap. </Highlight>",
    "excerpt": "New Consumer Onboarding This is the practical playbook for teams integrating ConvEngine for the first time. Follow this sequence to avoid the common mistakes: wrong data routing, stale intent carry over, unsafe prompt ex…"
  },
  {
    "id": "consumer/session-reset-and-continuity.mdx",
    "version": "v2",
    "title": "session reset and continuity",
    "permalink": "/docs/v2/consumer/session-reset-and-continuity",
    "content": "Session, Reset, and Continuity What is restored per turn From ce_conversation , session restores: intent_code state_code context_json input_params_json From context branch values, session also restores cross turn values such as clarification and intent lock metadata. Intent lock lifecycle Intent lock is used for incomplete schema collection to avoid drift. lock set when required schema fields are still missing intent resolver skip logic respects lock lock removed when schema is complete or schema path is absent Sticky intent lifecycle ( ce_config ) IntentResolutionStep.STICKY_INTENT applies during active incomplete schema collection to keep intent stable while required fields are still missing. when enabled, IntentResolutionStep skips re resolution only while incomplete schema collection is active skip emits audit stage: INTENT_RESOLVE_SKIPPED_STICKY_INTENT re resolution runs once schema collection is complete, and still runs for explicit switch/reset/force signals Force re resolution signals: reset commands: reset , restart , /reset , /restart switch phrases: switch to ... , switch intent , change intent/flow/mode input params: force_intent_resolution=true , resolve_intent=true , switch_intent=true , switch_flow=true , switch_mode=true active clarification flow Reset triggers request body reset=true input params reset , restart , conversation_reset text commands reset , restart , /reset , /restart intent based reset via ResetResolvedIntentStep ( ce_config ) Practical advice Keep reset intent names explicit and reserved ( RESET_SESSION style) Avoid mixing business intents with reset intents Audit CONVERSATION_RESET stages in pre production tests If reset logic is custom coded only in controller, multi turn state may still leak from existing conversation context. Use pipeline reset steps, not ad hoc request branching.",
    "rawContent": "# Session, Reset, and Continuity ## What is restored per turn From ce_conversation , session restores: - intent_code - state_code - context_json - input_params_json From context branch values, session also restores cross-turn values such as clarification and intent lock metadata. ## Intent lock lifecycle Intent lock is used for incomplete schema collection to avoid drift. - lock set when required schema fields are still missing - intent resolver skip logic respects lock - lock removed when schema is complete or schema path is absent ## Sticky intent lifecycle ( ce_config ) IntentResolutionStep.STICKY_INTENT applies during active incomplete schema collection to keep intent stable while required fields are still missing. - when enabled, IntentResolutionStep skips re-resolution only while incomplete schema collection is active - skip emits audit stage: INTENT_RESOLVE_SKIPPED_STICKY_INTENT - re-resolution runs once schema collection is complete, and still runs for explicit switch/reset/force signals <CodeBlockToggle title=\"Sticky intent config\" language=\"sql\"> { INSERT INTO ce_config (config_type, config_key, config_value, enabled) VALUES ('IntentResolutionStep', 'STICKY_INTENT', 'true', true); } </CodeBlockToggle> Force re-resolution signals: - reset commands: reset , restart , /reset , /restart - switch phrases: switch to ... , switch intent , change intent/flow/mode - input params: force_intent_resolution=true , resolve_intent=true , switch_intent=true , switch_flow=true , switch_mode=true - active clarification flow ## Reset triggers - request body reset=true - input params reset , restart , conversation_reset - text commands reset , restart , /reset , /restart - intent-based reset via ResetResolvedIntentStep ( ce_config ) <CodeBlockToggle title=\"Reset intent config\" language=\"sql\"> { INSERT INTO ce_config (config_type, config_key, config_value, enabled) VALUES ('ResetResolvedIntentStep', 'RESET_INTENT_CODES', 'RESET_SESSION,START_OVER', true); } </CodeBlockToggle> ## Practical advice - Keep reset intent names explicit and reserved ( RESET_SESSION style) - Avoid mixing business intents with reset intents - Audit CONVERSATION_RESET stages in pre-production tests <Highlight type=\"warning\" title=\"Common failure mode\"> If reset logic is custom-coded only in controller, multi-turn state may still leak from existing conversation context. Use pipeline reset steps, not ad-hoc request branching. </Highlight>",
    "excerpt": "Session, Reset, and Continuity What is restored per turn From ce_conversation , session restores: intent_code state_code context_json input_params_json From context branch values, session also restores cross turn values …"
  },
  {
    "id": "consumer/ui-integration.mdx",
    "version": "v2",
    "title": "ui integration",
    "permalink": "/docs/v2/consumer/ui-integration",
    "content": "UI Integration This page shows end to end UI wiring with: React (Vite) in JS + TS Angular (standalone) in TS SSE now + STOMP commented for later switch POST to /api/v1/conversation/message using conversationId and message . Use EventSource on /api/v1/conversation/stream/ '} . On each stream event, refresh /audit/ '} or trace endpoint. React Vite (JavaScript) , body: JSON.stringify( ), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const res = await fetch(API_BASE + \"/audit/\" + conversationId); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () = handlers.onConnected?.(); source.onerror = (error) = handlers.onError?.(error); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) = catch handlers.onEvent?.( ); }); }); return }; } // STOMP scaffold (optional) // npm install @stomp/stompjs sockjs client // import from \"@stomp/stompjs\"; // import SockJS from \"sockjs client\"; // export function subscribeConversationStomp(conversationId, handlers = ) // catch // }); // }, // onStompError: (frame) = handlers.onError?.(frame), // }); // client.activate(); // return }; // } } from \"react\"; const [conversationId] = useState(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState(0); useEffect(() = ); // STOMP alternate: // const stream = subscribeConversationStomp(conversationId, ); return () = stream.close(); }, [conversationId]); return conversationId= auditVersion= ; } } React Vite (TypeScript) onConnected?: () = void; onEvent?: (event: StreamEvent ) = void; onError?: (event: Event) = void; onClosed?: () = void; } conversationId: string, message: string, inputParams: Record = , reset = false ) , body: JSON.stringify( ), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } conversationId: string, handlers: StreamHandlers = ) catch handlers.onEvent?.( ); }); }); return }; } } from \"react\"; const [conversationId] = useState (crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState (0); useEffect(() = , }); return () = stream.close(); }, [conversationId]); return auditVersion= ; } } Angular Integration (authored sample) from '@angular/core'; stage: string; data: T | null; raw: MessageEvent; } @Injectable( ) private readonly apiBase = 'http://localhost:8080/api/v1/conversation'; constructor(private readonly http: HttpClient) sendMessage(payload: ): Observable fetchAudits(conversationId: string): Observable subscribeConversationSse( conversationId: string, handlers: = ) catch handlers.onEvent?.( ); }); }); return }; } // STOMP scaffold (optional) // npm i @stomp/stompjs sockjs client // connect ws://localhost:8080/ws convengine // subscribe /topic/convengine/audit/ } } from '@angular/core'; @Component( ) conversationId = crypto.randomUUID(); message = ''; messages: Array = []; typing = false; private streamCloser: | null = null; constructor(private readonly api: ConvengineApiService) ngOnInit(): void }); } send(): void ); this.message = ''; this.typing = true; this.api.sendMessage( ).subscribe( ); this.typing = false; }, error: () = }); } ngOnDestroy(): void } } } Agent is typing... Send } Keep one shared backend contract for conversationId , payload.type , and audit stage names. Only transport/client wrappers should differ per framework.",
    "rawContent": "# UI Integration This page shows end-to-end UI wiring with: - React (Vite) in JS + TS - Angular (standalone) in TS - SSE now + STOMP commented for later switch <FlowStep step=\"1\" title=\"Call message API\"> POST to <FileRef>/api/v1/conversation/message</FileRef> using <MethodRef>conversationId</MethodRef> and <MethodRef>message</MethodRef>. </FlowStep> <FlowStep step=\"2\" title=\"Subscribe to stream\"> Use <MethodRef>EventSource</MethodRef> on <FileRef>/api/v1/conversation/stream/{'{conversationId}'}</FileRef>. </FlowStep> <FlowStep step=\"3\" title=\"Refresh timeline\"> On each stream event, refresh <FileRef>/audit/{'{conversationId}'}</FileRef> or trace endpoint. </FlowStep> ## React Vite (JavaScript) <CodeBlockToggle title=\"convengine.api.js\" language=\"js\" packagePath=\"src/api\" filePath=\"src/api/convengine.api.js\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; const res = await fetch(API_BASE + \"/message\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ conversationId, message, reset, inputParams }), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const res = await fetch(API_BASE + \"/audit/\" + conversationId); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (error) => handlers.onError?.(error); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data = null; try { data = event.data ? JSON.parse(event.data) : null; } catch {} handlers.onEvent?.({ stage, data, raw: event }); }); }); return { close() { source.close(); handlers.onClosed?.(); } }; } // STOMP scaffold (optional) // npm install @stomp/stompjs sockjs-client // import { Client } from \"@stomp/stompjs\"; // import SockJS from \"sockjs-client\"; // export function subscribeConversationStomp(conversationId, handlers = {}) { // const client = new Client({ // webSocketFactory: () => new SockJS(\"http://localhost:8080/ws-convengine\"), // reconnectDelay: 5000, // onConnect: () => { // handlers.onConnected?.(); // client.subscribe(\"/topic/convengine/audit/\" + conversationId, (msg) => { // try { handlers.onEvent?.(JSON.parse(msg.body)); } // catch { handlers.onEvent?.(msg.body); } // }); // }, // onStompError: (frame) => handlers.onError?.(frame), // }); // client.activate(); // return { close() { client.deactivate(); handlers.onClosed?.(); } }; // } } </CodeBlockToggle> <CodeBlockToggle title=\"App.jsx\" language=\"jsx\" packagePath=\"src\" filePath=\"src/App.jsx\" > { import { useEffect, useState } from \"react\"; const [conversationId] = useState(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState(0); useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion((v) => v + 1), onEvent: () => setAuditVersion((v) => v + 1), }); // STOMP alternate: // const stream = subscribeConversationStomp(conversationId, { ... }); return () => stream.close(); }, [conversationId]); return <div>conversationId={conversationId} auditVersion={auditVersion}</div>; } } </CodeBlockToggle> ## React Vite (TypeScript) <CodeBlockToggle title=\"convengine.api.ts\" language=\"ts\" packagePath=\"src/api\" filePath=\"src/api/convengine.api.ts\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; | \"CONNECTED\" | \"USER_INPUT\" | \"STEP_ENTER\" | \"STEP_EXIT\" | \"STEP_ERROR\" | \"ASSISTANT_OUTPUT\" | \"ENGINE_RETURN\" | \"MESSAGE\"; stage: SseStage; data: T | null; raw: MessageEvent; } onConnected?: () => void; onEvent?: (event: StreamEvent<T>) => void; onError?: (event: Event) => void; onClosed?: () => void; } conversationId: string, message: string, inputParams: Record<string, unknown> = {}, reset = false ) { const res = await fetch(API_BASE + \"/message\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ conversationId, message, inputParams, reset }), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } conversationId: string, handlers: StreamHandlers<T> = {} ) { const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (event) => handlers.onError?.(event); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data: T | null = null; try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) as T : null; } catch { data = null; } handlers.onEvent?.({ stage: stage as SseStage, data, raw: event as MessageEvent }); }); }); return { close() { source.close(); handlers.onClosed?.(); } }; } } </CodeBlockToggle> <CodeBlockToggle title=\"App.tsx\" language=\"tsx\" packagePath=\"src\" filePath=\"src/App.tsx\" > { import { useEffect, useState } from \"react\"; const [conversationId] = useState<string>(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState<number>(0); useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion((v) => v + 1), onEvent: () => setAuditVersion((v) => v + 1), onError: () => {}, }); return () => stream.close(); }, [conversationId]); return <main>auditVersion={auditVersion}</main>; } } </CodeBlockToggle> ## Angular Integration (authored sample) <CodeBlockToggle title=\"convengine-api.service.ts\" language=\"ts\" packagePath=\"src/app/core\" filePath=\"src/app/core/convengine-api.service.ts\" > { import { Injectable } from '@angular/core'; stage: string; data: T | null; raw: MessageEvent; } @Injectable({ providedIn: 'root' }) private readonly apiBase = 'http://localhost:8080/api/v1/conversation'; constructor(private readonly http: HttpClient) {} sendMessage(payload: { conversationId: string; message: string; reset?: boolean; inputParams?: Record<string, unknown>; }): Observable<any> { return this.http.post(this.apiBase + '/message', payload); } fetchAudits(conversationId: string): Observable<any[]> { return this.http.get<any[]>(this.apiBase + '/audit/' + conversationId); } subscribeConversationSse( conversationId: string, handlers: { onConnected?: () => void; onEvent?: (event: ConversationEvent) => void; onError?: (event: Event) => void; onClosed?: () => void; } = {} ) { const source = new EventSource(this.apiBase + '/stream/' + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (event) => handlers.onError?.(event); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data: unknown = null; try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) : null; } catch { data = null; } handlers.onEvent?.({ stage, data, raw: event as MessageEvent }); }); }); return { close: () => { source.close(); handlers.onClosed?.(); } }; } // STOMP scaffold (optional) // npm i @stomp/stompjs sockjs-client // connect ws://localhost:8080/ws-convengine // subscribe /topic/convengine/audit/{conversationId} } } </CodeBlockToggle> <CodeBlockToggle title=\"chat.component.ts\" language=\"ts\" packagePath=\"src/app/features/chat\" filePath=\"src/app/features/chat/chat.component.ts\" > { import { Component, OnDestroy, OnInit } from '@angular/core'; @Component({ standalone: true, selector: 'app-chat', imports: [CommonModule, FormsModule], templateUrl: './chat.component.html' }) conversationId = crypto.randomUUID(); message = ''; messages: Array<{ role: 'user' | 'assistant'; text: string }> = []; typing = false; private streamCloser: { close: () => void } | null = null; constructor(private readonly api: ConvengineApiService) {} ngOnInit(): void { this.streamCloser = this.api.subscribeConversationSse(this.conversationId, { onEvent: () => { // optionally refresh audit panel } }); } send(): void { const text = this.message.trim(); if (!text || this.typing) return; this.messages.push({ role: 'user', text }); this.message = ''; this.typing = true; this.api.sendMessage({ conversationId: this.conversationId, message: text }).subscribe({ next: (res) => { const value = res?.payload?.value ?? ''; this.messages.push({ role: 'assistant', text: String(value) }); this.typing = false; }, error: () => { this.typing = false; } }); } ngOnDestroy(): void { this.streamCloser?.close(); } } } </CodeBlockToggle> <CodeBlockToggle title=\"chat.component.html\" language=\"html\" packagePath=\"src/app/features/chat\" filePath=\"src/app/features/chat/chat.component.html\" > { <section class=\"chat-shell\"> <div class=\"messages\"> <div *ngFor=\"let m of messages\" [class.user]=\"m.role === 'user'\" [class.assistant]=\"m.role === 'assistant'\"> {{ m.text }} </div> <div *ngIf=\"typing\" class=\"assistant typing\">Agent is typing...</div> </div> <div class=\"composer\"> <input [(ngModel)]=\"message\" placeholder=\"Type message\" /> <button (click)=\"send()\" [disabled]=\"typing\">Send</button> </div> </section> } </CodeBlockToggle> <Highlight type=\"tip\" title=\"React + Angular parity\"> Keep one shared backend contract for <MethodRef>conversationId</MethodRef>, <MethodRef>payload.type</MethodRef>, and audit stage names. Only transport/client wrappers should differ per framework. </Highlight>",
    "excerpt": "UI Integration This page shows end to end UI wiring with: React (Vite) in JS + TS Angular (standalone) in TS SSE now + STOMP commented for later switch POST to /api/v1/conversation/message using conversationId and messag…"
  },
  {
    "id": "deep-dive/data-model.mdx",
    "version": "v2",
    "title": "data model",
    "permalink": "/docs/v2/deep-dive/data-model",
    "content": "Data Model (v2) Control plane tables ce_config ce_container_config ce_intent ce_intent_classifier ce_output_schema ce_prompt_template ce_response ce_rule ce_policy ce_mcp_tool ce_mcp_db_tool ce_pending_action (new in v2) Runtime tables ce_conversation ce_audit ce_conversation_history ce_llm_call_log ce_validation_snapshot ce_pending_action (v2) Purpose: declarative catalog for executable pending actions by intent/state/action key Key columns: pending_action_id intent_code state_code action_key bean_name method_names priority enabled description created_at Lookup index: (enabled, action_key, intent_code, state_code, priority) Important: runtime status ( OPEN/IN_PROGRESS/EXECUTED/REJECTED/EXPIRED ) is not stored in this table runtime status is stored in context.pending_action_runtime Rule phase compatibility ce_rule.phase includes v2 phases: PIPELINE_RULES AGENT_POST_INTENT MCP_POST_LLM TOOL_POST_EXECUTION Tool group compatibility ce_mcp_tool.tool_group normalizes to: DB HTTP_API WORKFLOW_ACTION DOCUMENT_RETRIEVAL CALCULATOR_TRANSFORM NOTIFICATION FILES MCP tool scope columns ce_mcp_tool also supports optional scope columns: intent_code (nullable) state_code (nullable) Behavior: if both are NULL , the tool is globally eligible if set, tool eligibility is constrained to matching runtime session.intent and session.state non matching scoped tools are skipped from MCP planning/execution",
    "rawContent": "# Data Model (v2) ## Control-plane tables - ce_config - ce_container_config - ce_intent - ce_intent_classifier - ce_output_schema - ce_prompt_template - ce_response - ce_rule - ce_policy - ce_mcp_tool - ce_mcp_db_tool - ce_pending_action (new in v2) ## Runtime tables - ce_conversation - ce_audit - ce_conversation_history - ce_llm_call_log - ce_validation_snapshot ## ce_pending_action (v2) Purpose: - declarative catalog for executable pending actions by intent/state/action key Key columns: - pending_action_id - intent_code - state_code - action_key - bean_name - method_names - priority - enabled - description - created_at Lookup index: - (enabled, action_key, intent_code, state_code, priority) Important: - runtime status ( OPEN/IN_PROGRESS/EXECUTED/REJECTED/EXPIRED ) is not stored in this table - runtime status is stored in context.pending_action_runtime ## Rule phase compatibility ce_rule.phase includes v2 phases: - PIPELINE_RULES - AGENT_POST_INTENT - MCP_POST_LLM - TOOL_POST_EXECUTION ## Tool-group compatibility ce_mcp_tool.tool_group normalizes to: - DB - HTTP_API - WORKFLOW_ACTION - DOCUMENT_RETRIEVAL - CALCULATOR_TRANSFORM - NOTIFICATION - FILES ## MCP tool scope columns ce_mcp_tool also supports optional scope columns: - intent_code (nullable) - state_code (nullable) Behavior: - if both are NULL , the tool is globally eligible - if set, tool eligibility is constrained to matching runtime session.intent and session.state - non-matching scoped tools are skipped from MCP planning/execution",
    "excerpt": "Data Model (v2) Control plane tables ce_config ce_container_config ce_intent ce_intent_classifier ce_output_schema ce_prompt_template ce_response ce_rule ce_policy ce_mcp_tool ce_mcp_db_tool ce_pending_action (new in v2)…"
  },
  {
    "id": "deep-dive/developer-guide.mdx",
    "version": "v2",
    "title": "developer guide",
    "permalink": "/docs/v2/deep-dive/developer-guide",
    "content": "Developer Guide (v2) Build order for a new flow 1. define intent/state and response rows 2. define schema row (if slot collection needed) 3. define rule transitions by phase 4. define pending actions in ce_pending_action for confirmation flows 5. configure convengine.flow. 6. add tool rows and adapters if external execution is needed 7. replay test with expected intent/state assertions convengine.flow. checklist dialogue act. interaction policy. action lifecycle. disambiguation. guardrail. state graph. tool orchestration. memory. Extension points CeTask / CeTaskExecutor McpToolExecutor and adapter interfaces ConversationMemoryStore EngineStepHook custom rule type/action resolvers Operational safety checklist configure fallback response rows for UNKNOWN / ANY do not depend on one rule only; use phase specific rules verify pending action catalog priorities to avoid ambiguous execution enable state graph validation before promoting to production monitor audit for guardrail and disambiguation stages Regression strategy Use ConversationReplayService to replay scripted turns and assert expected intent/state at each turn.",
    "rawContent": "# Developer Guide (v2) ## Build order for a new flow 1. define intent/state and response rows 2. define schema row (if slot collection needed) 3. define rule transitions by phase 4. define pending actions in ce_pending_action for confirmation flows 5. configure convengine.flow.* 6. add tool rows and adapters if external execution is needed 7. replay test with expected intent/state assertions ## convengine.flow.* checklist - dialogue-act.* - interaction-policy.* - action-lifecycle.* - disambiguation.* - guardrail.* - state-graph.* - tool-orchestration.* - memory.* ## Extension points - CeTask / CeTaskExecutor - McpToolExecutor and adapter interfaces - ConversationMemoryStore - EngineStepHook - custom rule type/action resolvers ## Operational safety checklist - configure fallback response rows for UNKNOWN / ANY - do not depend on one rule only; use phase-specific rules - verify pending-action catalog priorities to avoid ambiguous execution - enable state-graph validation before promoting to production - monitor audit for guardrail and disambiguation stages ## Regression strategy Use ConversationReplayService to replay scripted turns and assert expected intent/state at each turn.",
    "excerpt": "Developer Guide (v2) Build order for a new flow 1. define intent/state and response rows 2. define schema row (if slot collection needed) 3. define rule transitions by phase 4. define pending actions in ce_pending_action…"
  },
  {
    "id": "deep-dive/examples.mdx",
    "version": "v2",
    "title": "examples",
    "permalink": "/docs/v2/deep-dive/examples",
    "content": "Real World Examples This page is intentionally dense. Each flow is shown as: 1. Chat transcript 2. Per turn step trace (what executed and why) 3. Required control plane rows ( ce_ ) 4. Audit timeline with payload level checkpoints Example 1: FAQ (informational path) How do I transfer my electricity connection? Share customerId, phone, email, source city, and target city. Then confirm to submit transfer. InteractionPolicyStep sees no pending_action signal and does not produce EXECUTE_PENDING_ACTION . The turn continues as a regular intent resolution flow. }\\\\nFAQ context: }\\\\nReturn short helpful answer.', 0.10, true); INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'DERIVED', 'Answer FAQ using available context and user question.', 10, true); } , \"userText\": \"How do I transfer my electricity connection?\", \"dialogueAct\": \"QUESTION\", \"dialogueActConfidence\": 0.70, \"dialogueActSource\": \"REGEX\" } } , \"dialogueAct\": \"QUESTION\", \"policyDecision\": \"RECLASSIFY_INTENT\", \"skipIntentResolution\": false, \"hasPendingAction\": false, \"hasPendingSlot\": false } } Example 2: CONNECTION_TRANSFER (multi turn + confirmation + pending action) Move my electricity connection from City1 to City2. Please provide customerId, phone, email, sourceCity, and targetCity. customerId 9912, phone 9988776655, email user@zapper.com, sourceCity City1, targetCity City2 Do you want to move this connection right away? yes please Connection transfer request submitted successfully. COLLECT_INPUTS\", \"Bootstrap collection state\"], [\"ResponseResolutionStep\", \"ask for required fields\", \"Prompt user for missing slots\"], ]} / AWAITING_CONFIRMATION\", \"User must confirm execution\"], [\"ResponseResolutionStep\", \"confirmation prompt\", \"\"], ]} / IN_PROGRESS\", \"Runtime status tracked in context\"], [\"4\", \"DisambiguationStep\", \"not required\", \"Single eligible action\"], [\"5\", \"GuardrailStep\", \"ALLOW\", \"No sensitive/approval block\"], [\"6\", \"PendingActionStep\", \"EXECUTED\", \"Task bean/method invoked from ce_pending_action\"], [\"7\", \"RulesStep\", \"AWAITING_CONFIRMATION COMPLETED\", \"Final state transition\"], [\"8\", \"ResponseResolutionStep\", \"success response\", \"User receives completion\"], ]} / , \"policyDecision\": \"EXECUTE_PENDING_ACTION\", \"pendingActionRef\": \"faqRuleTask:injectContainerData\", \"pendingActionResult\": \"EXECUTED\", \"intent\": \"CONNECTION_TRANSFER\", \"state\": \"AWAITING_CONFIRMATION\" } } , \"rulePhase\": \"PIPELINE_RULES\", \"intent\": \"CONNECTION_TRANSFER\", \"ruleStateCode\": \"AWAITING_CONFIRMATION\", \"action\": \"SET_STATE\", \"actionValue\": \"COMPLETED\" } } If user says \"yes\" but flow loops back to confirmation, check in order: 1) DIALOGUE_ACT_CLASSIFIED must be AFFIRM 2) INTERACTION_POLICY_DECIDED must be EXECUTE_PENDING_ACTION 3) PENDING_ACTION_EXECUTED must exist 4) RULE_APPLIED must transition state from AWAITING_CONFIRMATION to terminal state.",
    "rawContent": "# Real World Examples This page is intentionally dense. Each flow is shown as: 1. Chat transcript 2. Per-turn step trace (what executed and why) 3. Required control-plane rows ( ce_* ) 4. Audit timeline with payload-level checkpoints ## Example 1: FAQ (informational path) <Tabs groupId=\"v2-faq-deep\"> <TabItem value=\"chat\" label=\"Chat Transcript\" default> <Conversation title=\"FAQ conversation\"> <User>How do I transfer my electricity connection?</User> <Assistant>Share customerId, phone, email, source city, and target city. Then confirm to submit transfer.</Assistant> </Conversation> <DbTable title=\"Intent and state outcome\" columns={[\"Field\", \"Expected value\", \"Why\"]} rows={[ [\"intent\", \"FAQ\", \"Classifier matches informational query language\"], [\"state\", \"IDLE\", \"No slot collection / no pending action required\"], [\"responseType\", \"DERIVED (TEXT)\", \"FAQ answer generated from prompt/context\"], ]} /> </TabItem> <TabItem value=\"trace\" label=\"Per-turn Step Trace\"> <DbTable title=\"Turn T1 runtime trace\" columns={[\"Order\", \"Step\", \"Input facts\", \"Output facts\"]} rows={[ [\"1\", \"LoadOrCreateConversationStep\", \"conversationId present or new\", \"session opened/hydrated\"], [\"2\", \"AuditUserInputStep\", \"raw user text\", \"USER_INPUT audit row\"], [\"3\", \"DialogueActStep\", \"question sentence\", \"dialogue_act=QUESTION\"], [\"4\", \"InteractionPolicyStep\", \"no pending_action, no pending_slot\", \"policy_decision=RECLASSIFY_INTENT\"], [\"5\", \"IntentResolutionStep\", \"classifiers + agent hints\", \"intent=FAQ, state=IDLE\"], [\"6\", \"SchemaExtractionStep\", \"FAQ schema (light)\", \"schema facts available\"], [\"7\", \"RulesStep\", \"no FAQ rule action\", \"RULE_NO_MATCH or no mutation\"], [\"8\", \"ResponseResolutionStep\", \"FAQ response row + prompt\", \"assistant output prepared\"], [\"9\", \"MemoryStep\", \"recent turn context\", \"memory_session_summary\"], [\"10\", \"PersistConversationStep\", \"final session\", \"conversation/audit persisted\"], ]} /> <Highlight type=\"info\" title=\"Why no pending-action path here\"> InteractionPolicyStep sees no pending_action signal and does not produce EXECUTE_PENDING_ACTION . The turn continues as a regular intent-resolution flow. </Highlight> </TabItem> <TabItem value=\"db\" label=\"Required ce_* Rows\"> <DbTable title=\"Minimum rows required for FAQ flow\" columns={[\"Table\", \"Required row shape\", \"Used by\"]} rows={[ [\"ce_intent\", \"intent_code=FAQ\", \"IntentResolutionStep\"], [\"ce_intent_classifier\", \"intent_code=FAQ, rule_type=REGEX\", \"IntentResolutionStep\"], [\"ce_prompt_template\", \"intent_code=FAQ, response_type=TEXT\", \"ResponseResolutionStep (DERIVED)\"], [\"ce_response\", \"intent_code=FAQ, state_code=IDLE\", \"ResponseResolutionStep\"], [\"ce_container_config\", \"intent_code=FAQ (optional context source)\", \"AddContainerDataStep\"], [\"ce_config\", \"AgentIntentResolver + SchemaExtractionStep prompt keys\", \"Intent/Schema steps\"], ]} /> <CodeBlockToggle title=\"FAQ seed snippet\" language=\"sql\"> { INSERT INTO ce_intent (intent_code, description, priority, enabled) VALUES ('FAQ', 'Answer informational questions from FAQ knowledge base', 10, true); INSERT INTO ce_intent_classifier (intent_code, rule_type, pattern, priority, enabled) VALUES ('FAQ', 'REGEX', '(?i)\\\\b(what|how|help|faq|information|details|explain)\\\\b', 10, true); INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, temperature, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'You are a concise FAQ assistant. Answer directly and clearly.', 'User question: {{user_input}}\\\\nFAQ context: {{container_data}}\\\\nReturn short helpful answer.', 0.10, true); INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'DERIVED', 'Answer FAQ using available context and user question.', 10, true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit + Payload Postmortem\"> <DbTable title=\"Expected audit stages (ordered)\" columns={[\"Order\", \"Stage\", \"Must contain\"]} rows={[ [\"1\", \"USER_INPUT\", \"original user message\"], [\"2\", \"DIALOGUE_ACT_CLASSIFIED\", \"dialogueAct=QUESTION\"], [\"3\", \"INTERACTION_POLICY_DECIDED\", \"policyDecision=RECLASSIFY_INTENT\"], [\"4\", \"INTENT_RESOLVED_BY_*\", \"intent=FAQ\"], [\"5\", \"RESOLVE_RESPONSE_SELECTED\", \"responseType=DERIVED\"], [\"6\", \"ASSISTANT_OUTPUT\", \"output text or json payload\"], [\"7\", \"MEMORY_UPDATED\", \"summaryChars/recalled flags\"], ]} /> <CodeBlockToggle title=\"Audit payload checkpoint: DIALOGUE_ACT_CLASSIFIED\" language=\"json\"> { { \"_meta\": { \"stage\": \"DIALOGUE_ACT_CLASSIFIED\" }, \"userText\": \"How do I transfer my electricity connection?\", \"dialogueAct\": \"QUESTION\", \"dialogueActConfidence\": 0.70, \"dialogueActSource\": \"REGEX\" } } </CodeBlockToggle> <CodeBlockToggle title=\"Audit payload checkpoint: INTERACTION_POLICY_DECIDED\" language=\"json\"> { { \"_meta\": { \"stage\": \"INTERACTION_POLICY_DECIDED\" }, \"dialogueAct\": \"QUESTION\", \"policyDecision\": \"RECLASSIFY_INTENT\", \"skipIntentResolution\": false, \"hasPendingAction\": false, \"hasPendingSlot\": false } } </CodeBlockToggle> </TabItem> </Tabs> ## Example 2: CONNECTION_TRANSFER (multi-turn + confirmation + pending action) <Tabs groupId=\"v2-transfer-deep\"> <TabItem value=\"chat\" label=\"Chat Transcript\" default> <Conversation title=\"Connection transfer conversation\"> <User>Move my electricity connection from City1 to City2.</User> <Assistant>Please provide customerId, phone, email, sourceCity, and targetCity.</Assistant> <User>customerId 9912, phone 9988776655, email user@zapper.com, sourceCity City1, targetCity City2</User> <Assistant>Do you want to move this connection right away?</Assistant> <User>yes please</User> <Assistant>Connection transfer request submitted successfully.</Assistant> </Conversation> </TabItem> <TabItem value=\"trace\" label=\"Per-turn Step Trace\"> <DbTable title=\"Turn T1 (initial request)\" columns={[\"Step\", \"Key output\", \"Notes\"]} rows={[ [\"IntentResolutionStep\", \"intent=CONNECTION_TRANSFER\", \"Classifier picks transfer intent\"], [\"SchemaExtractionStep\", \"missing fields computed\", \"Required slots are incomplete\"], [\"RulesStep\", \"state -> COLLECT_INPUTS\", \"Bootstrap collection state\"], [\"ResponseResolutionStep\", \"ask for required fields\", \"Prompt user for missing slots\"], ]} /> <DbTable title=\"Turn T2 (slot fill)\" columns={[\"Step\", \"Key output\", \"Notes\"]} rows={[ [\"SchemaExtractionStep\", \"customerId/phone/email/sourceCity/targetCity extracted\", \"Schema complete\"], [\"RulesStep\", \"COLLECT_INPUTS -> AWAITING_CONFIRMATION\", \"User must confirm execution\"], [\"ResponseResolutionStep\", \"confirmation prompt\", \"\"], ]} /> <DbTable title=\"Turn T3 (affirm)\" columns={[\"Order\", \"Step\", \"Key output\", \"Why it matters\"]} rows={[ [\"1\", \"DialogueActStep\", \"AFFIRM\", \"Converts 'yes please' into execution signal\"], [\"2\", \"InteractionPolicyStep\", \"EXECUTE_PENDING_ACTION\", \"Policy routes to pending action\"], [\"3\", \"ActionLifecycleStep\", \"OPEN -> IN_PROGRESS\", \"Runtime status tracked in context\"], [\"4\", \"DisambiguationStep\", \"not required\", \"Single eligible action\"], [\"5\", \"GuardrailStep\", \"ALLOW\", \"No sensitive/approval block\"], [\"6\", \"PendingActionStep\", \"EXECUTED\", \"Task bean/method invoked from ce_pending_action\"], [\"7\", \"RulesStep\", \"AWAITING_CONFIRMATION -> COMPLETED\", \"Final state transition\"], [\"8\", \"ResponseResolutionStep\", \"success response\", \"User receives completion\"], ]} /> </TabItem> <TabItem value=\"db\" label=\"Required ce_* Rows\"> <DbTable title=\"Control-plane requirements\" columns={[\"Table\", \"Must have\", \"Consumed by\"]} rows={[ [\"ce_intent\", \"CONNECTION_TRANSFER\", \"IntentResolutionStep\"], [\"ce_intent_classifier\", \"transfer/move regex\", \"IntentResolutionStep\"], [\"ce_output_schema\", \"required slots for transfer\", \"SchemaExtractionStep\"], [\"ce_rule\", \"state bootstrap + completeness + completion rules\", \"RulesStep\"], [\"ce_pending_action\", \"action_key + bean_name + method_names\", \"ActionLifecycleStep/PendingActionStep\"], [\"ce_response\", \"COLLECT_INPUTS, AWAITING_CONFIRMATION, COMPLETED responses\", \"ResponseResolutionStep\"], [\"ce_config\", \"dialogue/prompt keys\", \"DialogueActStep/Schema steps\"], [\"ce_policy\", \"optional policy blocks\", \"PolicyEnforcementStep\"], ]} /> <CodeBlockToggle title=\"Seed snippet: pending action + rules\" language=\"sql\"> { INSERT INTO ce_pending_action (intent_code, state_code, action_key, bean_name, method_names, priority, enabled, description) VALUES ('CONNECTION_TRANSFER', 'AWAITING_CONFIRMATION', 'FINALIZE_CONNECTION_TRANSFER', 'faqRuleTask', 'injectContainerData', 1, true, 'Demo finalize action for connection transfer'); INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled) VALUES ('PIPELINE_RULES', 'CONNECTION_TRANSFER', 'IDLE', 'REGEX', '.*', 'SET_STATE', 'COLLECT_INPUTS', 10, true), ('PIPELINE_RULES', 'CONNECTION_TRANSFER', 'COLLECT_INPUTS', 'JSON_PATH', '$[?(@.state == ''COLLECT_INPUTS'' && @.customerId && @.phone && @.email && @.sourceCity && @.targetCity)]', 'SET_STATE', 'AWAITING_CONFIRMATION', 100, true), ('PIPELINE_RULES', 'CONNECTION_TRANSFER', 'AWAITING_CONFIRMATION', 'JSON_PATH', '$[?(@.state == ''AWAITING_CONFIRMATION'' && (@.pending_action_result == ''EXECUTED'' || @.inputParams.pending_action_result == ''EXECUTED''))]', 'SET_STATE', 'COMPLETED', 200, true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit + Payload Postmortem\"> <DbTable title=\"Confirmation turn audit chain (must appear in order)\" columns={[\"Order\", \"Stage\", \"Payload keys to verify\"]} rows={[ [\"1\", \"DIALOGUE_ACT_CLASSIFIED\", \"dialogueAct=AFFIRM, confidence, source\"], [\"2\", \"INTERACTION_POLICY_DECIDED\", \"policyDecision=EXECUTE_PENDING_ACTION\"], [\"3\", \"PENDING_ACTION_LIFECYCLE\", \"status=IN_PROGRESS\"], [\"4\", \"GUARDRAIL_ALLOW\", \"result=ALLOW\"], [\"5\", \"PENDING_ACTION_EXECUTED\", \"pendingActionResult=EXECUTED\"], [\"6\", \"RULE_APPLIED\", \"state transition to COMPLETED\"], [\"7\", \"ASSISTANT_OUTPUT\", \"final completion response\"], [\"8\", \"MEMORY_UPDATED\", \"summary updated\"], ]} /> <CodeBlockToggle title=\"Audit payload checkpoint: PENDING_ACTION_EXECUTED\" language=\"json\"> { { \"_meta\": { \"stage\": \"PENDING_ACTION_EXECUTED\" }, \"policyDecision\": \"EXECUTE_PENDING_ACTION\", \"pendingActionRef\": \"faqRuleTask:injectContainerData\", \"pendingActionResult\": \"EXECUTED\", \"intent\": \"CONNECTION_TRANSFER\", \"state\": \"AWAITING_CONFIRMATION\" } } </CodeBlockToggle> <CodeBlockToggle title=\"Audit payload checkpoint: RULE_APPLIED after execution\" language=\"json\"> { { \"_meta\": { \"stage\": \"RULE_APPLIED\" }, \"rulePhase\": \"PIPELINE_RULES\", \"intent\": \"CONNECTION_TRANSFER\", \"ruleStateCode\": \"AWAITING_CONFIRMATION\", \"action\": \"SET_STATE\", \"actionValue\": \"COMPLETED\" } } </CodeBlockToggle> <Highlight type=\"success\" title=\"Fast failure triage\"> If user says \"yes\" but flow loops back to confirmation, check in order: 1) DIALOGUE_ACT_CLASSIFIED must be AFFIRM 2) INTERACTION_POLICY_DECIDED must be EXECUTE_PENDING_ACTION 3) PENDING_ACTION_EXECUTED must exist 4) RULE_APPLIED must transition state from AWAITING_CONFIRMATION to terminal state. </Highlight> </TabItem> </Tabs>",
    "excerpt": "Real World Examples This page is intentionally dense. Each flow is shown as: 1. Chat transcript 2. Per turn step trace (what executed and why) 3. Required control plane rows ( ce_ ) 4. Audit timeline with payload level c…"
  },
  {
    "id": "deep-dive/failure-gotchas.mdx",
    "version": "v2",
    "title": "failure gotchas",
    "permalink": "/docs/v2/deep-dive/failure-gotchas",
    "content": "Data Correctness Gotchas This page documents where ConvEngine can produce incorrect, stale, or misleading output without necessarily crashing. It also lists framework constraints and a concrete roadmap to make the system safer, easier to operate, and more scalable. High risk improper data scenarios Additional correctness traps Framework limitations (current behavior) Improvement roadmap Phase 1: Correctness hardening (highest priority) Phase 2: Convenience and developer experience Phase 3: Scalability and throughput Confirmed from repository code: state overrides from JSON output, sticky intent skip behavior, rule pass mutation loops, context merge semantics, broad prompt var exposure, no optimistic lock field on conversation entity, and findAll() hot path scans. Inferred (consumer dependent): ingress concurrency controls, infra level ordering guarantees, and custom LlmClient timeout/retry strategy.",
    "rawContent": "# Data Correctness Gotchas This page documents where ConvEngine can produce **incorrect, stale, or misleading output** without necessarily crashing. It also lists framework constraints and a concrete roadmap to make the system safer, easier to operate, and more scalable. ## High-risk improper data scenarios <DbTable title=\"Top correctness failure modes\" columns={[ \"Gotcha\", \"Trigger\", \"Bad output pattern\", \"Fast detection\", \"Practical mitigation\" ]} rows={[ [ \"LLM JSON overrides engine intent/state\", \"Response JSON includes intent or state ; resolver applies those fields directly.\", \"Flow silently jumps to wrong state/intent on next turn.\", \"Compare pre/post state around RESOLVE_RESPONSE_LLM_OUTPUT and final persisted conversation row.\", \"Allowlist transitions, reject unknown states, and gate model-driven state changes behind validator hooks.\" ], [ \"Sticky intent routes new question to old flow\", \" STICKY_INTENT=true + active incomplete schema collection + no explicit switch/reset signal.\", \"User asks new intent but gets response from previous intent templates/rules.\", \"Frequent INTENT_RESOLVE_SKIPPED_STICKY_INTENT on semantically new user text.\", \"Force re-resolve on low confidence turns, topic-shift heuristics, and explicit UI switch-intent controls.\" ], [ \"Rule chain side effects create wrong final state\", \"Multiple matching rules mutate intent/state across passes.\", \"Technically valid response, semantically wrong transition path.\", \"Inspect ordered RULE_MATCHED / RULE_APPLIED events by pass and phase.\", \"Constrain rule ownership, cap cross-intent actions, and add collision regression tests for rule priority.\" ], [ \"Context merge preserves stale fields\", \"Schema extraction merges partial JSON into existing context and does not clear incompatible prior fields.\", \"Old values leak into later prompts and responses.\", \"Diff context pre/post schema extraction and check unchanged keys across intent/state changes.\", \"Add per-intent field reset policy and explicit stale-key eviction on transition boundaries.\" ], [ \"Concurrent writes race on same conversation\", \"Parallel requests share same conversationId with no optimistic version check.\", \"Last-write-wins overwrites can produce drifted context/intent/state.\", \"Look for overlapping timestamps and contradictory stage order for one conversation.\", \"Serialize by conversation key at API boundary or add optimistic locking ( @Version ).\" ] ]} /> ## Additional correctness traps <DbTable title=\"Less obvious but important\" columns={[\"Area\", \"What happens\", \"Why it matters\", \"Recommended guardrail\"]} rows={[ [ \"Prompt variable exposure\", \"All inputParams are exposed as prompt vars ( promptTemplateVars path).\", \"Unexpected/sensitive params can influence model behavior or leak into prompts.\", \"Move to explicit allowlist of exposable keys and redact secret-like fields.\" ], [ \"LLM invocation ThreadLocal lifecycle\", \" LlmInvocationContext.set(...) is used in several flows without matching clear in same path.\", \"Pooled-thread reuse can cause wrong attribution/context bleed in custom LlmClient logging.\", \"Wrap set/clear in try/finally in every LLM call site.\" ], [ \"Silent exception swallowing\", \"Several context/container merge failures are ignored to keep pipeline running.\", \"Turn completes with partial enrichment, giving plausible but incorrect output.\", \"Emit warning stages with structured reason and defaulted fields when fallback path is taken.\" ], [ \"History reconstruction quality\", \"Conversation history is reconstructed from audit stages (not canonical turn table).\", \"Missing or filtered audit events can distort LLM context history.\", \"Persist normalized user/assistant turn table and use that as primary history source.\" ], [ \"MCP tool safety assumptions\", \" safe_mode exists on DB tool config but execution path does not enforce separate safe-mode logic.\", \"Risk of over-trusting tool configuration for sensitive data queries.\", \"Enforce explicit read-only policy, SQL allowlist checks, and per-tool security policy validation.\" ] ]} /> ## Framework limitations (current behavior) <DbTable title=\"Design constraints to plan around\" columns={[\"Limitation\", \"Current behavior\", \"Consumer impact\", \"Better direction\"]} rows={[ [ \"No full-turn ACID boundary\", \"Turn state is updated across multiple independent saves/steps.\", \"Partial turn artifacts can persist after mid-pipeline failures.\", \"Introduce transactional turn boundary or compensating state machine.\" ], [ \"No built-in optimistic concurrency for conversation row\", \" ce_conversation entity has no versioned conflict detection.\", \"Racing requests overwrite each other nondeterministically.\", \"Add version column + conflict retry/merge strategy.\" ], [ \"Heavy dynamic config with mixed refresh model\", \"Some configs are read at startup; others queried per turn from DB.\", \"Operational behavior can be hard to reason about after config updates.\", \"Document refresh semantics per config and add explicit reload controls.\" ], [ \"In-memory scan selection paths\", \" findAll().stream() used in response/template/schema selection in hot path.\", \"Larger config tables increase latency and raise variability.\", \"Replace with indexed targeted queries + bounded caches.\" ], [ \"Single-process assumptions for ordering\", \"Conversation ordering and mutation safety are mostly local-process concerns.\", \"Horizontal scale can amplify race and ordering ambiguity.\", \"Adopt distributed per-conversation lock/queue semantics.\" ] ]} /> ## Improvement roadmap ### Phase 1: Correctness hardening (highest priority) <DbTable title=\"Immediate improvements\" columns={[\"Change\", \"Value\", \"Effort\", \"Notes\"]} rows={[ [ \"Add response state-transition validator\", \"Prevents invalid model-driven intent/state jumps.\", \"Low-Medium\", \"Apply before PersistConversationStep ; reject or quarantine invalid transitions.\" ], [ \"Add optimistic locking on ce_conversation \", \"Eliminates silent last-write-wins corruption.\", \"Medium\", \"Introduce version field + retry policy for conflict cases.\" ], [ \"Guarantee LlmInvocationContext.clear() \", \"Prevents cross-request attribution bleed.\", \"Low\", \"Wrap all LLM call sites with try/finally .\" ], [ \"Prompt-var allowlist + redaction\", \"Reduces prompt contamination and secret leakage risk.\", \"Low-Medium\", \"Replace current expose-all behavior with explicit allowlist.\" ], [ \"Emit structured fallback warnings\", \"Makes silent degradations diagnosable.\", \"Low\", \"When a catch-ignore path is hit, emit a dedicated stage with cause metadata.\" ] ]} /> ### Phase 2: Convenience and developer experience <DbTable title=\"Make ConvEngine easier to run\" columns={[\"Enhancement\", \"Why it helps\", \"Suggested shape\"]} rows={[ [ \"Config lint + dry-run validator\", \"Catches broken rules/templates before production impact.\", \"CLI/admin endpoint validating response mappings, rule loops, unresolved template vars, and MCP tool safety.\" ], [ \"State transition map visualization\", \"Helps teams reason about intent/state flows and side effects.\", \"Generate graph from rules + responses + schema transitions with dead-end and collision markers.\" ], [ \"Deterministic replay mode\", \"Simplifies debugging wrong-output incidents.\", \"Replay one conversation against snapshot config and compare expected vs actual transitions.\" ], [ \"Scenario test harness\", \"Moves quality from ad-hoc manual checks to repeatable tests.\", \"YAML/JSON test fixtures for input turn sequences, expected intent/state, payload assertions.\" ] ]} /> ### Phase 3: Scalability and throughput <DbTable title=\"Scale safely\" columns={[\"Scalability upgrade\", \"Benefit\", \"Implementation direction\"]} rows={[ [ \"Targeted repository queries\", \"Cuts CPU and DB transfer overhead in hot path.\", \"Replace findAll().stream() with indexed query methods for intent/state/priority.\" ], [ \"Hot config cache with version invalidation\", \"Stabilizes latency under high QPS.\", \"Cache rules/templates/schemas per intent-state; invalidate on config change event.\" ], [ \"Per-conversation serialized execution\", \"Removes race conditions while scaling horizontally.\", \"Route by conversation key to queue/partition; process one active turn per key.\" ], [ \"Async/parallelizable non-critical enrichments\", \"Reduces end-to-end response time.\", \"Move optional container/MCP enrichments off critical path with explicit timeout budget.\" ], [ \"Canonical turn store\", \"Improves history quality and replay reliability.\", \"Persist normalized user/assistant turns instead of reconstructing from audit stream.\" ] ]} /> <Highlight type=\"info\" title=\"Confirmed vs inferred\"> Confirmed from repository code: state overrides from JSON output, sticky-intent skip behavior, rule pass mutation loops, context merge semantics, broad prompt-var exposure, no optimistic lock field on conversation entity, and findAll() hot-path scans. Inferred (consumer-dependent): ingress concurrency controls, infra-level ordering guarantees, and custom LlmClient timeout/retry strategy. </Highlight>",
    "excerpt": "Data Correctness Gotchas This page documents where ConvEngine can produce incorrect, stale, or misleading output without necessarily crashing. It also lists framework constraints and a concrete roadmap to make the system…"
  },
  {
    "id": "deep-dive/file-map.mdx",
    "version": "v2",
    "title": "file map",
    "permalink": "/docs/v2/deep-dive/file-map",
    "content": "File Map (v2) Core runtime engine/provider/DefaultConversationalEngine.java engine/factory/EnginePipelineFactory.java engine/pipeline/EnginePipeline.java engine/session/EngineSession.java New v2 flow config config/ConvEngineFlowConfig.java New v2 steps engine/steps/DialogueActStep.java engine/steps/InteractionPolicyStep.java engine/steps/ActionLifecycleStep.java engine/steps/DisambiguationStep.java engine/steps/GuardrailStep.java engine/steps/PendingActionStep.java (enhanced behavior) engine/steps/ToolOrchestrationStep.java engine/steps/StateGraphStep.java engine/steps/MemoryStep.java Intent/schema/rules/response engine/steps/IntentResolutionStep.java engine/steps/SchemaExtractionStep.java engine/steps/RulesStep.java engine/steps/ResponseResolutionStep.java MCP + tool execution engine/steps/McpToolStep.java engine/mcp/McpPlanner.java engine/mcp/McpToolRegistry.java engine/mcp/executor/McpToolExecutor.java engine/mcp/executor/ (group specific executors) engine/mcp/executor/adapter/ (consumer adapter contracts) Data + repositories entity/CePendingAction.java repo/PendingActionRepository.java entity/CeRule.java repo/RuleRepository.java SQL DDL files in src/main/resources/sql/ Memory + eval engine/memory/ConversationMemoryStore.java engine/eval/ConversationReplayService.java engine/eval/model/",
    "rawContent": "# File Map (v2) ## Core runtime - engine/provider/DefaultConversationalEngine.java - engine/factory/EnginePipelineFactory.java - engine/pipeline/EnginePipeline.java - engine/session/EngineSession.java ## New v2 flow config - config/ConvEngineFlowConfig.java ## New v2 steps - engine/steps/DialogueActStep.java - engine/steps/InteractionPolicyStep.java - engine/steps/ActionLifecycleStep.java - engine/steps/DisambiguationStep.java - engine/steps/GuardrailStep.java - engine/steps/PendingActionStep.java (enhanced behavior) - engine/steps/ToolOrchestrationStep.java - engine/steps/StateGraphStep.java - engine/steps/MemoryStep.java ## Intent/schema/rules/response - engine/steps/IntentResolutionStep.java - engine/steps/SchemaExtractionStep.java - engine/steps/RulesStep.java - engine/steps/ResponseResolutionStep.java ## MCP + tool execution - engine/steps/McpToolStep.java - engine/mcp/McpPlanner.java - engine/mcp/McpToolRegistry.java - engine/mcp/executor/McpToolExecutor.java - engine/mcp/executor/* (group-specific executors) - engine/mcp/executor/adapter/* (consumer adapter contracts) ## Data + repositories - entity/CePendingAction.java - repo/PendingActionRepository.java - entity/CeRule.java - repo/RuleRepository.java - SQL DDL files in src/main/resources/sql/* ## Memory + eval - engine/memory/ConversationMemoryStore.java - engine/eval/ConversationReplayService.java - engine/eval/model/*",
    "excerpt": "File Map (v2) Core runtime engine/provider/DefaultConversationalEngine.java engine/factory/EnginePipelineFactory.java engine/pipeline/EnginePipeline.java engine/session/EngineSession.java New v2 flow config config/ConvEn…"
  },
  {
    "id": "deep-dive/improvement-backlog.mdx",
    "version": "v2",
    "title": "improvement backlog",
    "permalink": "/docs/v2/deep-dive/improvement-backlog",
    "content": "Improvement Backlog Current v2 direction: richer policy DSL for interaction matrix built in conflict resolution strategies for pending actions audit replay assertions as first class CI utility docs automation from code/DDL contracts",
    "rawContent": "# Improvement Backlog Current v2 direction: - richer policy DSL for interaction matrix - built-in conflict resolution strategies for pending actions - audit replay assertions as first-class CI utility - docs automation from code/DDL contracts",
    "excerpt": "Improvement Backlog Current v2 direction: richer policy DSL for interaction matrix built in conflict resolution strategies for pending actions audit replay assertions as first class CI utility docs automation from code/D…"
  },
  {
    "id": "deep-dive/index.mdx",
    "version": "v2",
    "title": "index",
    "permalink": "/docs/v2/deep-dive",
    "content": "Deep Dive This section documents the actual runtime behavior from code and schema, including step contracts, rule phases, audit traces, and control plane tables. Sections : End to end turn lifecycle and branch points. : Turn by turn chat, DB contracts, and audit timeline walkthroughs. : ce_ table contracts and runtime/control plane split. : Consumer implementation and extension strategy. : Source level map of key classes by responsibility. : Full step by step pipeline with exact stage purpose. : Intent resolution + schema extraction internals. : Rule phases, match/action behavior, response resolution. : MCP planner/tool orchestration and audit stages. : Detailed breakdown of newly introduced capabilities. : Common failure/correctness risks and mitigations.",
    "rawContent": "# Deep Dive This section documents the actual runtime behavior from code and schema, including step contracts, rule phases, audit traces, and control-plane tables. ## Sections - [Lifecycle](/docs/v2/deep-dive/lifecycle): End-to-end turn lifecycle and branch points. - [Real World Examples](/docs/v2/deep-dive/examples): Turn-by-turn chat, DB contracts, and audit timeline walkthroughs. - [Data Model](/docs/v2/deep-dive/data-model): ce_* table contracts and runtime/control-plane split. - [Developer Guide](/docs/v2/deep-dive/developer-guide): Consumer implementation and extension strategy. - [File Map](/docs/v2/deep-dive/file-map): Source-level map of key classes by responsibility. - [Pipeline Steps](/docs/v2/deep-dive/pipeline-steps): Full step-by-step pipeline with exact stage purpose. - [Intent & Schema](/docs/v2/deep-dive/intent-and-schema): Intent resolution + schema extraction internals. - [Rules & Responses](/docs/v2/deep-dive/rules-responses): Rule phases, match/action behavior, response resolution. - [MCP and Audit](/docs/v2/deep-dive/mcp-audit): MCP planner/tool orchestration and audit stages. - [v2 Features](/docs/v2/deep-dive/v2-features): Detailed breakdown of newly introduced capabilities. - [Failure Gotchas](/docs/v2/deep-dive/failure-gotchas): Common failure/correctness risks and mitigations.",
    "excerpt": "Deep Dive This section documents the actual runtime behavior from code and schema, including step contracts, rule phases, audit traces, and control plane tables. Sections : End to end turn lifecycle and branch points. : …"
  },
  {
    "id": "deep-dive/intent-and-schema.mdx",
    "version": "v2",
    "title": "intent and schema",
    "permalink": "/docs/v2/deep-dive/intent-and-schema",
    "content": "Intent and Schema Internals (v2) Dialogue act resolution DialogueActStep supports three modes via convengine.flow.dialogue act.resolute : REGEX_ONLY REGEX_THEN_LLM LLM_ONLY Regex handles core acts: AFFIRM NEGATE EDIT RESET QUESTION fallback NEW_REQUEST When LLM path is used, it must return strict JSON act + confidence. Interaction policy decision InteractionPolicyStep derives policy decision using: dialogue act pending action/slot presence optional pending action registry presence configurable matrix in convengine.flow.interaction policy.matrix Decisions: EXECUTE_PENDING_ACTION REJECT_PENDING_ACTION FILL_PENDING_SLOT RECLASSIFY_INTENT Intent resolver behavior in v2 IntentResolutionStep can skip resolution when: schema collection is active/locked policy sets skip_intent_resolution=true sticky intent optimization is active during incomplete schema flow New audit signals: INTENT_RESOLVE_SKIPPED_POLICY INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION INTENT_RESOLVE_SKIPPED_STICKY_INTENT Schema extraction SchemaExtractionStep still drives missing field follow up flows. Runtime facts are written into input params and then used by rules: missing_fields missing_field_options schema_json schema_complete Practical design rule Use schema extraction for required slot collection, and use dialogue+policy for short confirmations ( yes/ok/do that ) so intent reclassification does not disrupt active flow.",
    "rawContent": "# Intent and Schema Internals (v2) ## Dialogue act resolution DialogueActStep supports three modes via convengine.flow.dialogue-act.resolute : - REGEX_ONLY - REGEX_THEN_LLM - LLM_ONLY Regex handles core acts: - AFFIRM - NEGATE - EDIT - RESET - QUESTION - fallback NEW_REQUEST When LLM path is used, it must return strict JSON act + confidence. ## Interaction policy decision InteractionPolicyStep derives policy decision using: - dialogue act - pending action/slot presence - optional pending-action registry presence - configurable matrix in convengine.flow.interaction-policy.matrix Decisions: - EXECUTE_PENDING_ACTION - REJECT_PENDING_ACTION - FILL_PENDING_SLOT - RECLASSIFY_INTENT ## Intent resolver behavior in v2 IntentResolutionStep can skip resolution when: - schema collection is active/locked - policy sets skip_intent_resolution=true - sticky-intent optimization is active during incomplete schema flow New audit signals: - INTENT_RESOLVE_SKIPPED_POLICY - INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION - INTENT_RESOLVE_SKIPPED_STICKY_INTENT ## Schema extraction SchemaExtractionStep still drives missing-field follow-up flows. Runtime facts are written into input params and then used by rules: - missing_fields - missing_field_options - schema_json - schema_complete ## Practical design rule Use schema extraction for required slot collection, and use dialogue+policy for short confirmations ( yes/ok/do that ) so intent reclassification does not disrupt active flow.",
    "excerpt": "Intent and Schema Internals (v2) Dialogue act resolution DialogueActStep supports three modes via convengine.flow.dialogue act.resolute : REGEX_ONLY REGEX_THEN_LLM LLM_ONLY Regex handles core acts: AFFIRM NEGATE EDIT RES…"
  },
  {
    "id": "deep-dive/lifecycle.mdx",
    "version": "v2",
    "title": "lifecycle",
    "permalink": "/docs/v2/deep-dive/lifecycle",
    "content": ", , , , , , , , , , , , , , , , , , , , , , , , , ]; Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open /docs/v2/deep dive/request lifecycle . 1. API Entry Point The journey begins when a client sends a POST request to /api/v1/conversation/message . } 2. Engine Processing } 3. The Pipeline (Step by Step) DialogueActStep , InteractionPolicyStep , ActionLifecycleStep , DisambiguationStep , PendingActionStep , ToolOrchestrationStep , McpToolStep , StateGraphStep , and MemoryStep are route conditional and execute only when their prerequisites are met. Every step emits audit events. Use /audit/ /trace , then open /docs/v2/deep dive/request lifecycle and /docs/v2/deep dive/examples to compare turn by turn real world traces.",
    "rawContent": "{ name: \"LoadOrCreateConversationStep\", description: \"Hydrates existing conversation or creates new conversation shell.\" }, { name: \"ResetConversationStep\", description: \"Applies reset/start-over command handling.\" }, { name: \"PersistConversationBootstrapStep\", description: \"Persists conversation bootstrap row before persisted-required steps.\" }, { name: \"AuditUserInputStep\", description: \"Writes raw user input audit event.\" }, { name: \"PolicyEnforcementStep\", description: \"Applies pre-intent policy checks and safe short-circuit when required.\" }, { name: \"DialogueActStep\", description: \"Classifies turn as AFFIRM/NEGATE/EDIT/RESET/QUESTION/NEW_REQUEST.\" }, { name: \"InteractionPolicyStep\", description: \"Decides EXECUTE_PENDING_ACTION / REJECT_PENDING_ACTION / FILL_PENDING_SLOT / RECLASSIFY_INTENT.\" }, { name: \"ActionLifecycleStep\", description: \"Maintains pending_action_runtime status with TTL semantics.\" }, { name: \"DisambiguationStep\", description: \"When multiple actions are eligible, asks targeted clarification and pauses execution.\" }, { name: \"GuardrailStep\", description: \"Sanitization + sensitive checks + approval gate hooks.\" }, { name: \"IntentResolutionStep\", description: \"Resolves intent unless policy says skip_intent_resolution.\" }, { name: \"ResetResolvedIntentStep\", description: \"Applies post-intent reset mapping.\" }, { name: \"FallbackIntentStateStep\", description: \"Assigns fallback UNKNOWN flow when intent/state unresolved.\" }, { name: \"AddContainerDataStep\", description: \"Merges configured container data into runtime context.\" }, { name: \"PendingActionStep\", description: \"Executes or rejects pending action task via CeTaskExecutor.\" }, { name: \"ToolOrchestrationStep\", description: \"Unified tool request->execute->result contract by tool_group.\" }, { name: \"McpToolStep\", description: \"Planner loop for CALL_TOOL/ANSWER with MCP observations.\" }, { name: \"SchemaExtractionStep\", description: \"Parses/extracts structured schema fields.\" }, { name: \"AutoAdvanceStep\", description: \"Advances state when schema/task facts satisfy conditions.\" }, { name: \"RulesStep\", description: \"Runs phase-scoped rules and actions with cascade passes.\" }, { name: \"StateGraphStep\", description: \"Validate-only transition check, no forced state mutation.\" }, { name: \"ResponseResolutionStep\", description: \"Resolves EXACT/DERIVED response output.\" }, { name: \"MemoryStep\", description: \"Writes session summary and optional recall memory.\" }, { name: \"PersistConversationStep\", description: \"Persists conversation/result/audit metadata.\" }, { name: \"PipelineEndGuardStep\", description: \"Final guard and timing closure.\" }, ]; # Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open <FileRef>/docs/v2/deep-dive/request-lifecycle</FileRef>. ## 1. API Entry Point The journey begins when a client sends a POST request to /api/v1/conversation/message . <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.api.controller\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\" > { @PostMapping(\"/message\") public ConversationResponse message(@RequestBody ConversationRequest request) { EngineContext engineContext = EngineContext.builder() .conversationId(request.getConversationId()) .userText(request.getMessage()) .inputParams(request.getInputParams()) .build(); EngineResult result = engine.process(engineContext); return mapToResponse(result); } } </CodeBlockToggle> ## 2. Engine Processing <CodeBlockToggle title=\"DefaultConversationalEngine.process\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" > { @Override public EngineResult process(EngineContext engineContext) { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } } </CodeBlockToggle> ## 3. The Pipeline (Step-by-Step) <PipelineStepList ariaLabel=\"Pipeline step-by-step (v2)\" steps={v2PipelineSteps} /> <Highlight type=\"info\" title=\"Core path vs conditional steps\"> DialogueActStep , InteractionPolicyStep , ActionLifecycleStep , DisambiguationStep , PendingActionStep , ToolOrchestrationStep , McpToolStep , StateGraphStep , and MemoryStep are route-conditional and execute only when their prerequisites are met. </Highlight> <Highlight type=\"success\" title=\"Audit Trail + Real-world trace\"> Every step emits audit events. Use /audit/{id}/trace , then open <FileRef>/docs/v2/deep-dive/request-lifecycle</FileRef> and <FileRef>/docs/v2/deep-dive/examples</FileRef> to compare turn-by-turn real-world traces. </Highlight>",
    "excerpt": ", , , , , , , , , , , , , , , , , , , , , , , , , ]; Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open /docs/v2/deep dive/request lifecycle . 1. API Entry Point The journe…"
  },
  {
    "id": "deep-dive/mcp-audit.mdx",
    "version": "v2",
    "title": "mcp audit",
    "permalink": "/docs/v2/deep-dive/mcp-audit",
    "content": "MCP, Tool Orchestration, and Audit (v2) Two tool paths in v2 1. ToolOrchestrationStep direct request path via tool_request executes exactly one tool request runs TOOL_POST_EXECUTION rules 2. McpToolStep planner loop path ( CALL_TOOL / ANSWER ) supports up to bounded loops writes observations/final answer to context.mcp runs MCP_POST_LLM rules Executor model Both paths dispatch to McpToolExecutor implementations by normalized tool_group . Built in groups: DB HTTP_API WORKFLOW_ACTION DOCUMENT_RETRIEVAL CALCULATOR_TRANSFORM NOTIFICATION FILES Adapter interfaces exist so consumers can plug business implementations without editing engine steps. Guardrail integration If guardrail blocks execution: skip_tool_execution=true MCP/tool steps safely skip no unhandled errors required for this branch Audit stages to watch Tool orchestration: TOOL_ORCHESTRATION_REQUEST TOOL_ORCHESTRATION_RESULT TOOL_ORCHESTRATION_ERROR MCP planner: MCP_PLAN_LLM_INPUT MCP_PLAN_LLM_OUTPUT MCP_TOOL_CALL MCP_TOOL_RESULT MCP_TOOL_ERROR MCP_FINAL_ANSWER MCP tool scope filtering ce_mcp_tool supports optional runtime scope columns: intent_code state_code Eligibility rules: NULL scope values are wildcards non null scope values must match current session.intent and session.state if no MCP tool matches current scope, MCP step skips safely and emits MCP_NO_TOOLS_AVAILABLE",
    "rawContent": "# MCP, Tool Orchestration, and Audit (v2) ## Two tool paths in v2 1. ToolOrchestrationStep - direct request path via tool_request - executes exactly one tool request - runs TOOL_POST_EXECUTION rules 2. McpToolStep - planner loop path ( CALL_TOOL / ANSWER ) - supports up to bounded loops - writes observations/final answer to context.mcp - runs MCP_POST_LLM rules ## Executor model Both paths dispatch to McpToolExecutor implementations by normalized tool_group . Built-in groups: - DB - HTTP_API - WORKFLOW_ACTION - DOCUMENT_RETRIEVAL - CALCULATOR_TRANSFORM - NOTIFICATION - FILES Adapter interfaces exist so consumers can plug business implementations without editing engine steps. ## Guardrail integration If guardrail blocks execution: - skip_tool_execution=true - MCP/tool steps safely skip - no unhandled errors required for this branch ## Audit stages to watch Tool orchestration: - TOOL_ORCHESTRATION_REQUEST - TOOL_ORCHESTRATION_RESULT - TOOL_ORCHESTRATION_ERROR MCP planner: - MCP_PLAN_LLM_INPUT - MCP_PLAN_LLM_OUTPUT - MCP_TOOL_CALL - MCP_TOOL_RESULT - MCP_TOOL_ERROR - MCP_FINAL_ANSWER ## MCP tool scope filtering ce_mcp_tool supports optional runtime scope columns: - intent_code - state_code Eligibility rules: - NULL scope values are wildcards - non-null scope values must match current session.intent and session.state - if no MCP tool matches current scope, MCP step skips safely and emits MCP_NO_TOOLS_AVAILABLE",
    "excerpt": "MCP, Tool Orchestration, and Audit (v2) Two tool paths in v2 1. ToolOrchestrationStep direct request path via tool_request executes exactly one tool request runs TOOL_POST_EXECUTION rules 2. McpToolStep planner loop path…"
  },
  {
    "id": "deep-dive/pipeline-steps.mdx",
    "version": "v2",
    "title": "pipeline steps",
    "permalink": "/docs/v2/deep-dive/pipeline-steps",
    "content": "Pipeline Steps (what each step does) :::tip Hook where you need precision Before schema extraction: normalize inputs After rules: inspect intent/state transition correctness Before response resolution: inject display hints ::: Rules execute by phase. v2 includes PIPELINE_RULES , AGENT_POST_INTENT , MCP_POST_LLM , and TOOL_POST_EXECUTION . Prefer transitions in ce_rule unless absolutely framework level behavior is required. This keeps domain behavior data driven and testable via audit traces.",
    "rawContent": "# Pipeline Steps (what each step does) <DbTable title=\"Step responsibilities\" columns={[\"Step\", \"Primary responsibility\", \"Main session mutations\", \"Config/table dependencies\"]} rows={[ [\"LoadOrCreateConversationStep\", \"Fetch or bootstrap conversation row\", \"conversation, intent/state/context sync\", \"ce_conversation\"], [\"ResetConversationStep\", \"Early explicit reset\", \"intent/state/context/input params reset\", \"input flags, command text\"], [\"PersistConversationBootstrapStep\", \"Ensure conversation row persisted\", \"none/metadata\", \"ce_conversation\"], [\"AuditUserInputStep\", \"Persist user input audit\", \"none\", \"ce_audit\"], [\"PolicyEnforcementStep\", \"Policy block and stop\", \"payload + stop result on block\", \"ce_policy\"], [\"DialogueActStep\", \"Classify user turn action type\", \"dialogue_act in input params\", \"ce_config (dialogue act mode), ce_audit\"], [\"InteractionPolicyStep\", \"Decide runtime policy before intent\", \"policy_decision, skip_intent_resolution\", \"ce_config, session pending state\"], [\"ActionLifecycleStep\", \"Maintain pending action runtime TTL/status\", \"pending_action_runtime context\", \"ce_pending_action, ce_audit\"], [\"DisambiguationStep\", \"Ask question when multiple actions fit\", \"pending_clarification question/context\", \"ce_pending_action, ce_config, ce_audit\"], [\"GuardrailStep\", \"Apply guardrails and approval rules\", \"guardrail flags/sanitized text\", \"ce_config, ce_audit\"], [\"IntentResolutionStep\", \"Resolve intent with classifier+agent\", \"intent/state/clarification fields\", \"ce_intent, ce_intent_classifier, ce_config\"], [\"ResetResolvedIntentStep\", \"Reset on configured reset intent\", \"full reset\", \"ce_config RESET_INTENT_CODES\"], [\"FallbackIntentStateStep\", \"Fill missing intent/state defaults\", \"intent/state\", \"none\"], [\"AddContainerDataStep\", \"Fetch and attach container data\", \"containerData/context merge\", \"ce_container_config\"], [\"PendingActionStep\", \"Execute/reject pending action task\", \"pending_action_runtime status/result\", \"ce_pending_action, CeTaskExecutor, ce_audit\"], [\"ToolOrchestrationStep\", \"Run tool_group based orchestration\", \"tool_request/tool_result fields\", \"ce_tool, ce_mcp_tool, ce_audit\"], [\"McpToolStep\", \"MCP planner/tool loop\", \"context_json.mcp.*\", \"ce_mcp_tool, ce_mcp_db_tool, ce_config\"], [\"SchemaExtractionStep\", \"Schema-driven extraction and lock handling\", \"schema facts/context/lock\", \"ce_output_schema, ce_prompt_template\"], [\"AutoAdvanceStep\", \"Compute schema status facts\", \"schemaComplete/hasAny\", \"resolved schema + context\"], [\"RulesStep\", \"Match and apply transitions/actions\", \"intent/state/input params\", \"ce_rule\"], [\"StateGraphStep\", \"Validate state transition path\", \"state_graph_valid/reason\", \"ce_state_graph, ce_audit\"], [\"ResponseResolutionStep\", \"Resolve and generate output payload\", \"payload/last assistant json\", \"ce_response, ce_prompt_template\"], [\"MemoryStep\", \"Write memory/session summary\", \"memory.session_summary in context\", \"ce_memory, ce_audit\"], [\"PersistConversationStep\", \"Persist final conversation and result\", \"finalResult\", \"ce_conversation\"], [\"PipelineEndGuardStep\", \"Timing audit + terminal guard\", \"timings\", \"ce_audit\"], ]} /> :::tip Hook where you need precision - Before schema extraction: normalize inputs - After rules: inspect intent/state transition correctness - Before response resolution: inject display hints ::: <Highlight type=\"info\" title=\"v2 rule phases\"> Rules execute by phase. v2 includes PIPELINE_RULES , AGENT_POST_INTENT , MCP_POST_LLM , and TOOL_POST_EXECUTION . </Highlight> <Highlight type=\"warning\" title=\"Don’t hardcode transitions in steps\"> Prefer transitions in ce_rule unless absolutely framework-level behavior is required. This keeps domain behavior data-driven and testable via audit traces. </Highlight>",
    "excerpt": "Pipeline Steps (what each step does) :::tip Hook where you need precision Before schema extraction: normalize inputs After rules: inspect intent/state transition correctness Before response resolution: inject display hin…"
  },
  {
    "id": "deep-dive/request-lifecycle.mdx",
    "version": "v2",
    "title": "request lifecycle",
    "permalink": "/docs/v2/deep-dive/request-lifecycle",
    "content": ", , , , , , , , , , , , , , , , , , , , , , , , , ]; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , , , , , , , , ]; api: , engine: , session: , pipeline: , s1: , s2: , s3: , s4: , s5: , s6: , s7: , s8: , s9: , s10: , out: , }; Request Lifecycle (IDE Debug Mode) This page is the runtime control flow view for one turn. Think of it as stepping through breakpoints from API entry to final persistence. Canonical step inventory (latest) The visual flow highlights the common deterministic runtime path. Conditional/system steps from the list above still execute when their prerequisites are met. Engine\" default // orderByDag uses @MustRunAfter, @MustRunBefore, @RequiresConversationPersisted // wrapWithTiming adds STEP_ENTER / STEP_EXIT / STEP_ERROR audits + hook callbacks } } return session.getFinalResult(); } default void beforeStep(EngineStep.Name stepName, EngineSession session) default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) } } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } Table Touch Matrix Start at IntentResolutionStep , then click SchemaExtractionStep and RulesStep in the tree. That path explains most multi turn behavior differences.",
    "rawContent": "{ name: \"LoadOrCreateConversationStep\", description: \"Hydrates existing conversation or creates new conversation shell.\" }, { name: \"ResetConversationStep\", description: \"Applies reset/start-over command handling.\" }, { name: \"PersistConversationBootstrapStep\", description: \"Persists conversation bootstrap row before persisted-required steps.\" }, { name: \"AuditUserInputStep\", description: \"Writes raw user input audit event.\" }, { name: \"PolicyEnforcementStep\", description: \"Applies pre-intent policy checks and safe short-circuit when required.\" }, { name: \"DialogueActStep\", description: \"Classifies turn as AFFIRM/NEGATE/EDIT/RESET/QUESTION/NEW_REQUEST.\" }, { name: \"InteractionPolicyStep\", description: \"Decides EXECUTE_PENDING_ACTION / REJECT_PENDING_ACTION / FILL_PENDING_SLOT / RECLASSIFY_INTENT.\" }, { name: \"ActionLifecycleStep\", description: \"Maintains pending_action_runtime status with TTL semantics.\" }, { name: \"DisambiguationStep\", description: \"When multiple actions are eligible, asks targeted clarification and pauses execution.\" }, { name: \"GuardrailStep\", description: \"Sanitization + sensitive checks + approval gate hooks.\" }, { name: \"IntentResolutionStep\", description: \"Resolves intent unless policy says skip_intent_resolution.\" }, { name: \"ResetResolvedIntentStep\", description: \"Applies post-intent reset mapping.\" }, { name: \"FallbackIntentStateStep\", description: \"Assigns fallback UNKNOWN flow when intent/state unresolved.\" }, { name: \"AddContainerDataStep\", description: \"Merges configured container data into runtime context.\" }, { name: \"PendingActionStep\", description: \"Executes or rejects pending action task via CeTaskExecutor.\" }, { name: \"ToolOrchestrationStep\", description: \"Unified tool request->execute->result contract by tool_group.\" }, { name: \"McpToolStep\", description: \"Planner loop for CALL_TOOL/ANSWER with MCP observations.\" }, { name: \"SchemaExtractionStep\", description: \"Parses/extracts structured schema fields.\" }, { name: \"AutoAdvanceStep\", description: \"Advances state when schema/task facts satisfy conditions.\" }, { name: \"RulesStep\", description: \"Runs phase-scoped rules and actions with cascade passes.\" }, { name: \"StateGraphStep\", description: \"Validate-only transition check, no forced state mutation.\" }, { name: \"ResponseResolutionStep\", description: \"Resolves EXACT/DERIVED response output.\" }, { name: \"MemoryStep\", description: \"Writes session summary and optional recall memory.\" }, { name: \"PersistConversationStep\", description: \"Persists conversation/result/audit metadata.\" }, { name: \"PipelineEndGuardStep\", description: \"Final guard and timing closure.\" }, ]; { id: \"api\", position: { x: 20, y: 40 }, data: { label: \"API: ConversationController.message\" } }, { id: \"engine\", position: { x: 300, y: 40 }, data: { label: \"DefaultConversationalEngine.process\" } }, { id: \"session\", position: { x: 580, y: 40 }, data: { label: \"EngineSessionFactory.open\" } }, { id: \"pipeline\", position: { x: 860, y: 40 }, data: { label: \"EnginePipelineFactory.create\" } }, { id: \"s1\", position: { x: 20, y: 190 }, data: { label: \"LoadOrCreateConversationStep\" } }, { id: \"s2\", position: { x: 260, y: 190 }, data: { label: \"ResetConversationStep\" } }, { id: \"s3\", position: { x: 500, y: 190 }, data: { label: \"AuditUserInputStep\" } }, { id: \"s4\", position: { x: 740, y: 190 }, data: { label: \"IntentResolutionStep\" } }, { id: \"s5\", position: { x: 980, y: 190 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"s6\", position: { x: 20, y: 340 }, data: { label: \"AutoAdvanceStep\" } }, { id: \"s7\", position: { x: 260, y: 340 }, data: { label: \"RulesStep\" } }, { id: \"s8\", position: { x: 500, y: 340 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"s9\", position: { x: 740, y: 340 }, data: { label: \"PersistConversationStep\" } }, { id: \"s10\", position: { x: 980, y: 340 }, data: { label: \"PipelineEndGuardStep\" } }, { id: \"out\", position: { x: 500, y: 500 }, data: { label: \"EngineResult -> HTTP Response\" } }, ]; { id: \"e1\", source: \"api\", target: \"engine\" }, { id: \"e2\", source: \"engine\", target: \"session\" }, { id: \"e3\", source: \"session\", target: \"pipeline\" }, { id: \"e4\", source: \"pipeline\", target: \"s1\" }, { id: \"e5\", source: \"s1\", target: \"s2\" }, { id: \"e6\", source: \"s2\", target: \"s3\" }, { id: \"e7\", source: \"s3\", target: \"s4\" }, { id: \"e8\", source: \"s4\", target: \"s5\" }, { id: \"e9\", source: \"s5\", target: \"s6\" }, { id: \"e10\", source: \"s6\", target: \"s7\" }, { id: \"e11\", source: \"s7\", target: \"s8\" }, { id: \"e12\", source: \"s8\", target: \"s9\" }, { id: \"e13\", source: \"s9\", target: \"s10\" }, { id: \"e14\", source: \"s10\", target: \"out\" }, ]; api: { title: \"ConversationController.message\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Reads request body, normalizes inputParams, injects reset flag when needed, builds EngineContext and delegates to engine.process.\", session: [\"conversationId maybe provided or generated\", \"userText from request.message\", \"inputParams merged\"], tables: [\"none\"], }, engine: { title: \"DefaultConversationalEngine.process\", file: \"engine/provider/DefaultConversationalEngine.java\", method: \"process(EngineContext)\", stage: \"ENGINE_ENTRY\", summary: \"Opens EngineSession, loads conversation history provider data, executes pipeline, returns EngineResult.\", session: [\"session created\", \"conversationHistory injected\"], tables: [\"ce_audit (indirect via steps)\", \"ce_conversation (indirect via steps)\"], }, session: { title: \"EngineSessionFactory.open\", file: \"engine/factory/EngineSessionFactory.java\", method: \"open(EngineContext)\", stage: \"SESSION_BOOTSTRAP\", summary: \"Ensures conversation bootstrap row exists, attaches it into session, syncs state/intent/context/input params.\", session: [\"conversation object attached\", \"intent/state/context synced from DB\"], tables: [\"ce_conversation (R/W bootstrap)\"], }, pipeline: { title: \"EnginePipelineFactory.create\", file: \"engine/factory/EnginePipelineFactory.java\", method: \"orderByDag(...) + wrapWithTiming(...)\", stage: \"PIPELINE_BUILD\", summary: \"Resolves step DAG by annotations, wraps each step in timing/audit/hook-aware wrapper.\", session: [\"none (topology build)\"], tables: [\"none\"], }, s1: { title: \"LoadOrCreateConversationStep.execute\", file: \"engine/steps/LoadOrCreateConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Loads/syncs conversation row into session and keeps runtime state consistent.\", session: [\"conversation synchronized\", \"state available for next steps\"], tables: [\"ce_conversation (R/W)\"], }, s2: { title: \"ResetConversationStep.execute\", file: \"engine/steps/ResetConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Checks reset controls ( reset , restart , conversation_reset , command text). If triggered, wipes conversation runtime state.\", session: [\"intent/state/context reset conditionally\", \"input controls filtered\"], tables: [\"ce_conversation (W)\", \"ce_audit (CONVERSATION_RESET)\"], }, s3: { title: \"AuditUserInputStep.execute\", file: \"engine/steps/AuditUserInputStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Writes compact user input audit record with session meta intent/state.\", session: [\"user input captured\"], tables: [\"ce_audit (W)\"], }, s4: { title: \"IntentResolutionStep.execute\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Resolves intent using classifier + agent flow, with schema lock checks and collision handling.\", session: [\"intent maybe changed\", \"state may become INTENT_COLLISION\"], tables: [\"ce_intent (R)\", \"ce_intent_classifier (R)\", \"ce_config (R)\", \"ce_audit (W)\"], }, s5: { title: \"SchemaExtractionStep.execute\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Finds schema by intent/state, renders prompt template, calls LLM JSON extraction, merges context, computes missing fields, locks/unlocks intent.\", session: [\"contextJson merged\", \"schemaComplete/schemaHasAnyValue flags\", \"missing fields/options\"], tables: [\"ce_output_schema (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\", \"ce_config (R optional)\"], }, s6: { title: \"AutoAdvanceStep.execute\", file: \"engine/steps/AutoAdvanceStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Applies deterministic state changes from schema facts before rules run.\", session: [\"state may auto-transition\"], tables: [\"ce_audit (W)\"], }, s7: { title: \"RulesStep.execute\", file: \"engine/steps/RulesStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Runs enabled rules in priority order with multi-pass cascading when intent/state changes.\", session: [\"intent/state/context/inputParams may mutate via actions\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"], }, s8: { title: \"ResponseResolutionStep.execute\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Selects response mapping, executes EXACT/DERIVED strategy, resolves templates for derived output, applies transformers, audits output.\", session: [\"payload set\", \"finalResult staged\"], tables: [\"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"], }, s9: { title: \"PersistConversationStep.execute\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Persists final conversation state and last assistant payload to durable row.\", session: [\"conversation row synchronized with runtime\"], tables: [\"ce_conversation (W)\", \"ce_audit (W optional)\"], }, s10: { title: \"PipelineEndGuardStep.execute\", file: \"engine/steps/PipelineEndGuardStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Final guard/timing stage, emits pipeline timing audit and closes execution envelope.\", session: [\"step timings finalized\"], tables: [\"ce_audit (W)\"], }, out: { title: \"EngineResult return\", file: \"api/controller/ConversationController.java\", method: \"message(...) return\", stage: \"HTTP_RESPONSE\", summary: \"Controller maps EngineResult to API response payload type (TEXT/JSON) and returns to client.\", session: [\"final result exposed\"], tables: [\"none\"], }, }; # Request Lifecycle (IDE Debug Mode) This page is the runtime control-flow view for one turn. Think of it as stepping through breakpoints from API entry to final persistence. ## Canonical step inventory (latest) <PipelineStepList ariaLabel=\"Canonical step inventory (v2)\" steps={v2PipelineSteps} /> <Highlight type=\"tip\" title=\"Graph below is the common path\"> The visual flow highlights the common deterministic runtime path. Conditional/system steps from the list above still execute when their prerequisites are met. </Highlight> <EngineDebugFlow title=\"Request Turn Execution Graph\" subtitle=\"Click any node in tree or graph to inspect method-level detail, session snapshots, and table touch points.\" nodes={lifecycleNodes} edges={lifecycleEdges} detailsById={lifecycleDetails} defaultSelectedId=\"s4\" /> <Tabs groupId=\"lifecycle-code\"> <TabItem value=\"entry\" label=\"Controller -> Engine\" default> <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.api.controller\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\" > { EngineContext engineContext = EngineContext.builder() .conversationId(conversationId.toString()) .userText(request.getMessage()) .inputParams(inputParams) .build(); EngineResult result = engine.process(engineContext); } </CodeBlockToggle> <CodeBlockToggle title=\"DefaultConversationalEngine.process\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" > { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } </CodeBlockToggle> </TabItem> <TabItem value=\"pipeline\" label=\"DAG + Step Wrapper\"> <CodeBlockToggle title=\"EnginePipelineFactory.orderByDag + wrapWithTiming\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.factory\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/factory/EnginePipelineFactory.java\" > { @PostConstruct public void init() { List<EngineStep> ordered = orderByDag(discoveredSteps); this.pipeline = new EnginePipeline(wrapWithTiming(ordered)); } // orderByDag uses @MustRunAfter, @MustRunBefore, @RequiresConversationPersisted // wrapWithTiming adds STEP_ENTER / STEP_EXIT / STEP_ERROR audits + hook callbacks } </CodeBlockToggle> <CodeBlockToggle title=\"EnginePipeline.execute\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java\" > { for (EngineStep step : steps) { StepResult r = step.execute(session); if (r instanceof StepResult.Stop(EngineResult result)) { return result; } } return session.getFinalResult(); } </CodeBlockToggle> </TabItem> <TabItem value=\"hooks\" label=\"Step Hook Interception\"> <CodeBlockToggle title=\"EngineStepHook typed step matching\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.hook\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/hook/EngineStepHook.java\" > { public interface EngineStepHook { default boolean supports(EngineStep.Name stepName, EngineSession session) { return true; } default void beforeStep(EngineStep.Name stepName, EngineSession session) {} default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) {} default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) {} } } </CodeBlockToggle> <CodeBlockToggle title=\"Consumer hook example\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\" > { @Component public class MyHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName; } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"consumer_hint\", \"compact\"); } } } </CodeBlockToggle> </TabItem> </Tabs> ## Table Touch Matrix <DbTable title=\"Per-turn table access\" columns={[\"Table\", \"Read Path\", \"Write Path\"]} rows={[ [\"ce_conversation\", \"LoadOrCreateConversationStep\", \"PersistConversationStep / reset steps\"], [\"ce_intent\", \"IntentResolutionStep\", \"-\"], [\"ce_intent_classifier\", \"IntentResolutionStep\", \"-\"], [\"ce_output_schema\", \"SchemaExtractionStep\", \"-\"], [\"ce_prompt_template\", \"SchemaExtractionStep / ResponseResolutionStep\", \"-\"], [\"ce_rule\", \"RulesStep\", \"-\"], [\"ce_response\", \"ResponseResolutionStep\", \"-\"], [\"ce_config\", \"intent/reset/mcp/sql-agent config lookup\", \"-\"], [\"ce_audit\", \"-\", \"all stage audits via DbAuditService\"], ]} /> <Highlight type=\"info\" title=\"How to read this page\"> Start at IntentResolutionStep , then click SchemaExtractionStep and RulesStep in the tree. That path explains most multi-turn behavior differences. </Highlight>",
    "excerpt": ", , , , , , , , , , , , , , , , , , , , , , , , , ]; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ];…"
  },
  {
    "id": "deep-dive/rules-responses.mdx",
    "version": "v2",
    "title": "rules responses",
    "permalink": "/docs/v2/deep-dive/rules-responses",
    "content": "Rules and Response Resolution (v2) Rule phases ce_rule.phase in v2 supports: PIPELINE_RULES AGENT_POST_INTENT MCP_POST_LLM TOOL_POST_EXECUTION RulesStep now writes phase/source/origin metadata into input params and audit payload for every pass. Rule matching behavior For each pass: 1. fetch by phase + session state 2. check intent ( ANY /blank/null supported) 3. check state ( ANY /blank/null supported) 4. evaluate type resolver ( EXACT , REGEX , JSON_PATH ) 5. execute action resolver 6. rerun pass if intent/state changed (max pass cap) Audit emitted even when not matched ( RULE_NO_MATCH ) with explicit reason. Response resolution behavior ResponseResolutionStep : 1. selects response template by intent/state/priority 2. resolves output format 3. emits RESOLVE_RESPONSE audit stages 4. writes final payload ( EXACT or DERIVED ) v2 operational guidance keep UNKNOWN and ANY fallback responses to avoid hard failures keep at least one response for each terminal state use phase scoped rules instead of overloading one monolithic PIPELINE_RULES pass",
    "rawContent": "# Rules and Response Resolution (v2) ## Rule phases ce_rule.phase in v2 supports: - PIPELINE_RULES - AGENT_POST_INTENT - MCP_POST_LLM - TOOL_POST_EXECUTION RulesStep now writes phase/source/origin metadata into input params and audit payload for every pass. ## Rule matching behavior For each pass: 1. fetch by phase + session state 2. check intent ( ANY /blank/null supported) 3. check state ( ANY /blank/null supported) 4. evaluate type resolver ( EXACT , REGEX , JSON_PATH ) 5. execute action resolver 6. rerun pass if intent/state changed (max pass cap) Audit emitted even when not matched ( RULE_NO_MATCH ) with explicit reason. ## Response resolution behavior ResponseResolutionStep : 1. selects response template by intent/state/priority 2. resolves output format 3. emits RESOLVE_RESPONSE* audit stages 4. writes final payload ( EXACT or DERIVED ) ## v2 operational guidance - keep UNKNOWN and ANY fallback responses to avoid hard failures - keep at least one response for each terminal state - use phase-scoped rules instead of overloading one monolithic PIPELINE_RULES pass",
    "excerpt": "Rules and Response Resolution (v2) Rule phases ce_rule.phase in v2 supports: PIPELINE_RULES AGENT_POST_INTENT MCP_POST_LLM TOOL_POST_EXECUTION RulesStep now writes phase/source/origin metadata into input params and audit…"
  },
  {
    "id": "deep-dive/v2-features.mdx",
    "version": "v2",
    "title": "v2 features",
    "permalink": "/docs/v2/deep-dive/v2-features",
    "content": "ConvEngine v2 Features (Detailed) 1. DialogueActStep Adds configurable resolve mode via convengine.flow.dialogue act.resolute : REGEX_ONLY REGEX_THEN_LLM LLM_ONLY Fast path regex classification remains primary. LLM path used for ambiguity based on configured threshold. Emits: DIALOGUE_ACT_CLASSIFIED audit. 2. InteractionPolicyStep Policy matrix externalized in convengine.flow.interaction policy.matrix . Default safe matrix included. Output remains deterministic enums: EXECUTE_PENDING_ACTION REJECT_PENDING_ACTION FILL_PENDING_SLOT RECLASSIFY_INTENT Emits: INTERACTION_POLICY_DECIDED . 3. ActionLifecycleStep Runtime lifecycle stored in context pending_action_runtime . Status values: OPEN IN_PROGRESS EXECUTED REJECTED EXPIRED TTL by turns/time configurable via convengine.flow.action lifecycle. . Uses ce_pending_action as catalog only. Emits: PENDING_ACTION_LIFECYCLE . 4. ToolOrchestrationStep Unified tool contract: request ( tool_request ) execute result ( tool_result , tool_status ) Keeps DB executor path and adds group dispatch interfaces for: HTTP_API WORKFLOW_ACTION DOCUMENT_RETRIEVAL CALCULATOR_TRANSFORM NOTIFICATION FILES MCP tool eligibility is scoped by optional ce_mcp_tool.intent_code and ce_mcp_tool.state_code (with NULL as wildcard). Executes post tool rules with TOOL_POST_EXECUTION . 5. GuardrailStep Before tool/action execution: input sanitization sensitive action pattern checks approval gate hooks Outputs: allow/deny audit entries ( GUARDRAIL_ALLOW , GUARDRAIL_DENY ) skip flags for tool/pending action execution when denied 6. StateGraphStep (validate mode) Validates transition only, no forced mutation. Emits: STATE_GRAPH_VALID STATE_GRAPH_VIOLATION Can set optional soft block flag for downstream behavior. 7. DisambiguationStep When multiple pending actions eligible at same top priority: asks targeted clarification pauses execution cleanly Emits: DISAMBIGUATION_REQUIRED . 8. MemoryStep Writes session summary in context. Optional recall/write via pluggable ConversationMemoryStore adapter. Emits: MEMORY_UPDATED . 9. Eval/Trace framework ConversationReplayService replays conversations from input messages. Supports expectation assertions for intent/state regressions. 10. Consumer contract docs Consumer should configure behavior with data/config first: ce_rule ce_response ce_pending_action ce_mcp_tool convengine.flow. Avoid hardcoding conversational decisions in controller/service code.",
    "rawContent": "# ConvEngine v2 Features (Detailed) ## 1. DialogueActStep - Adds configurable resolve mode via convengine.flow.dialogue-act.resolute : - REGEX_ONLY - REGEX_THEN_LLM - LLM_ONLY - Fast-path regex classification remains primary. - LLM path used for ambiguity based on configured threshold. - Emits: DIALOGUE_ACT_CLASSIFIED audit. ## 2. InteractionPolicyStep - Policy matrix externalized in convengine.flow.interaction-policy.matrix . - Default safe matrix included. - Output remains deterministic enums: - EXECUTE_PENDING_ACTION - REJECT_PENDING_ACTION - FILL_PENDING_SLOT - RECLASSIFY_INTENT - Emits: INTERACTION_POLICY_DECIDED . ## 3. ActionLifecycleStep - Runtime lifecycle stored in context pending_action_runtime . - Status values: - OPEN - IN_PROGRESS - EXECUTED - REJECTED - EXPIRED - TTL by turns/time configurable via convengine.flow.action-lifecycle.* . - Uses ce_pending_action as catalog only. - Emits: PENDING_ACTION_LIFECYCLE . ## 4. ToolOrchestrationStep - Unified tool contract: - request ( tool_request ) - execute - result ( tool_result , tool_status ) - Keeps DB executor path and adds group dispatch interfaces for: - HTTP_API - WORKFLOW_ACTION - DOCUMENT_RETRIEVAL - CALCULATOR_TRANSFORM - NOTIFICATION - FILES - MCP tool eligibility is scoped by optional ce_mcp_tool.intent_code and ce_mcp_tool.state_code (with NULL as wildcard). - Executes post-tool rules with TOOL_POST_EXECUTION . ## 5. GuardrailStep Before tool/action execution: - input sanitization - sensitive action pattern checks - approval gate hooks Outputs: - allow/deny audit entries ( GUARDRAIL_ALLOW , GUARDRAIL_DENY ) - skip flags for tool/pending-action execution when denied ## 6. StateGraphStep (validate mode) - Validates transition only, no forced mutation. - Emits: - STATE_GRAPH_VALID - STATE_GRAPH_VIOLATION - Can set optional soft-block flag for downstream behavior. ## 7. DisambiguationStep - When multiple pending actions eligible at same top priority: - asks targeted clarification - pauses execution cleanly - Emits: DISAMBIGUATION_REQUIRED . ## 8. MemoryStep - Writes session summary in context. - Optional recall/write via pluggable ConversationMemoryStore adapter. - Emits: MEMORY_UPDATED . ## 9. Eval/Trace framework - ConversationReplayService replays conversations from input messages. - Supports expectation assertions for intent/state regressions. ## 10. Consumer contract docs Consumer should configure behavior with data/config first: - ce_rule - ce_response - ce_pending_action - ce_mcp_tool - convengine.flow.* Avoid hardcoding conversational decisions in controller/service code.",
    "excerpt": "ConvEngine v2 Features (Detailed) 1. DialogueActStep Adds configurable resolve mode via convengine.flow.dialogue act.resolute : REGEX_ONLY REGEX_THEN_LLM LLM_ONLY Fast path regex classification remains primary. LLM path …"
  },
  {
    "id": "examples.mdx",
    "version": "v2",
    "title": "examples",
    "permalink": "/docs/v2/examples",
    "content": "Examples (v2) 1. Mapper Studio publish/confirm flow Turn sequence: 1. Agent asks finalize confirmation. 2. User sends confirm / publish / generate excel / download excel . 3. DialogueActStep = AFFIRM . 4. InteractionPolicyStep = EXECUTE_PENDING_ACTION . 5. PendingActionStep executes mapped ce_pending_action task. 6. Rules move state (for example PUBLISHED ). 7. Response resolver returns publish confirmation payload. 2. Ambiguous action disambiguation If multiple actions are eligible with equal top priority: DisambiguationStep sets clarification question execution is paused safely no accidental action execution 3. Guarded sensitive action If sensitive pattern matched and approval is required but missing: GuardrailStep denies tool and pending action execution are skipped flow continues to safe response path with audit visibility 4. Tool orchestration flow When input includes tool_request : ToolOrchestrationStep dispatches by tool_group writes tool_result and tool_status executes TOOL_POST_EXECUTION rules 5. Zapper move connection flow 1. User: move connection city1 to city2. 2. Schema extraction identifies missing custId , phone , email . 3. Engine asks follow up for missing fields. 4. User provides values. 5. Engine asks confirmation. 6. User: ok / yes please / go ahead . 7. Policy resolves against pending action and executes move request task.",
    "rawContent": "# Examples (v2) ## 1. Mapper Studio publish/confirm flow Turn sequence: 1. Agent asks finalize confirmation. 2. User sends confirm / publish / generate excel / download excel . 3. DialogueActStep => AFFIRM . 4. InteractionPolicyStep => EXECUTE_PENDING_ACTION . 5. PendingActionStep executes mapped ce_pending_action task. 6. Rules move state (for example PUBLISHED ). 7. Response resolver returns publish confirmation payload. ## 2. Ambiguous action disambiguation If multiple actions are eligible with equal top priority: - DisambiguationStep sets clarification question - execution is paused safely - no accidental action execution ## 3. Guarded sensitive action If sensitive pattern matched and approval is required but missing: - GuardrailStep denies - tool and pending-action execution are skipped - flow continues to safe response path with audit visibility ## 4. Tool orchestration flow When input includes tool_request : - ToolOrchestrationStep dispatches by tool_group - writes tool_result and tool_status - executes TOOL_POST_EXECUTION rules ## 5. Zapper move-connection flow 1. User: move connection city1 to city2. 2. Schema extraction identifies missing custId , phone , email . 3. Engine asks follow-up for missing fields. 4. User provides values. 5. Engine asks confirmation. 6. User: ok / yes please / go ahead . 7. Policy resolves against pending action and executes move request task.",
    "excerpt": "Examples (v2) 1. Mapper Studio publish/confirm flow Turn sequence: 1. Agent asks finalize confirmation. 2. User sends confirm / publish / generate excel / download excel . 3. DialogueActStep = AFFIRM . 4. InteractionPoli…"
  },
  {
    "id": "faq.mdx",
    "version": "v2",
    "title": "faq",
    "permalink": "/docs/v2/faq",
    "content": "FAQ Is v1 still available? Yes. v1 docs are still available from the version dropdown. Use v2 docs for advanced and current features. How does v2 understand \"yes/ok/do that\"? Using DialogueActStep + InteractionPolicyStep + pending action context, not only intent keyword matching. Does StateGraphStep mutate state? No. Current v2 implementation is validate only; it audits validity and can set a soft block flag. Can I configure behavior without Java changes? Yes. Primary control should be through: ce_rule ce_response ce_pending_action ce_policy convengine.flow. How do we avoid 500s for conversational mismatches? keep fallback UNKNOWN / ANY rows use disambiguation and guardrail paths ensure response mappings exist for reachable states",
    "rawContent": "# FAQ ## Is v1 still available? Yes. v1 docs are still available from the version dropdown. Use v2 docs for advanced and current features. ## How does v2 understand \"yes/ok/do that\"? Using DialogueActStep + InteractionPolicyStep + pending-action context, not only intent keyword matching. ## Does StateGraphStep mutate state? No. Current v2 implementation is validate-only; it audits validity and can set a soft-block flag. ## Can I configure behavior without Java changes? Yes. Primary control should be through: - ce_rule - ce_response - ce_pending_action - ce_policy - convengine.flow.* ## How do we avoid 500s for conversational mismatches? - keep fallback UNKNOWN / ANY rows - use disambiguation and guardrail paths - ensure response mappings exist for reachable states",
    "excerpt": "FAQ Is v1 still available? Yes. v1 docs are still available from the version dropdown. Use v2 docs for advanced and current features. How does v2 understand \"yes/ok/do that\"? Using DialogueActStep + InteractionPolicyStep…"
  },
  {
    "id": "local-development.mdx",
    "version": "v2",
    "title": "local development",
    "permalink": "/docs/v2/local-development",
    "content": "Local Development Prerequisites Java 21 Spring compatible host app PostgreSQL + ConvEngine ce_ schema LlmClient implementation bean Minimal integration } } Required runtime beans from consumer side LlmClient datasource + JPA config any custom hooks/transformers you need Recommended local test loop 1. Send one turn to /message 2. Read /audit/ '} 3. Read /audit/ '}/trace 4. Tune DB rows and rerun same conversation id Transport toggles Keep SSE enabled initially. Use STOMP only when your client architecture needs bidirectional websocket semantics. Optional feature annotations } } With @EnableConvEngine(stream = true) (default), startup fails if both SSE and STOMP are disabled. With @EnableConvEngine(stream = false) , transport flags are ignored and only REST flow is active.",
    "rawContent": "# Local Development ## Prerequisites - Java 21 - Spring-compatible host app - PostgreSQL + ConvEngine <FileRef>ce_*</FileRef> schema - <MethodRef>LlmClient</MethodRef> implementation bean ## Minimal integration <CodeBlockToggle title=\"Enable ConvEngine\" language=\"java\" packagePath=\"your.app\" > { @EnableConvEngine @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> ## Required runtime beans from consumer side - <MethodRef>LlmClient</MethodRef> - datasource + JPA config - any custom hooks/transformers you need ## Recommended local test loop 1. Send one turn to <FileRef>/message</FileRef> 2. Read <FileRef>/audit/{'{conversationId}'}</FileRef> 3. Read <FileRef>/audit/{'{conversationId}'}/trace</FileRef> 4. Tune DB rows and rerun same conversation id ## Transport toggles <CodeBlockToggle title=\"application.yml\" language=\"yaml\"> { server: port: 8080 spring: datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd convengine: transport: sse: enabled: true or false emitter-timeout-ms: 1800000 stomp: enabled: true or false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 experimental: enabled: false } </CodeBlockToggle> <Highlight type=\"warning\" title=\"When enabling STOMP\"> Keep SSE enabled initially. Use STOMP only when your client architecture needs bidirectional websocket semantics. </Highlight> ## Optional feature annotations <CodeBlockToggle title=\"Enable optional performance features\" language=\"java\"> { @EnableConvEngine(stream = true) @EnableConvEngineAsyncAuditDispatch @EnableConvEngineStompBrokerRelay @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> <Highlight type=\"info\" title=\"Stream flag behavior\"> With <MethodRef>@EnableConvEngine(stream = true)</MethodRef> (default), startup fails if both SSE and STOMP are disabled. With <MethodRef>@EnableConvEngine(stream = false)</MethodRef>, transport flags are ignored and only REST flow is active. </Highlight>",
    "excerpt": "Local Development Prerequisites Java 21 Spring compatible host app PostgreSQL + ConvEngine ce_ schema LlmClient implementation bean Minimal integration } } Required runtime beans from consumer side LlmClient datasource +…"
  },
  {
    "id": "overview.mdx",
    "version": "v2",
    "title": "overview",
    "permalink": "/docs/v2/overview",
    "content": "ConvEngine v2 Overview ConvEngine v2 is a deterministic conversation workflow engine with explicit turn control steps for dialogue act, policy, pending action lifecycle, guardrails, tool orchestration, state graph validation, and memory. What v2 adds over v1 Turn understanding before intent re resolution: DialogueActStep InteractionPolicyStep Pending action runtime control: ActionLifecycleStep DisambiguationStep PendingActionStep Safety controls: GuardrailStep StateGraphStep (validate only) Tool runtime unification: ToolOrchestrationStep McpToolStep with executor per tool group Memory and replay: MemoryStep ConversationReplayService Rule phases expanded with post tool/post mcp execution: MCP_POST_LLM TOOL_POST_EXECUTION New control table: ce_pending_action Runtime model ConvEngine remains config first: DB control plane: ce_intent , ce_rule , ce_response , ce_prompt_template , ce_pending_action , ce_mcp_ Runtime policy config: convengine.flow. Deterministic pipeline with audited stage output Key outcomes Handles yes / ok / do that against pending context, not standalone intent. Avoids hidden state mutation by validating transitions ( StateGraphStep ) and auditing violations. Supports multiple tool groups ( DB , HTTP_API , WORKFLOW_ACTION , DOCUMENT_RETRIEVAL , CALCULATOR_TRANSFORM , NOTIFICATION , FILES ). Keeps every control decision visible in audit timeline. Next Reads",
    "rawContent": "# ConvEngine v2 Overview ConvEngine v2 is a deterministic conversation workflow engine with explicit turn-control steps for dialogue act, policy, pending-action lifecycle, guardrails, tool orchestration, state-graph validation, and memory. ## What v2 adds over v1 - Turn understanding before intent re-resolution: - DialogueActStep - InteractionPolicyStep - Pending action runtime control: - ActionLifecycleStep - DisambiguationStep - PendingActionStep - Safety controls: - GuardrailStep - StateGraphStep (validate-only) - Tool runtime unification: - ToolOrchestrationStep - McpToolStep with executor-per-tool-group - Memory and replay: - MemoryStep - ConversationReplayService - Rule phases expanded with post-tool/post-mcp execution: - MCP_POST_LLM - TOOL_POST_EXECUTION - New control table: - ce_pending_action ## Runtime model ConvEngine remains config-first: - DB control plane: ce_intent* , ce_rule , ce_response , ce_prompt_template , ce_pending_action , ce_mcp_* - Runtime policy config: convengine.flow.* - Deterministic pipeline with audited stage output ## Key outcomes - Handles yes / ok / do that against pending context, not standalone intent. - Avoids hidden state mutation by validating transitions ( StateGraphStep ) and auditing violations. - Supports multiple tool groups ( DB , HTTP_API , WORKFLOW_ACTION , DOCUMENT_RETRIEVAL , CALCULATOR_TRANSFORM , NOTIFICATION , FILES ). - Keeps every control decision visible in audit timeline. ## Next Reads - [Architecture](/docs/v2/architecture) - [Pipeline (Step-by-Step)](/docs/v2/deep-dive/pipeline-steps) - [Real World Examples (chat + DB + audit)](/docs/v2/deep-dive/examples) - [What’s New in v2](/docs/v2/deep-dive/v2-features) - [Version History](/docs/v2/version-history)",
    "excerpt": "ConvEngine v2 Overview ConvEngine v2 is a deterministic conversation workflow engine with explicit turn control steps for dialogue act, policy, pending action lifecycle, guardrails, tool orchestration, state graph valida…"
  },
  {
    "id": "version-history.mdx",
    "version": "v2",
    "title": "version history",
    "permalink": "/docs/v2/version-history",
    "content": "Version History 2.0.0 Major v2 runtime evolution focused on production grade turn control, tool orchestration, safety, and observability. Added new steps DialogueActStep InteractionPolicyStep ActionLifecycleStep DisambiguationStep GuardrailStep ToolOrchestrationStep StateGraphStep MemoryStep PendingActionStep enhanced for v2 policy/lifecycle integration Added new flow configuration model ConvEngineFlowConfig ( convengine.flow. ) dialogue act interaction policy matrix action lifecycle TTL disambiguation options guardrail controls state graph settings tool orchestration toggle memory summary settings Added new control table ce_pending_action action catalog for pending action execution indexed by action key/intent/state/priority Added new rule phases MCP_POST_LLM TOOL_POST_EXECUTION Added tool execution architecture McpToolExecutor interface group executors for: DB HTTP_API WORKFLOW_ACTION DOCUMENT_RETRIEVAL CALCULATOR_TRANSFORM NOTIFICATION FILES adapter interfaces for consumer implementations Added memory and replay scaffolding ConversationMemoryStore ConversationReplayService replay model classes ( Trace ) Added audit stage coverage Expanded audit visibility for: dialogue act and interaction policy pending action lifecycle and execution disambiguation requirements guardrail allow/deny tool orchestration request/result/error state graph validation/violation memory updates post phase rule metadata 1.x line Use the version dropdown to switch to v1 documentation.",
    "rawContent": "# Version History ## 2.0.0 Major v2 runtime evolution focused on production-grade turn control, tool orchestration, safety, and observability. ### Added new steps - DialogueActStep - InteractionPolicyStep - ActionLifecycleStep - DisambiguationStep - GuardrailStep - ToolOrchestrationStep - StateGraphStep - MemoryStep - PendingActionStep enhanced for v2 policy/lifecycle integration ### Added new flow configuration model - ConvEngineFlowConfig ( convengine.flow.* ) - dialogue act - interaction policy matrix - action lifecycle TTL - disambiguation options - guardrail controls - state graph settings - tool orchestration toggle - memory summary settings ### Added new control table - ce_pending_action - action catalog for pending-action execution - indexed by action key/intent/state/priority ### Added new rule phases - MCP_POST_LLM - TOOL_POST_EXECUTION ### Added tool execution architecture - McpToolExecutor interface - group executors for: - DB - HTTP_API - WORKFLOW_ACTION - DOCUMENT_RETRIEVAL - CALCULATOR_TRANSFORM - NOTIFICATION - FILES - adapter interfaces for consumer implementations ### Added memory and replay scaffolding - ConversationMemoryStore - ConversationReplayService - replay model classes ( Trace* ) ### Added audit stage coverage Expanded audit visibility for: - dialogue act and interaction policy - pending action lifecycle and execution - disambiguation requirements - guardrail allow/deny - tool orchestration request/result/error - state graph validation/violation - memory updates - post-phase rule metadata ## 1.x line Use the version dropdown to switch to v1 documentation.",
    "excerpt": "Version History 2.0.0 Major v2 runtime evolution focused on production grade turn control, tool orchestration, safety, and observability. Added new steps DialogueActStep InteractionPolicyStep ActionLifecycleStep Disambig…"
  }
]