---
title: Data Model
sidebar_position: 4
hide_table_of_contents: true
---

import { DbTable, CodeBlockToggle } from "@site/src/components/convengine";

# Data Model

ConvEngine is configuration-driven. Behavior is defined in the following tables.

## Configuration Tables

<DbTable
  title="Core Tables"
  columns={["Table", "Purpose", "Key Columns"]}
  rows={[
    ["ce_intent", "Defines business intents", "intent_code, description, enabled"],
    ["ce_intent_classifier", "Regex patterns for intents", "match_pattern, priority"],
    ["ce_rule", "Logic & State Transitions", "phase, state_code, rule_type, action, match_pattern"],
    ["ce_response", "Output mapping", "response_type, output_format, exact_text"],
    ["ce_output_schema", "Data extraction definition", "json_schema, priority"],
    ["ce_prompt_template", "LLM Prompts", "system_prompt, user_prompt"],
  ]}
/>

## Runtime Tables

<DbTable
  title="Runtime Persistence"
  columns={["Table", "Purpose"]}
  rows={[
    ["ce_conversation", "Current state of active conversations"],
    ["ce_audit", "Append-only log of every step execution"],
    ["ce_conversation_history", "Normalized user/AI turn history used for prompt history reconstruction"],
  ]}
/>

---

# Session API

When writing Java extensions (Interceptors, Transformers), you interact with `EngineSession`.

<CodeBlockToggle
  title="EngineSession.java (key methods)"
  language="java"
  packagePath="com.github.salilvnair.convengine.engine.session"
  filePath="src/main/java/com/github/salilvnair/convengine/engine/session/EngineSession.java"
>
{`// State Management
void setIntent(String intent);
void setState(String state);

// Extras/Input params used by steps, prompts and rules
Map<String, Object> getInputParams();
void putInputParam(String key, Object value);

// Persisted Entity
CeConversation getConversation();

// Flow Control
void setFinalResult(EngineResult result); // Stop pipeline immediately`}
</CodeBlockToggle>

## Common Operations

### Setting a Task (`SET_TASK` action)
Tasks are triggered through rule action resolution, not by writing arbitrary `task` keys in context.
Configure `ce_rule.action=SET_TASK` and map `action_value` to a Spring task bean method.

<CodeBlockToggle title="SET_TASK rule row" language="sql" packagePath="consumer DB">
{`INSERT INTO ce_rule
  (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description)
VALUES
  ('PIPELINE_RULES', 'REQUEST_TRACKER', 'ANY', 'REGEX', '(?i).*track.*request.*', 'SET_TASK', 'requestTrackerTask:loadStatus', 10, true,
   'Invoke consumer task bean during rule execution');`}
</CodeBlockToggle>

<CodeBlockToggle title="Consumer task bean method" language="java" packagePath="consumer logic">
{`@Component("requestTrackerTask")
public class RequestTrackerTask implements CeRuleTask {
  public void loadStatus(EngineSession session, CeRule rule) {
    // Populate context/input params for downstream response
    session.putInputParam("requestStatus", "IN_REVIEW");
  }
}`}
</CodeBlockToggle>

### Getting Extracted Data
Access data extracted by the Schema Extraction step.

<CodeBlockToggle title="Read extracted value" language="java" packagePath="consumer logic">
{`String accountId = (String) session.getInputParams().get("accountId");`}
</CodeBlockToggle>
