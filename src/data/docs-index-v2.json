[
  {
    "id": "api/audit-trace.mdx",
    "version": "v2",
    "title": "audit trace",
    "permalink": "/docs/v2/api/audit-trace",
    "content": "Audit Trace API Endpoint GET /api/v1/conversation/audit/ /trace Response shape ], \"stages\": [ } ] } } Why this endpoint exists separates timeline from raw audit payload parsing easier UI rendering for runbooks and debug tools complements ce_conversation_history , which stores normalized user/AI turns even when audit persistence runs deferred preserves both domain and technical stages Use both endpoints together: /audit/ for raw forensic payload, /audit/ /trace for step flow visualization.",
    "rawContent": "# Audit Trace API ## Endpoint GET /api/v1/conversation/audit/{conversationId}/trace ## Response shape <CodeBlockToggle title=\"Trace response\" language=\"json\" defaultOpen={true}> { { \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"steps\": [ { \"step\": \"IntentResolutionStep\", \"stepClass\": \"com.github.salilvnair.convengine.engine.steps.IntentResolutionStep\", \"status\": \"OK\", \"startedAt\": \"2026-02-14T10:22:01.102Z\", \"endedAt\": \"2026-02-14T10:22:01.147Z\", \"durationMs\": 45, \"error\": null, \"stages\": [] } ], \"stages\": [ { \"auditId\": 12031, \"stage\": \"STEP_ENTER\", \"createdAt\": \"2026-02-14T10:22:01.102Z\", \"payload\": { \"step\": \"IntentResolutionStep\" } } ] } } </CodeBlockToggle> ## Why this endpoint exists - separates timeline from raw audit payload parsing - easier UI rendering for runbooks and debug tools - complements ce_conversation_history , which stores normalized user/AI turns even when audit persistence runs deferred - preserves both domain and technical stages <Highlight type=\"tip\" title=\"Best practice\"> Use both endpoints together: /audit/{id} for raw forensic payload, /audit/{id}/trace for step-flow visualization. </Highlight>",
    "excerpt": "Audit Trace API Endpoint GET /api/v1/conversation/audit/ /trace Response shape ], \"stages\": [ } ] } } Why this endpoint exists separates timeline from raw audit payload parsing easier UI rendering for runbooks and debug …"
  },
  {
    "id": "api/java-api.mdx",
    "version": "v2",
    "title": "java api",
    "permalink": "/docs/v2/api/java-api",
    "content": "Java API (Core Contracts) Entry points } } } } } default void write(EngineSession session, String summary) } } Flow configuration API Extension contracts ResponseTransformerHandler ContainerDataTransformerHandler rule task execution pathway via SET_TASK pending action execution via CeTaskExecutor tool adapters through McpToolExecutor implementations",
    "rawContent": "# Java API (Core Contracts) ## Entry points <DbTable title=\"Primary interfaces\" columns={[\"Type\", \"Package\", \"Role\"]} rows={[ [\"ConversationalEngine\", \"engine.core\", \"Main process method\"], [\"LlmClient\", \"llm.core\", \"LLM adapter contract\"], [\"EngineStep\", \"engine.pipeline\", \"Step unit contract\"], [\"EngineStepHook\", \"engine.hook\", \"Step interception contract\"], [\"ConvEngineVerboseAdapter\", \"transport.verbose\", \"Consumer-facing verbose UI emission helper\"], [\"McpToolExecutor\", \"engine.mcp.executor\", \"Tool-group executor contract\"], [\"ConversationMemoryStore\", \"engine.memory\", \"Pluggable memory adapter\"], [\"CeTask\", \"engine.task\", \"Task contract for pending/rule execution\"], ]} /> <CodeBlockToggle title=\"ConversationalEngine\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.core\"> { public interface ConversationalEngine { EngineResult process(EngineContext engineContext); } } </CodeBlockToggle> <CodeBlockToggle title=\"LlmClient\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.llm.core\"> { public interface LlmClient { String generateText(String hint, String contextJson); String generateJson(String hint, String jsonSchema, String contextJson); float[] generateEmbedding(String input); } } </CodeBlockToggle> <CodeBlockToggle title=\"EngineStep.Name enum (current)\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\"> { public interface EngineStep { enum Name { AuditUserInputStep, CacheInspectAuditStep, DialogueActStep, InteractionPolicyStep, CorrectionStep, ActionLifecycleStep, DisambiguationStep, GuardrailStep, IntentResolutionStep, AddContainerDataStep, SchemaExtractionStep, PendingActionStep, ToolOrchestrationStep, StateGraphStep, ResponseResolutionStep, MemoryStep, AutoAdvanceStep, McpToolStep, LoadOrCreateConversationStep, FallbackIntentStateStep, PersistConversationBootstrapStep, ResetConversationStep, PersistConversationStep, PipelineEndGuardStep, ResetResolvedIntentStep, PolicyEnforcementStep, RulesStep, Unknown; } } } </CodeBlockToggle> <CodeBlockToggle title=\"McpToolExecutor\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.mcp.executor\"> { public interface McpToolExecutor { String toolGroup(); String execute(CeMcpTool tool, Map<String, Object> args, EngineSession session); } } </CodeBlockToggle> <CodeBlockToggle title=\"ConversationMemoryStore\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.memory\"> { public interface ConversationMemoryStore { default String read(EngineSession session) { return null; } default void write(EngineSession session, String summary) {} } } </CodeBlockToggle> ## Flow configuration API <DbTable title=\"Configuration classes\" columns={[\"Class\", \"Purpose\"]} rows={[ [\"ConvEngineFlowConfig\", \"Runtime controls for dialogue/policy/lifecycle/guardrail/tool/stategraph/disambiguation/memory\"], [\"ConvEngineEntityConfig\", \"Dynamic table name mapping via convengine.tables\"], [\"ConvEngineAuditConfig\", \"Audit behavior controls\"], ]} /> ## Extension contracts - <MethodRef>ResponseTransformerHandler</MethodRef> - <MethodRef>ContainerDataTransformerHandler</MethodRef> - rule task execution pathway via <MethodRef>SET_TASK</MethodRef> - pending action execution via CeTaskExecutor - tool adapters through McpToolExecutor implementations",
    "excerpt": "Java API (Core Contracts) Entry points } } } } } default void write(EngineSession session, String summary) } } Flow configuration API Extension contracts ResponseTransformerHandler ContainerDataTransformerHandler rule ta…"
  },
  {
    "id": "api/rest-api.mdx",
    "version": "v2",
    "title": "rest api",
    "permalink": "/docs/v2/api/rest-api",
    "content": "REST API Base /api/v1/conversation Endpoints POST /message } } , \"context\": \" \" } } Experimental endpoint (feature flagged) Base: /api/v1/conversation/experimental POST /generate sql Enable with: } ' } } generate sql is designed for non transactional configuration tables ( ce_config , ce_intent , ce_rule , ce_prompt_template , ce_response , ce_output_schema , ce_container_config , optional MCP tables). It does not generate runtime conversation/audit data. Generated SQL should be reviewed before use. The endpoint applies safety checks but does not replace human review.",
    "rawContent": "# REST API ## Base <FileRef>/api/v1/conversation</FileRef> ## Endpoints <DbTable title=\"Conversation endpoints\" columns={[\"Method\", \"Path\", \"Purpose\"]} rows={[ [\"POST\", \"/message\", \"Process one turn and return payload\"], [\"GET\", \"/audit/{conversationId}\", \"Raw audit rows for conversation\"], [\"GET\", \"/audit/{conversationId}/trace\", \"Normalized step+stage timeline\"], [\"GET\", \"/cache/refresh\", \"Evicts static configs memory tree ( ce_static_configs ) and triggers a Spring DB pre-loader to dynamically swap framework configuration\"] ]} /> ## POST <FileRef>/message</FileRef> <CodeBlockToggle title=\"Request body\" language=\"json\" defaultOpen={true}> { { \"conversationId\": \"uuid-optional\", \"message\": \"Track request REQ-778102\", \"reset\": false, \"inputParams\": { \"tenant\": \"acme\" } } } </CodeBlockToggle> <CodeBlockToggle title=\"Success response\" language=\"json\" defaultOpen={true}> { { \"success\": true, \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"intent\": \"REQUEST_TRACKER\", \"state\": \"IDLE\", \"payload\": { \"type\": \"TEXT\", \"value\": \"Request REQ-778102 is IN_REVIEW.\" }, \"context\": \"{...}\" } } </CodeBlockToggle> ## Experimental endpoint (feature-flagged) Base: <FileRef>/api/v1/conversation/experimental</FileRef> - <MethodRef>POST /generate-sql</MethodRef> Enable with: <CodeBlockToggle title=\"application.yml (feature flag)\" language=\"yaml\"> { convengine: experimental: enabled: true } </CodeBlockToggle> <Tabs groupId=\"experimental-generate-sql\"> <TabItem value=\"postman\" label=\"Postman\" default> <DbTable title=\"Postman setup\" columns={[\"Field\", \"Value\"]} rows={[ [\"Method\", \"POST\"], [\"URL\", \"http://localhost:8080/api/v1/conversation/experimental/generate-sql\"], [\"Headers\", \"Content-Type: application/json\"], [\"Body Mode\", \"raw (JSON)\"], ]} /> <CodeBlockToggle title=\"Postman body (JSON)\" language=\"json\"> { { \"scenario\": \"Build disconnect electricity workflow\", \"domain\": \"utilities\", \"constraints\": \"Collect account number before action\", \"includeMcp\": true } } </CodeBlockToggle> </TabItem> <TabItem value=\"curl\" label=\"curl\"> <CodeBlockToggle title=\"curl request\" language=\"bash\"> { curl -X POST \"http://localhost:8080/api/v1/conversation/experimental/generate-sql\" \\\\ -H \"Content-Type: application/json\" \\\\ -d '{ \"scenario\": \"Build disconnect electricity workflow\", \"domain\": \"utilities\", \"constraints\": \"Collect account number before action\", \"includeMcp\": true }' } </CodeBlockToggle> </TabItem> </Tabs> <CodeBlockToggle title=\"/experimental/generate-sql success response\" language=\"json\"> { { \"success\": true, \"sql\": \"INSERT INTO ce_config ...;\\\\nINSERT INTO ce_intent ...;\", \"warnings\": [], \"note\": \"Experimental output: review before applying in production.\" } } </CodeBlockToggle> <Highlight type=\"info\" title=\"Generation scope\"> generate-sql is designed for non-transactional configuration tables ( ce_config , ce_intent , ce_rule , ce_prompt_template , ce_response , ce_output_schema , ce_container_config , optional MCP tables). It does not generate runtime conversation/audit data. </Highlight> <Highlight type=\"warning\" title=\"Experimental output\"> Generated SQL should be reviewed before use. The endpoint applies safety checks but does not replace human review. </Highlight>",
    "excerpt": "REST API Base /api/v1/conversation Endpoints POST /message } } , \"context\": \" \" } } Experimental endpoint (feature flagged) Base: /api/v1/conversation/experimental POST /generate sql Enable with: } ' } } generate sql is …"
  },
  {
    "id": "api/stream-api.mdx",
    "version": "v2",
    "title": "stream api",
    "permalink": "/docs/v2/api/stream-api",
    "content": "Stream API (Socket) Base transport endpoints Conversation turns are submitted through POST /api/v1/conversation/message . Socket/SSE channels stream audit stages for that same conversationId . SSE subscription ; source.addEventListener(\"STEP_ENTER\", (event) = ); source.addEventListener(\"ASSISTANT_OUTPUT\", (event) = ); source.addEventListener(\"VERBOSE\", (event) = ); } STOMP subscription , }); client.activate(); } Socket payload contract (v2.0.8) 2.0.8 introduces envelope type separation in the stream payload. eventType: \"AUDIT\" for audit stage events eventType: \"VERBOSE\" for verbose runtime progress/error events }, \"verbose\": null } } }, \"verbose\": } } Socket + Audit API usage 1. Call POST /api/v1/conversation/message with conversationId . 2. Subscribe to SSE/STOMP for live stages. 3. Query GET /api/v1/conversation/audit/ '} for raw events. 4. Query GET /api/v1/conversation/audit/ '}/trace for normalized step timeline. Use REST endpoints for deterministic request/response behavior, and use streaming endpoints for observability UX.",
    "rawContent": "# Stream API (Socket) ## Base transport endpoints <DbTable title=\"Streaming endpoints\" columns={[\"Transport\", \"Endpoint / Destination\", \"Purpose\"]} rows={[ [\"SSE\", \"GET /api/v1/conversation/stream/{conversationId}\", \"Server-sent live audit events for one conversation\"], [\"STOMP WS\", \"WS handshake: /ws-convengine\", \"WebSocket endpoint for STOMP clients\"], [\"STOMP topic\", \"/topic/convengine/audit/{conversationId}\", \"Conversation-scoped audit stream destination\"], ]} /> <Highlight type=\"info\" title=\"Flow contract\"> Conversation turns are submitted through <MethodRef>POST /api/v1/conversation/message</MethodRef>. Socket/SSE channels stream audit stages for that same <MethodRef>conversationId</MethodRef>. </Highlight> ## SSE subscription <CodeBlockToggle title=\"SSE client (browser)\" language=\"javascript\"> { const conversationId = \"9bf7540a-b129-4685-a120-730e8a0cb94b\"; const source = new EventSource( \"/api/v1/conversation/stream/\" + conversationId ); source.onmessage = (event) => { // fallback event channel console.log(\"SSE message:\", event.data); }; source.addEventListener(\"STEP_ENTER\", (event) => { console.log(\"STEP_ENTER:\", JSON.parse(event.data)); }); source.addEventListener(\"ASSISTANT_OUTPUT\", (event) => { console.log(\"ASSISTANT_OUTPUT:\", JSON.parse(event.data)); }); source.addEventListener(\"VERBOSE\", (event) => { console.log(\"VERBOSE:\", JSON.parse(event.data)); }); } </CodeBlockToggle> ## STOMP subscription <CodeBlockToggle title=\"STOMP client (JS)\" language=\"javascript\"> { // npm i @stomp/stompjs sockjs-client const conversationId = \"9bf7540a-b129-4685-a120-730e8a0cb94b\"; const client = new Client({ webSocketFactory: () => new SockJS(\"/ws-convengine\"), reconnectDelay: 5000, onConnect: () => { client.subscribe( \"/topic/convengine/audit/\" + conversationId, (message) => console.log(\"STOMP audit:\", JSON.parse(message.body)) ); }, }); client.activate(); } </CodeBlockToggle> ## Socket payload contract (v2.0.8) 2.0.8 introduces envelope type separation in the stream payload. - eventType: \"AUDIT\" for audit stage events - eventType: \"VERBOSE\" for verbose runtime progress/error events <CodeBlockToggle title=\"AUDIT envelope example\" language=\"json\"> { { \"eventType\": \"AUDIT\", \"auditId\": 12031, \"stage\": \"STEP_ENTER\", \"createdAt\": \"2026-02-14T10:22:01.102Z\", \"payload\": { \"_meta\": { \"stage\": \"STEP_ENTER\", \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"intent\": \"FAQ\", \"state\": \"IDLE\" } }, \"verbose\": null } } </CodeBlockToggle> <CodeBlockToggle title=\"VERBOSE envelope example\" language=\"json\"> { { \"eventType\": \"VERBOSE\", \"auditId\": null, \"stage\": \"VERBOSE\", \"createdAt\": \"2026-02-27T13:40:24.250Z\", \"payload\": { \"verbose\": { \"verboseId\": 4, \"eventType\": \"VERBOSE_PROGRESS\", \"stepName\": \"McpToolStep\", \"determinant\": \"MCP_TOOL_CALL\", \"intent\": \"LOAN_APPLICATION\", \"state\": \"COLLECTING_DETAILS\", \"ruleId\": null, \"toolCode\": \"loan.credit.rating.check\", \"level\": \"INFO\", \"text\": \"Checking credit rating from credit union.\" } }, \"verbose\": { \"verboseId\": 4, \"eventType\": \"VERBOSE_PROGRESS\", \"stepName\": \"McpToolStep\", \"determinant\": \"MCP_TOOL_CALL\", \"level\": \"INFO\", \"text\": \"Checking credit rating from credit union.\" } } } </CodeBlockToggle> ## Socket + Audit API usage 1. Call <FileRef>POST /api/v1/conversation/message</FileRef> with conversationId . 2. Subscribe to SSE/STOMP for live stages. 3. Query <FileRef>GET /api/v1/conversation/audit/{'{conversationId}'}</FileRef> for raw events. 4. Query <FileRef>GET /api/v1/conversation/audit/{'{conversationId}'}/trace</FileRef> for normalized step timeline. <Highlight type=\"tip\" title=\"Operational recommendation\"> Use REST endpoints for deterministic request/response behavior, and use streaming endpoints for observability UX. </Highlight>",
    "excerpt": "Stream API (Socket) Base transport endpoints Conversation turns are submitted through POST /api/v1/conversation/message . Socket/SSE channels stream audit stages for that same conversationId . SSE subscription ; source.a…"
  },
  {
    "id": "architecture.mdx",
    "version": "v2",
    "title": "architecture",
    "permalink": "/docs/v2/architecture",
    "content": "Architecture Layers API + Transport Layer ConversationController request ingress + validation + correlation ids SSE / STOMP event transport for audit streams Runtime Pipeline Layer DefaultConversationalEngine EnginePipelineFactory (DAG sort + wrappers + timing + step hooks) EngineSession (per turn mutable state) Decision + Control Layer dialogue act: DialogueActStep policy: InteractionPolicyStep correction routing: CorrectionStep pending action lifecycle: ActionLifecycleStep , DisambiguationStep , PendingActionStep guard + transition validation: GuardrailStep , StateGraphStep core intent/schema/rules/response path Tooling Layer ToolOrchestrationStep (unified tool request/execute/result contract) McpToolStep (planner loop + CALL_TOOL / ANSWER ) Persistence + Audit Layer JPA repositories on ce_ ce_conversation , ce_audit , ce_memory write path Request Path (high level) Builds EngineContext from conversationId , message , inputParams , optional reset flag. EngineSessionFactory creates session and history provider injects last turns. Dialogue act + interaction policy + correction routing + pending action lifecycle decide whether to execute task, clarify, confirm, patch, or continue standard intent flow. Intent/schema/rules/response steps produce deterministic state transition + assistant payload. Final payload is persisted and returned as TEXT/JSON response, with full audit trail. Code references } } } :::tip Intervention point You can intercept any step via EngineStepHook ( beforeStep , afterStep , onStepError ) without forking the engine. ::: Rules execute by phase: PRE_RESPONSE_RESOLUTION , POST_AGENT_INTENT , POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP , POST_AGENT_MCP , and POST_TOOL_EXECUTION . Keep business transitions in ce_rule and state graph config, not hardcoded in steps, so behavior remains data driven and auditable.",
    "rawContent": "# Architecture ## Layers ### API + Transport Layer - <MethodRef>ConversationController</MethodRef> - request ingress + validation + correlation ids - SSE / STOMP event transport for audit streams ### Runtime Pipeline Layer - <MethodRef>DefaultConversationalEngine</MethodRef> - <MethodRef>EnginePipelineFactory</MethodRef> (DAG sort + wrappers + timing + step hooks) - <MethodRef>EngineSession</MethodRef> (per-turn mutable state) ### Decision + Control Layer - dialogue act: <MethodRef>DialogueActStep</MethodRef> - policy: <MethodRef>InteractionPolicyStep</MethodRef> - correction routing: <MethodRef>CorrectionStep</MethodRef> - pending action lifecycle: <MethodRef>ActionLifecycleStep</MethodRef>, <MethodRef>DisambiguationStep</MethodRef>, <MethodRef>PendingActionStep</MethodRef> - guard + transition validation: <MethodRef>GuardrailStep</MethodRef>, <MethodRef>StateGraphStep</MethodRef> - core intent/schema/rules/response path ### Tooling Layer - <MethodRef>ToolOrchestrationStep</MethodRef> (unified tool request/execute/result contract) - <MethodRef>McpToolStep</MethodRef> (planner loop + CALL_TOOL / ANSWER ) ### Persistence + Audit Layer - JPA repositories on <FileRef>ce_*</FileRef> - <FileRef>ce_conversation</FileRef>, <FileRef>ce_audit</FileRef>, <FileRef>ce_memory</FileRef> write path ## Request Path (high-level) <FlowStep step=\"1\" title=\"Controller receives request\"> Builds <MethodRef>EngineContext</MethodRef> from <MethodRef>conversationId</MethodRef>, <MethodRef>message</MethodRef>, <MethodRef>inputParams</MethodRef>, optional <MethodRef>reset</MethodRef> flag. </FlowStep> <FlowStep step=\"2\" title=\"Engine opens session\"> <MethodRef>EngineSessionFactory</MethodRef> creates session and history provider injects last turns. </FlowStep> <FlowStep step=\"3\" title=\"Control steps run\"> Dialogue act + interaction policy + correction routing + pending-action lifecycle decide whether to execute task, clarify, confirm, patch, or continue standard intent flow. </FlowStep> <FlowStep step=\"4\" title=\"Core flow resolves output\"> Intent/schema/rules/response steps produce deterministic state transition + assistant payload. </FlowStep> <FlowStep step=\"5\" title=\"Persist + return result\"> Final payload is persisted and returned as TEXT/JSON response, with full audit trail. </FlowStep> ## Code references <CodeBlockToggle title=\"Engine entrypoint\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" > { @Override public EngineResult process(EngineContext engineContext) { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } } </CodeBlockToggle> <CodeBlockToggle title=\"Pipeline execution loop\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java\" > { for (EngineStep step : steps) { StepResult r = step.execute(session); if (r instanceof StepResult.Stop(EngineResult result)) { return result; } } } </CodeBlockToggle> :::tip Intervention point You can intercept any step via <MethodRef>EngineStepHook</MethodRef> (<MethodRef>beforeStep</MethodRef>, <MethodRef>afterStep</MethodRef>, <MethodRef>onStepError</MethodRef>) without forking the engine. ::: <Highlight type=\"info\" title=\"Control phases\"> Rules execute by phase: <MethodRef>PRE_RESPONSE_RESOLUTION</MethodRef>, <MethodRef>POST_AGENT_INTENT</MethodRef>, <MethodRef>POST_SCHEMA_EXTRACTION</MethodRef>, <MethodRef>PRE_AGENT_MCP</MethodRef>, <MethodRef>POST_AGENT_MCP</MethodRef>, and <MethodRef>POST_TOOL_EXECUTION</MethodRef>. </Highlight> <Highlight type=\"warning\" title=\"Deterministic boundary\"> Keep business transitions in <FileRef>ce_rule</FileRef> and state graph config, not hardcoded in steps, so behavior remains data-driven and auditable. </Highlight>",
    "excerpt": "Architecture Layers API + Transport Layer ConversationController request ingress + validation + correlation ids SSE / STOMP event transport for audit streams Runtime Pipeline Layer DefaultConversationalEngine EnginePipel…"
  },
  {
    "id": "consumer/annotations-reference.mdx",
    "version": "v2",
    "title": "annotations reference",
    "permalink": "/docs/v2/consumer/annotations-reference",
    "content": "Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. Consumer entry annotations } } } stream is an annotation parameter on @EnableConvEngine , not a YAML key. Keep it aligned with convengine.transport.sse.enabled and convengine.transport.stomp.enabled . Extension annotations (consumer customization) } } } } @Override public ContainerComponentResponse intercept(ContainerComponentResponse response, EngineSession session) } } If a class uses @ResponseTransformer or @ContainerDataTransformer but does not implement the required handler interface, startup fails. Internal pipeline annotations (advanced / framework contributors) } } Pipeline requires exactly one @ConversationBootstrapStep and one @TerminalStep . Misuse can break startup DAG validation. Quick recommendations for consumers 1. Use @EnableConvEngine , @EnableConvEngineCaching , and @EnableConvEngineAsyncConversation initially for zero latency pipelines. 2. Add @ResponseTransformer or container annotations only when you have a concrete customization need. 3. Avoid pipeline DAG annotations unless you are intentionally adding custom engine steps and can test full ordering. 4. Keep annotation usage paired with integration tests for one real conversation flow. See , , and for end to end integration context.",
    "rawContent": "# Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. ## Consumer entry annotations <DbTable title=\"Use these in your consumer app\" columns={[\"Annotation\", \"Target\", \"Purpose\", \"Typical usage\"]} rows={[ [\" @EnableConvEngine(stream = true|false) \", \"Spring Boot app class\", \"Bootstraps ConvEngine auto-configuration and stream setting.\", \"Always required to activate framework.\"], [\" @EnableConvEngineCaching \", \"Spring Boot app class\", \"Hooks ConvEngine's pipeline to Spring's CacheManager to intercept slow relational DB saves.\", \"Apply to resolve conversation I/O latency.\"], [\" @EnableConvEngineAsyncConversation \", \"Spring Boot app class\", \"Ties ConvEngine into Spring's thread pools for asynchronous background tasks.\", \"Apply alongside caching.\"], [\" @EnableConvEngineAsyncAuditDispatch \", \"Spring config/app class\", \"Forces async audit dispatch marker mode.\", \"Use when you intentionally want async listener dispatch.\"], [\" @EnableConvEngineStompBrokerRelay \", \"Spring config/app class\", \"Forces STOMP broker relay marker mode.\", \"Use when deploying with external STOMP broker relay.\"], ]} /> <CodeBlockToggle title=\"Basic enablement\" language=\"java\"> { @SpringBootApplication @EnableConvEngine(stream = true) @EnableConvEngineCaching @EnableConvEngineAsyncConversation public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> <CodeBlockToggle title=\"Optional relay + async markers\" language=\"java\"> { @Configuration @EnableConvEngineAsyncAuditDispatch @EnableConvEngineStompBrokerRelay public class ConvEngineFeatureFlags { } } </CodeBlockToggle> <Highlight type=\"info\" title=\"How stream mode works\"> stream is an annotation parameter on @EnableConvEngine , not a YAML key. Keep it aligned with convengine.transport.sse.enabled and convengine.transport.stomp.enabled . </Highlight> ## Extension annotations (consumer customization) <DbTable title=\"Extension points\" columns={[\"Annotation\", \"Must implement\", \"Purpose\", \"Key parameters\"]} rows={[ [\" @ResponseTransformer \", \" ResponseTransformerHandler \", \"Last-mile payload shaping by intent/state.\", \" intent , state \"], [\" @ContainerDataTransformer \", \" ContainerDataTransformerHandler \", \"Transforms CCF container data before session attach.\", \" intent , state \"], [\" @ContainerDataInterceptor \", \" ContainerDataRequestInterceptor and/or ContainerDataResponseInterceptor \", \"Intercepts CCF request/response around execution.\", \" intent , state , order \"], ]} /> <CodeBlockToggle title=\"Response transformer example\" language=\"java\"> { @Component @ResponseTransformer(intent = \"REQUEST_TRACKER\", state = \"IDLE\") public class TrackerResponseTransformer implements ResponseTransformerHandler { @Override public OutputPayload transform(OutputPayload responsePayload, EngineSession session, Map<String, Object> inputParams) { return responsePayload; } } } </CodeBlockToggle> <CodeBlockToggle title=\"Container transformer example\" language=\"java\"> { @Component @ContainerDataTransformer(intent = \"DISCONNECT_ELECTRICITY\", state = \"COLLECTING\") public class DisconnectContainerTransformer implements ContainerDataTransformerHandler { @Override public Map<String, Object> transform(ContainerComponentResponse response, EngineSession session, Map<String, Object> inputParams) { return Map.of(\"normalized\", response); } } } </CodeBlockToggle> <CodeBlockToggle title=\"Container interceptor example\" language=\"java\"> { @Component @ContainerDataInterceptor(intent = \"*\", state = \"*\", order = 10) public class TraceContainerInterceptor implements ContainerDataRequestInterceptor, ContainerDataResponseInterceptor { @Override public void intercept(ContainerComponentRequest request, EngineSession session) { // mutate request if needed } @Override public ContainerComponentResponse intercept(ContainerComponentResponse response, EngineSession session) { return response; } } } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Transformer/interceptor registration rules\"> If a class uses @ResponseTransformer or @ContainerDataTransformer but does not implement the required handler interface, startup fails. </Highlight> ## Internal pipeline annotations (advanced / framework contributors) <DbTable title=\"Engine DAG annotations\" columns={[\"Annotation\", \"Role\", \"Who should use it\"]} rows={[ [\" @MustRunAfter(...) \", \"Declares DAG dependency: step runs after listed steps.\", \"Framework contributors adding new EngineStep beans.\"], [\" @MustRunBefore(...) \", \"Declares DAG dependency: step runs before listed steps.\", \"Framework contributors adding new EngineStep beans.\"], [\" @RequiresConversationPersisted \", \"Forces ordering after bootstrap persistence step.\", \"Framework/internal step authors.\"], [\" @ConversationBootstrapStep \", \"Marks the single bootstrap step in pipeline.\", \"Framework internals only.\"], [\" @TerminalStep \", \"Marks the single terminal step in pipeline.\", \"Framework internals only.\"], [\" @PromptVar \", \"Maps fields in internal prompt context models to template aliases.\", \"Framework internals only; not for consumer app classes.\"], ]} /> <CodeBlockToggle title=\"Custom step with ordering\" language=\"java\"> { @Component @RequiresConversationPersisted @MustRunAfter(IntentResolutionStep.class) @MustRunBefore(ResponseResolutionStep.class) public class CustomValidationStep implements EngineStep { @Override public StepResult execute(EngineSession session) { return new StepResult.Continue(); } } } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Important constraints\"> Pipeline requires exactly one @ConversationBootstrapStep and one @TerminalStep . Misuse can break startup DAG validation. </Highlight> ## Quick recommendations for consumers 1. Use @EnableConvEngine , @EnableConvEngineCaching , and @EnableConvEngineAsyncConversation initially for zero-latency pipelines. 2. Add @ResponseTransformer or container annotations only when you have a concrete customization need. 3. Avoid pipeline DAG annotations unless you are intentionally adding custom engine steps and can test full ordering. 4. Keep annotation usage paired with integration tests for one real conversation flow. <Highlight type=\"info\" title=\"Related pages\"> See [Consumer Guide](/docs/v2/consumer/), [New Consumer Onboarding](/docs/v2/consumer/new-consumer-onboarding), and [Extensions](/docs/v2/consumer/extensions) for end-to-end integration context. </Highlight>",
    "excerpt": "Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. Consumer entry annotations } } } stream is an annotation parameter on @EnableConvEngine , not …"
  },
  {
    "id": "consumer/backend-integration.mdx",
    "version": "v2",
    "title": "backend integration",
    "permalink": "/docs/v2/consumer/backend-integration",
    "content": "Backend Integration This page uses your demo repos directly: backend reference: convengine demo UI reference: zapper ui What each demo proves convengine demo : Spring Boot consumer setup, transport mode config, step hooks, LLM wiring. zapper ui : conversation client, SSE subscription, audit timeline UI. Add @EnableConvEngine and provide required beans. Use profile yaml ( sse , stomp , both ) to switch runtime behavior. Frontend posts to message endpoint and listens to SSE/STOMP for audit updates. convengine demo: Core app bootstrap ) @EntityScan(basePackages = ) @EnableJpaRepositories(basePackages = ) public class ConvengineDemoApplication } } @Bean public ObjectMapper objectMapper() } } convengine demo: Runtime config model: gpt 4.1 base url: https://api.openai.com lmstudio: api key: \\$ model: openai/gpt oss 20b base url: http://localhost:1234 transport: sse: enabled: true emitter timeout ms: 1800000 stomp: enabled: false endpoint: /ws convengine app destination prefix: /app topic prefix: /topic audit destination base: /topic/convengine/audit allowed origin pattern: \" \" sock js: true broker: mode: SIMPLE relay destination prefixes: /topic,/queue relay host: localhost relay port: 61613 client login: \"\" client passcode: \"\" system login: \"\" system passcode: \"\" virtual host: \"\" system heartbeat send interval ms: 10000 system heartbeat receive interval ms: 10000 audit: enabled: true level: ALL include stages: [] exclude stages: [] persistence: mode: IMMEDIATE jdbc batch size: 200 max buffered events: 5000 flush stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final step names: PipelineEndGuardStep flush on stop outcome: true dispatch: async enabled: false worker threads: 2 queue capacity: 2000 rejection policy: CALLER_RUNS keep alive seconds: 60 rate limit: enabled: false max events: 200 window ms: 1000 per conversation: true per stage: true max tracked buckets: 20000 } Keep broker.mode: SIMPLE and audit.dispatch.async enabled: false for baseline. Enable relay and async in non prod first, then tune queue capacity , rejection policy , and rate limit using audit volume. convengine demo: Transport + Hook diagnostics public static class StepHook } } } } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) @Override public void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) @Override public void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) } } zapper ui: How frontend consumes backend ); return () = stream.close(); }, [conversationId]); } ]); // Typing indicator shown while request is in flight } 1. Start backend ( convengine demo ) with profile sse , stomp , or both . 2. Start zapper ui and point API base to backend URL. 3. Send message, verify live timeline from stream + detailed payloads from audit API.",
    "rawContent": "# Backend Integration This page uses your demo repos directly: - backend reference: <FileRef>convengine-demo</FileRef> - UI reference: <FileRef>zapper-ui</FileRef> ## What each demo proves - <FileRef>convengine-demo</FileRef>: Spring Boot consumer setup, transport mode config, step hooks, LLM wiring. - <FileRef>zapper-ui</FileRef>: conversation client, SSE subscription, audit timeline UI. <FlowStep step=\"1\" title=\"Enable ConvEngine in backend\"> Add <MethodRef>@EnableConvEngine</MethodRef> and provide required beans. </FlowStep> <FlowStep step=\"2\" title=\"Configure transport mode\"> Use profile yaml ( sse , stomp , both ) to switch runtime behavior. </FlowStep> <FlowStep step=\"3\" title=\"Connect frontend\"> Frontend posts to message endpoint and listens to SSE/STOMP for audit updates. </FlowStep> ## convengine-demo: Core app bootstrap <CodeBlockToggle title=\"ConvengineDemoApplication.java\" language=\"java\" packagePath=\"com.github.salilvnair\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/ConvengineDemoApplication.java\" > { @SpringBootApplication @ComponentScan(basePackages = {\"com.github.salilvnair.convengdemo\"}) @EntityScan(basePackages = {\"com.github.salilvnair.convengdemo.entity\"}) @EnableJpaRepositories(basePackages = {\"com.github.salilvnair.convengdemo.repo\"}) public class ConvengineDemoApplication { public static void main(String[] args) { SpringApplication.run(ConvengineDemoApplication.class, args); } } } </CodeBlockToggle> <CodeBlockToggle title=\"ConvEngineConfig.java\" language=\"java\" packagePath=\"com.github.salilvnair.convengdemo.config\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/ConvEngineConfig.java\" > { @Configuration @EnableConvEngine @EnableConvEngineAsyncAuditDispatch // optional @EnableConvEngineStompBrokerRelay // optional @EnableCcfCore public class ConvEngineConfig { @Bean public RestWebServiceFacade restWebServiceFacade() { return new RestWebServiceFacade(); } @Bean public ObjectMapper objectMapper() { return new ObjectMapper(); } } } </CodeBlockToggle> ## convengine-demo: Runtime config <CodeBlockToggle title=\"application.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application.yml\" > { server: port: 8080 spring: datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd convengine: demo: stream-mode: SSE step-hook: enabled: true tables: AUDIT: CE_AUDIT CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_PLANNER: CE_MCP_PLANNER MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE llm: provider: openai temperature: 0.3 openai: api-key: \\${OPENAI_API_KEY\\} model: gpt-4.1 base-url: https://api.openai.com lmstudio: api-key: \\${LMSTUDIO_API_KEY\\} model: openai/gpt-oss-20b base-url: http://localhost:1234 transport: sse: enabled: true emitter-timeout-ms: 1800000 stomp: enabled: false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 } </CodeBlockToggle> <CodeBlockToggle title=\"application-sse.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-sse.yml\"> { convengine: demo: stream-mode: SSE transport: sse: enabled: true stomp: enabled: false } </CodeBlockToggle> <CodeBlockToggle title=\"application-stomp.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-stomp.yml\"> { convengine: demo: stream-mode: STOMP transport: sse: enabled: false stomp: enabled: true } </CodeBlockToggle> <CodeBlockToggle title=\"application-both.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-both.yml\"> { convengine: demo: stream-mode: BOTH transport: sse: enabled: true stomp: enabled: true } </CodeBlockToggle> <Highlight type=\"tip\" title=\"Relay + async audit rollout\"> Keep broker.mode: SIMPLE and audit.dispatch.async-enabled: false for baseline. Enable relay and async in non-prod first, then tune queue-capacity , rejection-policy , and rate-limit using audit volume. </Highlight> ## convengine-demo: Transport + Hook diagnostics <CodeBlockToggle title=\"DemoTransportProperties.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/DemoTransportProperties.java\" > { @Component @ConfigurationProperties(prefix = \"convengine.demo\") public class DemoTransportProperties { private StreamMode streamMode = StreamMode.SSE; private StepHook stepHook = new StepHook(); public enum StreamMode { SSE, STOMP, BOTH } public static class StepHook { private boolean enabled = true; } } } </CodeBlockToggle> <CodeBlockToggle title=\"ConvEngineTransportStartupLogger.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/ConvEngineTransportStartupLogger.java\" > { @Component @RequiredArgsConstructor public class ConvEngineTransportStartupLogger { private final DemoTransportProperties demoTransportProperties; private final ConvEngineTransportConfig transportConfig; private final Environment environment; @EventListener(ApplicationReadyEvent.class) public void logTransportConfiguration() { boolean sseEnabled = transportConfig.getSse().isEnabled(); boolean stompEnabled = transportConfig.getStomp().isEnabled(); // validates mode and prints endpoints } } } </CodeBlockToggle> <CodeBlockToggle title=\"DemoEngineStepHook.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/DemoEngineStepHook.java\" > { @Component @RequiredArgsConstructor public class DemoEngineStepHook implements EngineStepHook { private static final Set<EngineStep.Name> TRACKED_STEPS = Set.of( EngineStep.Name.IntentResolutionStep, EngineStep.Name.SchemaExtractionStep, EngineStep.Name.RulesStep, EngineStep.Name.ResponseResolutionStep ); @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return demoTransportProperties.getStepHook().isEnabled() && TRACKED_STEPS.contains(stepName); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { /* logs */ } @Override public void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) { /* logs */ } @Override public void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) { /* logs */ } } } </CodeBlockToggle> ## zapper-ui: How frontend consumes backend <CodeBlockToggle title=\"convengine.api.js (zapper-ui)\" language=\"js\" filePath=\"zapper-ui/src/api/convengine.api.js\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; // STOMP scaffold commented for optional enablement } </CodeBlockToggle> <CodeBlockToggle title=\"App.jsx (zapper-ui)\" language=\"jsx\" filePath=\"zapper-ui/src/App.jsx\" > { useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion(v => v + 1), onEvent: () => setAuditVersion(v => v + 1), }); return () => stream.close(); }, [conversationId]); } </CodeBlockToggle> <CodeBlockToggle title=\"ChatPanel.jsx (zapper-ui)\" language=\"jsx\" filePath=\"zapper-ui/src/components/ChatPanel.jsx\" > { const res = await sendMessage(conversationId, userText); setMessages(m => [...m, { role: \"assistant\", text: assistantText }]); // Typing indicator shown while request is in-flight } </CodeBlockToggle> <Highlight type=\"info\" title=\"Backend + UI runbook\"> 1. Start backend ( convengine-demo ) with profile <MethodRef>sse</MethodRef>, <MethodRef>stomp</MethodRef>, or <MethodRef>both</MethodRef>. 2. Start <FileRef>zapper-ui</FileRef> and point API base to backend URL. 3. Send message, verify live timeline from stream + detailed payloads from audit API. </Highlight> <CodeBlockToggle title=\"Run commands\" language=\"bash\" defaultOpen={false}> { # backend (convengine-demo) ./mvnw spring-boot:run -Dspring-boot.run.profiles=sse # or ./mvnw spring-boot:run -Dspring-boot.run.profiles=stomp # or ./mvnw spring-boot:run -Dspring-boot.run.profiles=both # frontend (zapper-ui) npm install npm run dev } </CodeBlockToggle>",
    "excerpt": "Backend Integration This page uses your demo repos directly: backend reference: convengine demo UI reference: zapper ui What each demo proves convengine demo : Spring Boot consumer setup, transport mode config, step hook…"
  },
  {
    "id": "consumer/caching-and-persistence.mdx",
    "version": "v2",
    "title": "caching and persistence",
    "permalink": "/docs/v2/consumer/caching-and-persistence",
    "content": "Caching & Persistence ConvEngine v2 is heavily optimized to decouple real time generative latency from slow relational database I/O. The framework accomplishes this by utilizing Asynchronous Persistence Threads alongside Spring's Abstract CacheManager . To activate this optimization on your backend, add the following decorators to your application class: 1. @EnableConvEngineCaching 2. @EnableConvEngineAsyncConversation The actual datastore powering @EnableConvEngineCaching is entirely controlled by the Consumer application , not the ConvEngine framework. ConvEngine relies on the generic Spring CacheManager interface to save and load CeConversation instances via the ce_conversation_cache routing key. By default, to activate ConvEngine caching, you must pull in Spring Boot's caching abstraction layer. If you import this module but do not import any external caching dependencies (like Redis or Ehcache), Spring Boot will automatically fall back to providing a ConcurrentMapCacheManager out of the box. Dependency requirement ( pom.xml ) : If you annotate your application class with @EnableConvEngineCaching but fail to include spring boot starter cache in your pom.xml , the Spring context will fatally crash on startup because it cannot find an underlying CacheManager bean to bind to. This operates seamlessly once the module is present. It holds conversation states inside a standard Java HashMap residing in your server's active JVM memory. Pros : Blazing fast ( 0ms read/write latency), requires zero configuration. Cons : Cache is completely wiped if the Spring Boot application restarts or crashes; not horizontal scale (multi pod) friendly. 1. Ehcache 3 (JSR 107) For robust, production grade memory bounds, Ehcache is a highly recommended on premise memory provider. It allows conversational payloads to spill over from the active heap into offheap memory to prevent JVM garbage collection thrashing during large multi turn flows. Dependency update ( pom.xml ) : App configuration ( application.yml ) : Provider specification ( src/main/resources/ehcache.xml ) : 2. Caffeine Cache If you prefer a highly optimized, high performance local cache strictly contained inside the JVM (without off heap spillage but statistically faster hit rates than Ehcache), Caffeine is Spring Boot's default local provider replacement. Dependency update ( pom.xml ) : App configuration ( application.yml ) : Unlike Ehcache, Caffeine can be fully initialized inside application.yml without distinct XML files. 3. Redis For horizontally scaled environments like Kubernetes ( k8s ) where your user traffic rotates across multiple server pods mid conversation, you cannot use local memory (Ehcache/Caffeine). Redis binds ConvEngine's cache into an external centralized datastore. Dependency update ( pom.xml ) : App configuration ( application.yml ) : Because Redis runs outside the active server JVM, it relies on network transmission. You must ensure that your Spring application has a generic RedisTemplate or Jackson configured RedisCacheConfiguration bean configured to serialize CeConversation entities, otherwise Java will throw NotSerializableException when attempting to push the object to the internet. 4. Static Configuration Preloading Beyond dynamic conversational sessions, ConvEngine also permanently caches all non transactional database rules ( ce_intent , ce_rule , ce_mcp_tool , ce_mcp_planner , ce_config , etc.) into a generic ce_static_configs memory tree entirely upon JVM live initiation. This ensures that the engine never triggers synchronous relational fetches during the middle of a customer's turn. If you connect to your database and update a ce_rule row manually using SQL , the active Java application won't automatically see it until you flush this static cache. Flushing the Cache Tree: You can do this by hitting the integrated Admin Controller endpoint mapped generically natively into your backend: This endpoint executes @CacheEvict(value = \"ce_static_configs\", allEntries = true) and immediately re triggers the Spring Data Preloader, locking in your latest SQL tweaks live. 5. Cache Analyzer API ( /api/v1/cache/analyze ) Use this endpoint when you want to validate cache health without guessing whether misses are caused by provider, proxying, or runtime wiring. warmup=true actively calls static cache loaders before reporting timing metrics. warmup=false only inspects current state and does not trigger additional warmup calls. How to Read the Analyzer Response Interpret each JSON block as follows: , \"ce_mcp_tool\": , \"ce_mcp_db_tool\": , \"ce_mcp_planner\": , \"ce_prompt_template\": , \"ce_policy\": , \"ce_pending_action\": , \"ce_intent\": , \"ce_output_schema\": , \"ce_response\": , \"ce_rule\": , \"ce_intent_classifier\": , \"ce_container_config\": }, \"registeredCacheNames\": [ \"ce_config\", \"ce_prompt_template\", \"ce_policy\", \"ce_output_schema\", \"ce_conversation_history_cache\", \"ce_rule\", \"ce_container_config\", \"ce_mcp_tool\", \"ce_mcp_db_tool\", \"ce_mcp_planner\", \"ce_conversation_cache\", \"ce_pending_action\", \"ce_intent\", \"ce_response\", \"ce_intent_classifier\" ], \"staticCaches\": , \"ce_mcp_tool\": , \"ce_mcp_db_tool\": , \"ce_mcp_planner\": , \"ce_prompt_template\": , \"ce_policy\": , \"ce_pending_action\": , \"ce_intent\": , \"ce_output_schema\": , \"ce_response\": , \"ce_rule\": , \"ce_intent_classifier\": , \"ce_container_config\": }, \"runtimeCaches\": , \"ce_conversation_history_cache\": } } } Interpreting the sample you shared cacheManagerClass=ConcurrentMapCacheManager : Local in memory cache provider is active and valid. Static caches all show exists=true , hasSimpleKeyEntry=true , nativeEntryCount=1 : static ce_ cache population is healthy. Static listSize values are non zero: static rows are loaded into cache as expected. firstCallMs=0 and secondCallMs=0 : data is tiny and runtime is fast enough to round to 0 ms; this is normal. Runtime caches at nativeEntryCount=0 : no conversation/historical entries cached yet at capture time, or traffic was not running when the snapshot was taken.",
    "rawContent": "# Caching & Persistence ConvEngine v2 is heavily optimized to decouple real-time generative latency from slow relational database I/O. The framework accomplishes this by utilizing **Asynchronous Persistence Threads** alongside **Spring's Abstract CacheManager**. To activate this optimization on your backend, add the following decorators to your application class: 1. <MethodRef>@EnableConvEngineCaching</MethodRef> 2. <MethodRef>@EnableConvEngineAsyncConversation</MethodRef> <Highlight type=\"tip\" title=\"How the abstraction works\"> The actual datastore powering @EnableConvEngineCaching is **entirely controlled by the Consumer application**, not the ConvEngine framework. ConvEngine relies on the generic Spring CacheManager interface to save and load CeConversation instances via the ce_conversation_cache routing key. </Highlight> By default, to activate ConvEngine caching, you must pull in Spring Boot's caching abstraction layer. If you import this module but do not import any external caching dependencies (like Redis or Ehcache), Spring Boot will automatically fall back to providing a ** ConcurrentMapCacheManager ** out of the box. **Dependency requirement ( pom.xml )**: <CodeBlockToggle title=\"pom.xml\" language=\"xml\"> { <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Startup crashes without this dependency\"> If you annotate your application class with @EnableConvEngineCaching but fail to include spring-boot-starter-cache in your pom.xml , the Spring context will fatally crash on startup because it cannot find an underlying CacheManager bean to bind to. </Highlight> This operates seamlessly once the module is present. It holds conversation states inside a standard Java HashMap residing in your server's active JVM memory. - **Pros**: Blazing fast ( 0ms read/write latency), requires zero configuration. - **Cons**: Cache is completely wiped if the Spring Boot application restarts or crashes; not horizontal-scale (multi-pod) friendly. --- ## 1. Ehcache 3 (JSR-107) For robust, production-grade memory bounds, **Ehcache** is a highly recommended on-premise memory provider. It allows conversational payloads to spill over from the active heap into offheap memory to prevent JVM garbage collection thrashing during large multi-turn flows. **Dependency update ( pom.xml )**: <CodeBlockToggle title=\"pom.xml\" language=\"xml\"> { <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> <dependency> <groupId>javax.cache</groupId> <artifactId>cache-api</artifactId> </dependency> <dependency> <groupId>org.ehcache</groupId> <artifactId>ehcache</artifactId> </dependency> } </CodeBlockToggle> **App configuration ( application.yml )**: <CodeBlockToggle title=\"application.yml\" language=\"yaml\"> { spring: cache: jcache: config: classpath:ehcache.xml } </CodeBlockToggle> **Provider specification ( src/main/resources/ehcache.xml )**: <CodeBlockToggle title=\"ehcache.xml\" language=\"xml\"> { <config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.ehcache.org/v3\" xmlns:jsr107=\"http://www.ehcache.org/v3/jsr107\" xsi:schemaLocation=\" http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd http://www.ehcache.org/v3/jsr107 http://www.ehcache.org/schema/ehcache-107-ext-3.0.xsd\"> <!-- This MUST exactly match ConvEngine's requested alias --> <cache alias=\"ce_conversation_cache\"> <key-type>java.lang.String</key-type> <value-type>com.github.salilvnair.convengine.entity.CeConversation</value-type> <expiry> <ttl unit=\"minutes\">60</ttl> </expiry> <resources> <heap unit=\"entries\">2000</heap> <offheap unit=\"MB\">100</offheap> </resources> </cache> </config> } </CodeBlockToggle> --- ## 2. Caffeine Cache If you prefer a highly optimized, high-performance local cache strictly contained inside the JVM (without off-heap spillage but statistically faster hit-rates than Ehcache), **Caffeine** is Spring Boot's default local provider replacement. **Dependency update ( pom.xml )**: <CodeBlockToggle title=\"pom.xml\" language=\"xml\"> { <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> <dependency> <groupId>com.github.ben-manes.caffeine</groupId> <artifactId>caffeine</artifactId> </dependency> } </CodeBlockToggle> **App configuration ( application.yml )**: Unlike Ehcache, Caffeine can be fully initialized inside application.yml without distinct XML files. <CodeBlockToggle title=\"application.yml\" language=\"yaml\"> { spring: cache: type: caffeine cache-names: ce_conversation_cache caffeine: # Max limits the cache to 5,000 conversational objects, expiring them 60 minutes after their last network write spec: maximumSize=5000,expireAfterWrite=60m } </CodeBlockToggle> --- ## 3. Redis For horizontally scaled environments like Kubernetes ( k8s ) where your user traffic rotates across multiple server pods mid-conversation, you cannot use local memory (Ehcache/Caffeine). **Redis** binds ConvEngine's cache into an external centralized datastore. **Dependency update ( pom.xml )**: <CodeBlockToggle title=\"pom.xml\" language=\"xml\"> { <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> } </CodeBlockToggle> **App configuration ( application.yml )**: <CodeBlockToggle title=\"application.yml\" language=\"yaml\"> { spring: data: redis: host: localhost port: 6379 cache: type: redis redis: time-to-live: 60m cache-null-values: false use-key-prefix: true key-prefix: \"convengine:\" } </CodeBlockToggle> <Highlight type=\"warning\" title=\"A note on serialization\"> Because Redis runs outside the active server JVM, it relies on network transmission. You must ensure that your Spring application has a generic RedisTemplate or Jackson-configured RedisCacheConfiguration bean configured to serialize CeConversation entities, otherwise Java will throw NotSerializableException when attempting to push the object to the internet. </Highlight> --- ## 4. Static Configuration Preloading Beyond dynamic conversational sessions, ConvEngine also permanently caches all non-transactional database rules ( ce_intent , ce_rule , ce_mcp_tool , ce_mcp_planner , ce_config , etc.) into a generic ce_static_configs memory tree entirely upon JVM live initiation. This ensures that the engine never triggers synchronous relational fetches during the middle of a customer's turn. If you connect to your database and update a ce_rule row manually using SQL , the active Java application won't automatically see it until you flush this static cache. **Flushing the Cache Tree:** You can do this by hitting the integrated Admin Controller endpoint mapped generically natively into your backend: <CodeBlockToggle title=\"Cache Refresh Trigger\" language=\"bash\"> { curl -X GET \"http://localhost:8080/api/v1/cache/refresh\" } </CodeBlockToggle> This endpoint executes @CacheEvict(value = \"ce_static_configs\", allEntries = true) and immediately re-triggers the Spring Data Preloader, locking in your latest SQL tweaks live. --- ## 5. Cache Analyzer API ( /api/v1/cache/analyze ) Use this endpoint when you want to validate cache health without guessing whether misses are caused by provider, proxying, or runtime wiring. <DbTable title=\"Analyzer endpoint contract\" columns={[\"Method\", \"Path\", \"Query Param\", \"Purpose\"]} rows={[ [\"GET\", \"/api/v1/cache/analyze\", \"warmup=true|false\", \"Returns cache/provider/proxy diagnostics and cache entry visibility.\"], ]} /> <CodeBlockToggle title=\"Example calls\" language=\"bash\"> { # Deep probe (runs warmup timing first-call vs second-call) curl \"http://localhost:8080/api/v1/cache/analyze?warmup=true\" # Passive snapshot (no extra warmup/timing calls) curl \"http://localhost:8080/api/v1/cache/analyze?warmup=false\" } </CodeBlockToggle> <Highlight type=\"info\" title=\"warmup flag behavior\"> warmup=true actively calls static cache loaders before reporting timing metrics. warmup=false only inspects current state and does not trigger additional warmup calls. </Highlight> ### How to Read the Analyzer Response Interpret each JSON block as follows: <DbTable title=\"Field-by-field meaning\" columns={[\"Field\", \"What it means\", \"Healthy signal\", \"When to investigate\"]} rows={[ [\"warmupAndTimingEnabled\", \"Whether analyzer executed active timing probe.\", \"Matches your request flag.\", \"Unexpected value indicates wrong request or proxy/caching to old endpoint.\"], [\"cacheManagerClass\", \"Actual Spring cache provider at runtime.\", \" ConcurrentMapCacheManager , Caffeine, Redis, etc. as expected.\", \"Unexpected provider means environment config drift.\"], [\"registeredCacheNames\", \"Caches currently known to provider.\", \"Includes static ce_* and runtime caches.\", \"Missing cache names means cache operations are not being registered/hit.\"], [\"warmupTimingMs\", \"First vs second invocation latency by static cache.\", \"Second call <= first call, usually much faster.\", \"Both large or growing means repeated misses or backend latency.\"], [\"staticCaches.*.hasSimpleKeyEntry\", \"Whether no-arg @Cacheable entry exists.\", \" true for all static ce_* datasets.\", \" false means static caches were not populated/hit.\"], [\"staticCaches.*.listSize\", \"Rows currently held in memory for each static table.\", \"Non-zero sizes matching expected SQL data.\", \"Unexpected zero/low values indicates seed/data/environment mismatch.\"], [\"runtimeCaches.*.nativeEntryCount\", \"Current conversation/history cache occupancy.\", \"Grows when conversations run.\", \"Always zero during active traffic indicates runtime cache path not used.\"], ]} /> <CodeBlockToggle title=\"Sample response\" language=\"json\"> { { \"warmupAndTimingEnabled\": true, \"cacheManagerClass\": \"org.springframework.cache.concurrent.ConcurrentMapCacheManager\", \"warmupTimingMs\": { \"ce_config\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_mcp_tool\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_mcp_db_tool\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_mcp_planner\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_prompt_template\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_policy\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_pending_action\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_intent\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_output_schema\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_response\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_rule\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_intent_classifier\": { \"secondCallMs\": 0, \"firstCallMs\": 0 }, \"ce_container_config\": { \"secondCallMs\": 0, \"firstCallMs\": 0 } }, \"registeredCacheNames\": [ \"ce_config\", \"ce_prompt_template\", \"ce_policy\", \"ce_output_schema\", \"ce_conversation_history_cache\", \"ce_rule\", \"ce_container_config\", \"ce_mcp_tool\", \"ce_mcp_db_tool\", \"ce_mcp_planner\", \"ce_conversation_cache\", \"ce_pending_action\", \"ce_intent\", \"ce_response\", \"ce_intent_classifier\" ], \"staticCaches\": { \"ce_config\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 12, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_mcp_tool\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 2, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_mcp_db_tool\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 2, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_mcp_planner\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 3, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_prompt_template\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 4, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_policy\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 1, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_pending_action\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 1, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_intent\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 4, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_output_schema\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 2, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_response\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 7, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_rule\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 4, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_intent_classifier\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 3, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 }, \"ce_container_config\": { \"valueType\": \"java.util.ArrayList\", \"exists\": true, \"listSize\": 1, \"hasSimpleKeyEntry\": true, \"nativeEntryCount\": 1 } }, \"runtimeCaches\": { \"ce_conversation_cache\": { \"exists\": true, \"nativeEntryCount\": 0 }, \"ce_conversation_history_cache\": { \"exists\": true, \"nativeEntryCount\": 0 } } } } </CodeBlockToggle> ### Interpreting the sample you shared - cacheManagerClass=ConcurrentMapCacheManager : Local in-memory cache provider is active and valid. - Static caches all show exists=true , hasSimpleKeyEntry=true , nativeEntryCount=1 : static ce_* cache population is healthy. - Static listSize values are non-zero: static rows are loaded into cache as expected. - firstCallMs=0 and secondCallMs=0 : data is tiny and runtime is fast enough to round to 0 ms; this is normal. - Runtime caches at nativeEntryCount=0 : no conversation/historical entries cached yet at capture time, or traffic was not running when the snapshot was taken.",
    "excerpt": "Caching & Persistence ConvEngine v2 is heavily optimized to decouple real time generative latency from slow relational database I/O. The framework accomplishes this by utilizing Asynchronous Persistence Threads alongside…"
  },
  {
    "id": "consumer/configuration.mdx",
    "version": "v2",
    "title": "configuration",
    "permalink": "/docs/v2/consumer/configuration",
    "content": "Consumer Configuration This guide covers the core tunable properties available for ConvEngine consumers. Properties are managed via Spring Boot @ConfigurationProperties and can be set in your application.yml or application.properties . Core namespaces ConvEngine introduces several configuration namespaces: convengine.flow. (runtime behavior tuning) convengine.audit. (event and tracking controls) convengine.transport. (SSE/STOMP delivery settings) convengine.tables. (dynamic table mapping overrides) convengine.experimental. (forward looking toggles) Complete application.yml Reference Below is a complete reference of the default configuration options exposed by ConvEngine. disambiguation: enabled: true max options: 5 memory: enabled: true summary max chars: 1200 recent turns for summary: 3 Transport mechanisms transport: sse: enabled: true emitter timeout ms: 1800000 stomp: enabled: false endpoint: /ws convengine app destination prefix: /app topic prefix: /topic audit destination base: /topic/convengine/audit allowed origin pattern: \" \" sock js: true broker: mode: SIMPLE SIMPLE | RELAY relay destination prefixes: /topic,/queue relay host: localhost relay port: 61613 client login: \"\" client passcode: \"\" system login: \"\" system passcode: \"\" virtual host: \"\" system heartbeat send interval ms: 10000 system heartbeat receive interval ms: 10000 Auditing controls audit: enabled: true persist meta: true cache inspector: false level: ALL ALL | STANDARD | ERROR_ONLY | NONE include stages: [] exclude stages: [] persistence: mode: IMMEDIATE IMMEDIATE | DEFERRED_BULK jdbc batch size: 200 max buffered events: 5000 flush stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final step names: PipelineEndGuardStep flush on stop outcome: true dispatch: async enabled: false worker threads: 2 queue capacity: 2000 rejection policy: CALLER_RUNS CALLER_RUNS | DROP_NEWEST | DROP_OLDEST | ABORT keep alive seconds: 60 rate limit: enabled: false max events: 200 window ms: 1000 per conversation: true per stage: true max tracked buckets: 20000 } Breakdown: Flow Configuration The convengine.flow. properties control the nuanced routing behavior without requiring consumer side hardcoded Java branching for common dialogue/action patterns. EXECUTE_PENDING_ACTION)\"] ]} / Breakdown: Audit Configuration convengine.audit. dictates how the system records telemetry and metric payloads down to the individual pipeline stage logic. Breakdown: Transport Configuration convengine.transport. applies to interactive async communication paths like Server Sent Events (SSE) or WebSockets via STOMP. Some transport handlers may also be gated by @EnableConvEngine(stream = true) in your main application class. Runtime DB Behavior (Deep Dive Links) ce_verbose : ce_conversation : session reset/continuity behavior:",
    "rawContent": "# Consumer Configuration This guide covers the core tunable properties available for ConvEngine consumers. Properties are managed via Spring Boot @ConfigurationProperties and can be set in your application.yml or application.properties . ## Core namespaces ConvEngine introduces several configuration namespaces: - convengine.flow.* (runtime behavior tuning) - convengine.audit.* (event and tracking controls) - convengine.transport.* (SSE/STOMP delivery settings) - convengine.tables.* (dynamic table mapping overrides) - convengine.experimental.* (forward-looking toggles) --- ## Complete application.yml Reference Below is a complete reference of the default configuration options exposed by ConvEngine. <CodeBlockToggle title=\"Complete application.yml reference\" language=\"yaml\" defaultOpen={true}> { convengine: # Dynamic table mapping for CE_* entities (same as V1) tables: AUDIT: CE_AUDIT CONFIG: CE_CONFIG CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_PLANNER: CE_MCP_PLANNER MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA POLICY: CE_POLICY PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE # Feature flags for experimental features experimental: enabled: false # Flow tuning flow: query-rewrite: enabled: true conversation-history: max-turns: 10 dialogue-act: resolute: REGEX_THEN_LLM # REGEX_ONLY | REGEX_THEN_LLM | LLM_ONLY llm-threshold: 0.90 interaction-policy: execute-pending-on-affirm: true reject-pending-on-negate: true fill-pending-slot-on-non-new-request: true require-resolved-intent-and-state: true matrix: \"PENDING_ACTION:AFFIRM\": EXECUTE_PENDING_ACTION \"PENDING_ACTION:NEGATE\": REJECT_PENDING_ACTION \"PENDING_SLOT:EDIT\": FILL_PENDING_SLOT \"PENDING_SLOT:QUESTION\": FILL_PENDING_SLOT \"PENDING_SLOT:NEGATE\": FILL_PENDING_SLOT \"PENDING_SLOT:AFFIRM\": FILL_PENDING_SLOT action-lifecycle: enabled: true ttl-turns: 3 ttl-minutes: 30 tool-orchestration: enabled: true guardrail: enabled: true sanitize-input: true require-approval-for-sensitive-actions: false approval-gate-fail-closed: false sensitive-patterns: [] state-graph: enabled: true soft-block-on-violation: false allowed-transitions: {} disambiguation: enabled: true max-options: 5 memory: enabled: true summary-max-chars: 1200 recent-turns-for-summary: 3 # Transport mechanisms transport: sse: enabled: true emitter-timeout-ms: 1800000 stomp: enabled: false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE # SIMPLE | RELAY relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 # Auditing controls audit: enabled: true persist-meta: true cache-inspector: false level: ALL # ALL | STANDARD | ERROR_ONLY | NONE include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE # IMMEDIATE | DEFERRED_BULK jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS # CALLER_RUNS | DROP_NEWEST | DROP_OLDEST | ABORT keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 } </CodeBlockToggle> --- ## Breakdown: Flow Configuration The convengine.flow.* properties control the nuanced routing behavior without requiring consumer-side hardcoded Java branching for common dialogue/action patterns. <DbTable title=\"convengine.flow.dialogue-act\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"resolute\", \"REGEX_THEN_LLM\", \"Intent resolution strategy (REGEX_ONLY, REGEX_THEN_LLM, LLM_ONLY)\"], [\"llm-threshold\", \"0.90\", \"Confidence threshold for LLM intent classification via DialogueAct\"] ]} /> <DbTable title=\"convengine.flow.query-rewrite\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"true\", \"Automatically derives a standalone query from conversation history for contextual downstream RAG tool injection.\"] ]} /> <DbTable title=\"convengine.flow.conversation-history\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"maxTurns\", \"10\", \"Maximum number of conversation turns to retain in history before summarization.\"] ]} /> <DbTable title=\"convengine.flow.interaction-policy\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"execute-pending-on-affirm\", \"true\", \"Automatically run pending action if user says yes\"], [\"reject-pending-on-negate\", \"true\", \"Cancel pending action if user says no\"], [\"fill-pending-slot-on-non-new-request\", \"true\", \"Assign input to a waiting required parameter slot\"], [\"require-resolved-intent-and-state\", \"true\", \"Enforce strict intent tracking\"], [\"matrix\", \"{...}\", \"Configures the fallback resolution engine for dialogue act intent mapping to standard actions (e.g. PENDING_ACTION:AFFIRM -> EXECUTE_PENDING_ACTION)\"] ]} /> <DbTable title=\"convengine.flow.action-lifecycle\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"true\", \"Tracks how long pending actions remain valid\"], [\"ttl-turns\", \"3\", \"Number of conversational turns a pending action survives before eviction\"], [\"ttl-minutes\", \"30\", \"Wall-clock time bounds for pending action survival\"] ]} /> <DbTable title=\"convengine.flow.guardrail\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"true\", \"General guardrail functionality\"], [\"sanitize-input\", \"true\", \"Basic textual sanitization\"], [\"require-approval-for-sensitive-actions\", \"false\", \"If true, high-privilege tool execution demands explicit user affirmation\"], [\"approval-gate-fail-closed\", \"false\", \"If true, guardrail rejections fail closed rather than degrading gracefully\"], [\"sensitive-patterns\", \"[]\", \"Regex signatures for proactive redaction\"] ]} /> <DbTable title=\"convengine.flow.state-graph\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"true\", \"Turn state transition validation on/off\"], [\"soft-block-on-violation\", \"false\", \"Allow transition but mark warning if violating strict pathing\"], [\"allowed-transitions\", \"{}\", \"Map defining hard-coded allowed path trajectories\"] ]} /> <DbTable title=\"convengine.flow.disambiguation\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"true\", \"Allow engine to propose follow-ups when intent density intersects/collides\"], [\"max-options\", \"5\", \"Clamp the number of disambiguation choices returned\"] ]} /> <DbTable title=\"convengine.flow.memory\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"true\", \"Enables LLM-driven session summarization for long dialogues\"], [\"summary-max-chars\", \"1200\", \"Maximum characters allowed in token context injection for memory\"], [\"recent-turns-for-summary\", \"3\", \"Sliding window of interaction chunks prior to memory compression\"] ]} /> --- ## Breakdown: Audit Configuration convengine.audit.* dictates how the system records telemetry and metric payloads down to the individual pipeline stage logic. <DbTable title=\"convengine.audit\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"true\", \"Root toggle for the audit framework\"], [\"persist-meta\", \"true\", \"Attach engine metadata to the payload (intent, state, emittedAt)\"], [\"cache-inspector\", \"false\", \"Takes full snapshots of the memory session tree on every cache step\"], [\"level\", \"ALL\", \"Logging verbosity threshold (ALL, STANDARD, ERROR_ONLY, NONE)\"], [\"include-stages\", \"[]\", \"Whitelist specific stages\"], [\"exclude-stages\", \"[]\", \"Blacklist specific stages\"] ]} /> <DbTable title=\"convengine.audit.dispatch\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"async-enabled\", \"false\", \"Moves transport fan-out off the main request thread when true\"], [\"worker-threads\", \"2\", \"Number of async audit dispatcher threads\"], [\"queue-capacity\", \"2000\", \"Maximum queued events\"], [\"rejection-policy\", \"CALLER_RUNS\", \"Backpressure handling when capacity exceeded (CALLER_RUNS, DROP_NEWEST, DROP_OLDEST, ABORT)\"], [\"keep-alive-seconds\", \"60\", \"Metrics keep-alive window\"] ]} /> <DbTable title=\"convengine.audit.persistence\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"mode\", \"IMMEDIATE\", \"Write style. IMMEDIATE writes row by row. DEFERRED_BULK buffers events and writes batch inserts (safer under load).\"], [\"jdbc-batch-size\", \"200\", \"Row chunking factor for DB connection drivers\"], [\"max-buffered-events\", \"5000\", \"Maximum heap objects maintained for bulk emission\"], [\"flush-stages\", \"ENGINE_KNOWN_FAILURE, ENGINE_UNKNOWN_FAILURE\", \"Immediate force-flush triggers\"], [\"final-step-names\", \"PipelineEndGuardStep\", \"Trigger to signify request termination to commit remainder logs\"], [\"flush-on-stop-outcome\", \"true\", \"Flush early if a stage explicitly terminates the pipeline\"] ]} /> <DbTable title=\"convengine.audit.rate-limit\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"enabled\", \"false\", \"Protects DB from noisy event generation loop conditions\"], [\"max-events\", \"200\", \"Cap on volume\"], [\"window-ms\", \"1000\", \"Time interval (sliding)\"], [\"per-conversation\", \"true\", \"Bucket per conversation UUID\"], [\"per-stage\", \"true\", \"Bucket per discrete execution component logic\"], [\"max-tracked-buckets\", \"20000\", \"Upper memory footprint limit for Token Bucket store\"] ]} /> --- ## Breakdown: Transport Configuration convengine.transport.* applies to interactive async communication paths like Server Sent Events (SSE) or WebSockets via STOMP. <DbTable title=\"convengine.transport.stomp.broker\" columns={[\"Property\", \"Default\", \"Description\"]} rows={[ [\"mode\", \"SIMPLE\", \"SIMPLE operates an in-memory broker. RELAY interfaces with external STOMP brokers (e.g., RabbitMQ).\"], [\"relay-destination-prefixes\", \"/topic, /queue\", \"Path segments bound to external relay dispatch\"], [\"relay-host\", \"localhost\", \"Address of standard STOMP capable broker\"], [\"relay-port\", \"61613\", \"Network port\"], [\"system-heartbeat-send-interval-ms\", \"10000\", \"Broker heartbeat outgoing frequency\"], [\"system-heartbeat-receive-interval-ms\", \"10000\", \"Broker heartbeat tolerance incoming frequency\"] ]} /> <Highlight type=\"tip\" title=\"Stream enablement note\"> Some transport handlers may also be gated by @EnableConvEngine(stream = true) in your main application class. </Highlight> --- ## Runtime DB Behavior (Deep Dive Links) - ce_verbose : [Verbose and Conversation Runtime](/docs/v2/deep-dive/verbose-and-conversation-runtime) - ce_conversation : [Verbose and Conversation Runtime](/docs/v2/deep-dive/verbose-and-conversation-runtime) - session reset/continuity behavior: [Session, Reset, Continuity](/docs/v2/consumer/session-reset-and-continuity)",
    "excerpt": "Consumer Configuration This guide covers the core tunable properties available for ConvEngine consumers. Properties are managed via Spring Boot @ConfigurationProperties and can be set in your application.yml or applicati…"
  },
  {
    "id": "consumer/extensions.mdx",
    "version": "v2",
    "title": "extensions",
    "permalink": "/docs/v2/consumer/extensions",
    "content": "Extension Points and Intervention Scenarios EngineStepHook intervene between any steps Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } :::tip Where to use this Use hooks when you need low friction runtime intervention without forking framework steps. ::: ContainerDataTransformer reshape container response Real scenario: CCF returns nested payload; you flatten to schema friendly map. } } ResponseTransformer post process final payload Real scenario: Add support team escalation footer for high severity disconnect failures. return responsePayload; } } } ContainerDataInterceptor intercept request/response around CCF Real scenario: add tenant metadata and redact a field before persistence. ConvEngineVerboseAdapter publish UI verbose messages from consumer code Use this when hooks, transformers, or custom Spring beans need to emit progress/error messages to the UI without embedding transport code. ]] in state [[\\$ ]].\" ); } } } What it gives you: publish(session, this, \"TOKEN\") : DB backed ce_verbose lookup using this.getClass().getSimpleName() publish(session, this, \"TOKEN\", metadata) : same, with extra metadata for resolver matching and rendering publishError(...) : same path, error branch publishText(...) : bypasses ce_verbose row lookup and sends direct text, still rendered through Thymeleaf Recommended pattern: use publish(...) when the wording should be controlled by ce_verbose use publishText(...) when the wording should come directly from consumer Java Rule Action Playbook ( SET_TASK , SET_JSON , GET_CONTEXT , GET_SESSION , SET_INPUT_PARAM , SET_DIALOGUE_ACT ) These actions execute inside RulesStep.execute(...) and mutate the live EngineSession . Set ce_rule.phase based on where you want the action to run: POST_DIALOGUE_ACT : immediately after DialogueActStep , before InteractionPolicyStep . PRE_RESPONSE_RESOLUTION : normal RulesStep pass. POST_AGENT_INTENT : post intent pass inside AgentIntentResolver . SET_TASK execute consumer Java methods from rule Use this when a rule match must trigger consumer side business logic (incident raise, tracker lookup, eligibility fetch, etc). Set ce_rule.action to SET_TASK and provide bean/method mapping in action_value . Bean must be a Spring bean with the configured bean name and implement CeRuleTask . Methods are invoked with (EngineSession session, CeRule rule) . public void attachEta(EngineSession session, CeRule rule) } } Downstream prompt/response can read new context/inputParams (for example requestStatus , lastUpdated , eta_hours ). SET_JSON move JSONPath value into input params Use this to extract one value from runtime session JSON into a flat prompt var. SET_JSON writes to session.putInputParam(\"error_code\", value) . It does not change session.contextJson unless your subsequent task/hook updates context explicitly. GET_CONTEXT snapshot context into input params Use this when prompt templates or tasks need full context as a single variable. If action_value is blank, engine uses default key context . GET_SESSION snapshot session facts into input params Use this for advanced derived responses that need runtime flags ( schemaComplete , intentLocked , missingRequiredFields , etc). If action_value is blank, engine uses default key session . SET_INPUT_PARAM write runtime flags directly Use this when you need lightweight runtime variables for later rules/steps without creating a custom task bean. ', 11, true, 'Mark confirmation flags after schema becomes complete'); } Typical uses: awaiting_confirmation confirmation_key skip_schema_extraction routing_decision correction_applied This is the clean way to make later ce_rule phases react to: confirmation answers ( AFFIRM / NEGATE ) correction routing post schema, pre MCP gating SET_DIALOGUE_ACT override final dialogue act after classification Use this when DialogueActStep correctly preserves an LLM candidate (for example dialogue_act_llm_candidate=EDIT ) but the final guarded result should be overridden before InteractionPolicyStep . This is especially useful in POST_DIALOGUE_ACT . ', 5, true, 'Promote guarded LLM EDIT back to EDIT before interaction policy'); } Accepted action_value formats: simple string: EDIT structured JSON: SET_DIALOGUE_ACT updates: dialogue_act dialogue_act_confidence dialogue_act_source optional standalone_query (which also refreshes resolved_user_input ) SET_TASK methods run during rule execution. Keep methods deterministic and idempotent. For side effecting calls (ticket creation, webhook dispatch), guard with strict rule conditions and add idempotency keys from conversationId . Resolvers engine/rule/type/provider/SetTaskActionResolver.java engine/rule/type/provider/SetJsonActionResolver.java engine/rule/type/provider/GetContextActionResolver.java engine/rule/type/provider/GetSessionActionResolver.java engine/rule/type/provider/SetDialogueActActionResolver.java Task invocation engine/rule/task/CeRuleTaskExecutor.java Execution loop engine/steps/RulesStep.java Custom action resolver ( RuleActionResolver ) Consumer can define a brand new rule action without changing framework core. Implement RuleActionResolver and return your action name from action() . @Override public void resolve(EngineSession session, CeRule rule) } } Set ce_rule.action to your custom token (case insensitive lookup), for example ENRICH_TIER . No manual factory config is needed. RuleActionResolverFactory auto registration behavior auto discovers all Spring beans implementing RuleActionResolver and maps by action().toUpperCase() .",
    "rawContent": "# Extension Points and Intervention Scenarios <div className=\"ce-extensions-page\"> ## EngineStepHook - intervene between any steps {#1-enginestephook---intervene-between-any-steps} Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. <CodeBlockToggle title=\"EngineStepHook example\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\"> { @Component public class LogAnalysisHintHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName && \"LOG_ANALYSIS\".equalsIgnoreCase(session.getIntent()); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"log_source_priority\", \"APM_FIRST\"); } } } </CodeBlockToggle> :::tip Where to use this Use hooks when you need low-friction runtime intervention without forking framework steps. ::: ## ContainerDataTransformer - reshape container response {#2-containerdatatransformer---reshape-container-response} Real scenario: CCF returns nested payload; you flatten to schema-friendly map. <CodeBlockToggle title=\"ContainerDataTransformer example\" language=\"java\" packagePath=\"com.zapper.convengine.transformers\"> { @Component @ContainerDataTransformer(intent = \"REQUEST_TRACKER\", state = \"IDLE\") public class RequestTrackerContainerTransformer implements ContainerDataTransformerHandler { @Override public Map<String, Object> transform(ContainerComponentResponse response, EngineSession session, Map<String, Object> inputParams) { Map<String, Object> out = new LinkedHashMap<>(); out.put(\"ticket_id\", inputParams.get(\"ticketId\")); out.put(\"status\", \"IN_REVIEW\"); return out; } } } </CodeBlockToggle> ## ResponseTransformer - post-process final payload {#3-responsetransformer---post-process-final-payload} Real scenario: Add support-team escalation footer for high-severity disconnect failures. <CodeBlockToggle title=\"ResponseTransformer example\" language=\"java\" packagePath=\"com.zapper.convengine.transformers\"> { @Component @ResponseTransformer(intent = \"DISCONNECT_ELECTRICITY\", state = \"FAILED\") public class DisconnectFailureResponseTransformer implements ResponseTransformerHandler { @Override public OutputPayload transform(OutputPayload responsePayload, EngineSession session, Map<String, Object> inputParams) { if (responsePayload instanceof TextPayload(String text)) { return new TextPayload(text + \"\\\\nIf this is urgent, call support at +1-800-000-0000.\"); } return responsePayload; } } } </CodeBlockToggle> ## ContainerDataInterceptor - intercept request/response around CCF {#4-containerdatainterceptor---intercept-requestresponse-around-ccf} Real scenario: add tenant metadata and redact a field before persistence. <CodeBlockToggle title=\"Interceptor scenario (concept)\" language=\"text\"> { Before Execute: - inject tenantId/requestId - attach observability headers After Execute: - redact sensitive node from raw container payload - enrich session input params for downstream rule checks } </CodeBlockToggle> ## ConvEngineVerboseAdapter - publish UI verbose messages from consumer code {#5-convengineverboseadapter---publish-ui-verbose-messages-from-consumer-code} Use this when hooks, transformers, or custom Spring beans need to emit progress/error messages to the UI without embedding transport code. <CodeBlockToggle title=\"Verbose adapter example\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\"> { @Component @RequiredArgsConstructor public class LoanConfirmationHook implements EngineStepHook { private final ConvEngineVerboseAdapter verboseAdapter; @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { verboseAdapter.publish(session, this, \"PRECHECK_STARTED\"); verboseAdapter.publishText( session, this, \"PRECHECK_NOTE\", \"Reviewing customer [[\\${context.customerId}]] in state [[\\${state}]].\" ); } } } </CodeBlockToggle> What it gives you: - publish(session, this, \"TOKEN\") : DB-backed ce_verbose lookup using this.getClass().getSimpleName() - publish(session, this, \"TOKEN\", metadata) : same, with extra metadata for resolver matching and rendering - publishError(...) : same path, error branch - publishText(...) : bypasses ce_verbose row lookup and sends direct text, still rendered through Thymeleaf Recommended pattern: - use publish(...) when the wording should be controlled by ce_verbose - use publishText(...) when the wording should come directly from consumer Java ## Rule Action Playbook ( SET_TASK , SET_JSON , GET_CONTEXT , GET_SESSION , SET_INPUT_PARAM , SET_DIALOGUE_ACT ) {#6-rule-action-playbook-set_task-set_json-get_context-get_session-set_input_param-set_dialogue_act} These actions execute inside <MethodRef>RulesStep.execute(...)</MethodRef> and mutate the live <MethodRef>EngineSession</MethodRef>. Set <MethodRef>ce_rule.phase</MethodRef> based on where you want the action to run: - <MethodRef>POST_DIALOGUE_ACT</MethodRef>: immediately after <MethodRef>DialogueActStep</MethodRef>, before <MethodRef>InteractionPolicyStep</MethodRef>. - <MethodRef>PRE_RESPONSE_RESOLUTION</MethodRef>: normal <MethodRef>RulesStep</MethodRef> pass. - <MethodRef>POST_AGENT_INTENT</MethodRef>: post-intent pass inside <MethodRef>AgentIntentResolver</MethodRef>. <DbTable title=\"Action value format (exact runtime behavior)\" columns={[\"Action\", \"action_value format\", \"Engine behavior\"]} rows={[ [\"SET_TASK\", \"beanName:methodName or beanName:methodA,methodB\", \"Invokes Spring bean methods via CeRuleTaskExecutor\"], [\"SET_JSON\", \"targetKey:jsonPath\", \"Extracts JSONPath from session eject and stores into inputParams[targetKey]\"], [\"GET_CONTEXT\", \"targetKey (optional)\", \"Stores session.contextDict() into inputParams[targetKey] (default key=context)\"], [\"GET_SESSION\", \"targetKey (optional)\", \"Stores session.sessionDict() into inputParams[targetKey] (default key=session)\"], [\"SET_INPUT_PARAM\", \"{\\\"key\\\":value,...}\", \"Writes literal runtime flags directly into inputParams\"], [\"SET_DIALOGUE_ACT\", \"\\\"EDIT\\\" or {\\\"dialogueAct\\\":\\\"EDIT\\\",...}\", \"Overrides final dialogue_act / confidence / source and can sync standalone_query\"], ]} /> ### SET_TASK - execute consumer Java methods from rule {#51-set_task---execute-consumer-java-methods-from-rule} Use this when a rule match must trigger consumer-side business logic (incident raise, tracker lookup, eligibility fetch, etc). <FlowStep step=\"1\" title=\"Create ce_rule row\"> Set <MethodRef>ce_rule.action</MethodRef> to <MethodRef>SET_TASK</MethodRef> and provide bean/method mapping in <MethodRef>action_value</MethodRef>. </FlowStep> <CodeBlockToggle title=\"SET_TASK rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PRE_RESPONSE_RESOLUTION', 'REQUEST_TRACKER', 'ANY', 'REGEX', '(?i).*track.*request.*', 'SET_TASK', 'requestTrackerTask:loadStatus,attachEta', 10, true, 'Load tracker status + ETA from consumer service'); } </CodeBlockToggle> <FlowStep step=\"2\" title=\"Implement task bean\"> Bean must be a Spring bean with the configured bean name and implement <MethodRef>CeRuleTask</MethodRef>. Methods are invoked with <MethodRef>(EngineSession session, CeRule rule)</MethodRef>. </FlowStep> <CodeBlockToggle title=\"Consumer task bean (Java)\" language=\"java\" packagePath=\"com.zapper.convengine.tasks\" filePath=\"src/main/java/com/acme/convengine/tasks/RequestTrackerTask.java\" > { @Component(\"requestTrackerTask\") public class RequestTrackerTask implements CeRuleTask { public void loadStatus(EngineSession session, CeRule rule) { String requestId = String.valueOf(session.getInputParams().getOrDefault(\"requestId\", \"\")); // fetch from your DB/service session.putInputParam(\"requestStatus\", \"APPROVAL_PENDING\"); session.putInputParam(\"lastUpdated\", \"2026-02-10T11:40:00Z\"); } public void attachEta(EngineSession session, CeRule rule) { session.putInputParam(\"eta_hours\", 12); } } } </CodeBlockToggle> <FlowStep step=\"3\" title=\"Use in response generation\"> Downstream prompt/response can read new context/inputParams (for example requestStatus , lastUpdated , eta_hours ). </FlowStep> ### SET_JSON - move JSONPath value into input params {#52-set_json---move-jsonpath-value-into-input-params} Use this to extract one value from runtime session JSON into a flat prompt var. <CodeBlockToggle title=\"SET_JSON rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PRE_RESPONSE_RESOLUTION', 'LOG_ANALYSIS', 'ANY', 'JSON_PATH', '$.schemaJson.errorCode != null', 'SET_JSON', 'error_code:$.schemaJson.errorCode', 20, true, 'Expose extracted errorCode as prompt var'); } </CodeBlockToggle> <Highlight type=\"info\" title=\"What exactly gets updated\"> SET_JSON writes to <MethodRef>session.putInputParam(\"error_code\", value)</MethodRef>. It does not change session.contextJson unless your subsequent task/hook updates context explicitly. </Highlight> ### GET_CONTEXT - snapshot context into input params {#53-get_context---snapshot-context-into-input-params} Use this when prompt templates or tasks need full context as a single variable. <CodeBlockToggle title=\"GET_CONTEXT rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PRE_RESPONSE_RESOLUTION', 'REQUEST_TRACKER', 'ANY', 'REGEX', '(?i).*status.*', 'GET_CONTEXT', 'ctx_snapshot', 30, true, 'Expose full context to prompt/task layer'); } </CodeBlockToggle> If action_value is blank, engine uses default key context . ### GET_SESSION - snapshot session facts into input params {#54-get_session---snapshot-session-facts-into-input-params} Use this for advanced derived responses that need runtime flags ( schemaComplete , intentLocked , missingRequiredFields , etc). <CodeBlockToggle title=\"GET_SESSION rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PRE_RESPONSE_RESOLUTION', 'DISCONNECT_ELECTRICITY', 'ANY', 'JSON_PATH', '$.schemaComplete == false', 'GET_SESSION', 'session_snapshot', 40, true, 'Expose full runtime session facts for follow-up prompt decisions'); } </CodeBlockToggle> If action_value is blank, engine uses default key session . ### SET_INPUT_PARAM - write runtime flags directly {#65-set_input_param---write-runtime-flags-directly} Use this when you need lightweight runtime variables for later rules/steps without creating a custom task bean. <CodeBlockToggle title=\"SET_INPUT_PARAM rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('POST_SCHEMA_EXTRACTION', 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'JSON_PATH', '$[?(@.schemaComplete == true)]', 'SET_INPUT_PARAM', '{\"awaiting_confirmation\":true,\"confirmation_key\":\"LOAN_APPLICATION_CONFIRM\"}', 11, true, 'Mark confirmation flags after schema becomes complete'); } </CodeBlockToggle> Typical uses: - awaiting_confirmation - confirmation_key - skip_schema_extraction - routing_decision - correction_applied This is the clean way to make later ce_rule phases react to: - confirmation answers ( AFFIRM / NEGATE ) - correction routing - post-schema, pre-MCP gating ### SET_DIALOGUE_ACT - override final dialogue-act after classification {#66-set_dialogue_act---override-final-dialogue-act-after-classification} Use this when DialogueActStep correctly preserves an LLM candidate (for example dialogue_act_llm_candidate=EDIT ) but the final guarded result should be overridden before InteractionPolicyStep . This is especially useful in POST_DIALOGUE_ACT . <CodeBlockToggle title=\"SET_DIALOGUE_ACT rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('POST_DIALOGUE_ACT', 'LOAN_APPLICATION', 'ANY', 'JSON_PATH', '$[?(@.inputParams.dialogue_act == ''NEW_REQUEST'' && @.inputParams.dialogue_act_source == ''REGEX_GUARD'' && @.inputParams.dialogue_act_llm_candidate == ''EDIT'')]', 'SET_DIALOGUE_ACT', '{\"dialogueAct\":\"EDIT\",\"source\":\"POST_DIALOGUE_ACT_RULE\"}', 5, true, 'Promote guarded LLM EDIT back to EDIT before interaction policy'); } </CodeBlockToggle> Accepted action_value formats: - simple string: EDIT - structured JSON: {\"dialogueAct\":\"EDIT\",\"confidence\":0.99,\"source\":\"POST_DIALOGUE_ACT_RULE\",\"standaloneQuery\":\"...\"} SET_DIALOGUE_ACT updates: - dialogue_act - dialogue_act_confidence - dialogue_act_source - optional standalone_query (which also refreshes resolved_user_input ) <Highlight type=\"warning\" title=\"Operational guardrails\"> SET_TASK methods run during rule execution. Keep methods deterministic and idempotent. For side-effecting calls (ticket creation, webhook dispatch), guard with strict rule conditions and add idempotency keys from <MethodRef>conversationId</MethodRef>. </Highlight> <Highlight type=\"tip\" title=\"Where to trace this in code\"> <div className=\"ce-chip-groups\"> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Resolvers</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/SetTaskActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/SetJsonActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/GetContextActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/GetSessionActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/SetDialogueActActionResolver.java</FileRef></span> </div> </div> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Task invocation</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/rule/task/CeRuleTaskExecutor.java</FileRef></span> </div> </div> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Execution loop</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/steps/RulesStep.java</FileRef></span> </div> </div> </div> </Highlight> ### Custom action resolver ( RuleActionResolver ) {#66-custom-action-resolver-ruleactionresolver} Consumer can define a brand-new rule action without changing framework core. <FlowStep step=\"1\" title=\"Create custom resolver bean\"> Implement <MethodRef>RuleActionResolver</MethodRef> and return your action name from <MethodRef>action()</MethodRef>. </FlowStep> <CodeBlockToggle title=\"Custom RuleActionResolver example\" language=\"java\" packagePath=\"com.zapper.convengine.rules\" filePath=\"src/main/java/com/acme/convengine/rules/EnrichCustomerTierActionResolver.java\" > { @Component public class EnrichCustomerTierActionResolver implements RuleActionResolver { @Override public String action() { return \"ENRICH_TIER\"; } @Override public void resolve(EngineSession session, CeRule rule) { // action_value example: customerTier:PREMIUM String raw = rule.getActionValue() == null ? \"\" : rule.getActionValue(); String[] parts = raw.split(\":\", 2); String key = parts.length > 0 && !parts[0].isBlank() ? parts[0] : \"customerTier\"; String value = parts.length > 1 ? parts[1] : \"STANDARD\"; session.putInputParam(key, value); } } } </CodeBlockToggle> <FlowStep step=\"2\" title=\"Use action in ce_rule\"> Set <MethodRef>ce_rule.action</MethodRef> to your custom token (case-insensitive lookup), for example <MethodRef>ENRICH_TIER</MethodRef>. </FlowStep> <CodeBlockToggle title=\"ce_rule row for custom action\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PRE_RESPONSE_RESOLUTION', 'REQUEST_TRACKER', 'REGEX', '(?i).*vip.*', 'ENRICH_TIER', 'customerTier:PREMIUM', 5, true, 'Mark VIP tier for downstream response logic'); } </CodeBlockToggle> <Highlight type=\"tip\" title=\"Auto-registration behavior\"> No manual factory config is needed. <DocTermPopup term=\"Auto-registration behavior\">RuleActionResolverFactory auto-registration behavior</DocTermPopup> auto-discovers all Spring beans implementing <MethodRef>RuleActionResolver</MethodRef> and maps by <MethodRef>action().toUpperCase()</MethodRef>. </Highlight> </div>",
    "excerpt": "Extension Points and Intervention Scenarios EngineStepHook intervene between any steps Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. @Override public void beforeStep(EngineS…"
  },
  {
    "id": "consumer/index.mdx",
    "version": "v2",
    "title": "index",
    "permalink": "/docs/v2/consumer",
    "content": "Consumer Integration What changed in integration Configure behavior via convengine.flow. Use ce_pending_action for confirmable actions Prefer rules/policy over custom Java branching Add tool executors through tool group adapters Minimum setup @EnableConvEngine LlmClient implementation DDL + seed for required ce_ tables response/rule rows for initial and terminal states Dive deeper",
    "rawContent": "# Consumer Integration ## What changed in integration - Configure behavior via convengine.flow.* - Use ce_pending_action for confirmable actions - Prefer rules/policy over custom Java branching - Add tool executors through tool-group adapters ## Minimum setup - @EnableConvEngine - LlmClient implementation - DDL + seed for required ce_* tables - response/rule rows for initial and terminal states ## Dive deeper - [New Consumer Onboarding](/docs/v2/consumer/new-consumer-onboarding) - [Backend Integration](/docs/v2/consumer/backend-integration) - [Caching & Persistence](/docs/v2/consumer/caching-and-persistence) - [Configuration](/docs/v2/consumer/configuration) - [CE Verbose (table + SQL + runtime usage)](/docs/v2/deep-dive/verbose-and-conversation-runtime) - [Annotations Reference](/docs/v2/consumer/annotations-reference) - [Extensions](/docs/v2/consumer/extensions) - [Session Reset & Continuity](/docs/v2/consumer/session-reset-and-continuity) - [MCP Basics](/docs/v2/consumer/mcp/basics) - [MCP Advanced Guide](/docs/v2/consumer/mcp/advanced) - [MCP Example 1 (Mockey + Demo)](/docs/v2/consumer/mcp/example1) - [MCP Example 2 - Loan Application](/docs/v2/consumer/mcp/example2) - [MCP Example 3 - Loan Application Extended](/docs/v2/consumer/mcp/example3) - [UI Integration](/docs/v2/consumer/ui-integration)",
    "excerpt": "Consumer Integration What changed in integration Configure behavior via convengine.flow. Use ce_pending_action for confirmable actions Prefer rules/policy over custom Java branching Add tool executors through tool group …"
  },
  {
    "id": "consumer/mcp/advanced.mdx",
    "version": "v2",
    "title": "advanced",
    "permalink": "/docs/v2/consumer/mcp/advanced",
    "content": "MCP Advanced Guide (v2.0.7) This page documents the production MCP model in ConvEngine 2.0.7 , including planner guardrails, post phase rules, and MCP context metadata used by ce_rule JSON_PATH. Read order 1. 2. MCP Advanced Guide (this page) 3. 4. 5. 6. 7. Phase names (current) PRE_RESPONSE_RESOLUTION POST_AGENT_INTENT POST_AGENT_MCP POST_TOOL_EXECUTION Compatibility note: legacy values ( PIPELINE_RULES , AGENT_POST_INTENT , AGENT_POST_MCP , TOOL_POST_EXECUTION ) are normalized at runtime. Tool execution paths Planner MCP path ( McpToolStep ) 1. Planner returns CALL_TOOL or ANSWER . 2. Tool results are appended to context.mcp.observations . 3. For ANSWER , final text is written to context.mcp.finalAnswer . 4. Rules run in phase POST_AGENT_MCP . 5. Response resolution runs after rule transitions. Direct tool path ( ToolOrchestrationStep ) 1. Request contains tool_request . 2. Exactly one tool executes. 3. Result stored in inputParams.tool_result and context.mcp.toolExecution . 4. Rules run in phase POST_TOOL_EXECUTION . 5. Response resolution runs with updated state/context. Guardrail blocked answer semantics When MCP_STATUS=GUARDRAIL_BLOCKED_NEXT_TOOL : 1. McpToolStep writes fallback text ( McpConstants.FALLBACK_GUARDRAIL_BLOCKED ) to context.mcp.finalAnswer . 2. Rules in POST_AGENT_MCP still execute. 3. ce_response remains the final response authority (commonly DERIVED using context.mcp.finalAnswer ). MCP metadata model for rules context.mcp.lifecycle : phase , status , outcome , finished blocked , error , errorMessage lastAction , lastToolCode , lastToolGroup , lastToolArgs toolExecuted context.mcp.toolExecution : phase , status , outcome , finished error , scopeMismatch , toolExecuted toolCode , toolGroup , meta , result , errorMessage JSON_PATH patterns you can use in ce_rule.match_pattern text $[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.outcome == 'BLOCKED')] $[?(@.context.mcp.lifecycle.error == true)] $[?(@.context.mcp.toolExecution.phase == 'POST_TOOL_EXECUTION' && @.context.mcp.toolExecution.status == 'SUCCESS')] $[?(@.context.mcp.toolExecution.scopeMismatch == true)] Direct tool example ( POST_TOOL_EXECUTION ) User asks: Check order ORD 7017 status. json } } Execution: ToolOrchestrationStep executes one tool. Writes tool_result + tool_status=SUCCESS . Writes context.mcp.toolExecution. . Executes POST_TOOL_EXECUTION rules. Example: rule sets state to ORDER_SUBMITTED_DIAGNOSIS when tool status is submitted. ce_mcp_tool and ce_mcp_planner scoping rules intent_code and state_code are mandatory (no null/blank scope). Allowed values: intent_code : defined ce_intent.intent_code or ANY or UNKNOWN state_code : values present in ce_rule.state_code or ANY or UNKNOWN Invalid scope rows are blocked at startup by static scope validation. Planner prompt source ( ce_mcp_planner ) Planner prompt selection: 1. exact intent_code + state_code 2. exact intent_code + ANY 3. global ANY + ANY 4. legacy fallback ( ce_config McpPlanner keys) if planner rows are unavailable SQL snippets sql INSERT INTO ce_mcp_planner (planner_id, intent_code, state_code, system_prompt, user_prompt, enabled) VALUES (1001, 'ANY', 'ANY', '...', '...', true), (1002, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', '...', '...', true); sql INSERT INTO ce_mcp_tool (tool_id, tool_code, tool_group, intent_code, state_code, enabled, description) VALUES (9001, 'db.knowledge.graph', 'DB', 'ANY', 'ANY', true, 'DB knowledge graph'), (9002, 'order.status.api', 'HTTP_API', 'ANY', 'ANY', true, 'Order status API'); For MCP chains, keep final user text in ce_response / ce_prompt_template and treat context.mcp.finalAnswer as a derived source, not the final transport payload.",
    "rawContent": "# MCP Advanced Guide (v2.0.7) This page documents the production MCP model in ConvEngine 2.0.7 , including planner guardrails, post-phase rules, and MCP context metadata used by ce_rule JSON_PATH. ## Read order 1. [MCP Basics](/docs/v2/consumer/mcp/basics) 2. MCP Advanced Guide (this page) 3. [MCP HTTP Tool](/docs/v2/consumer/mcp/http-tool) 4. [MCP Deep Dive](/docs/v2/consumer/mcp/deep-dive) 5. [MCP Example 1](/docs/v2/consumer/mcp/example1) 6. [MCP Example 2](/docs/v2/consumer/mcp/example2) 7. [MCP Example 3](/docs/v2/consumer/mcp/example3) ## Phase names (current) - PRE_RESPONSE_RESOLUTION - POST_AGENT_INTENT - POST_AGENT_MCP - POST_TOOL_EXECUTION Compatibility note: legacy values ( PIPELINE_RULES , AGENT_POST_INTENT , AGENT_POST_MCP , TOOL_POST_EXECUTION ) are normalized at runtime. ## Tool execution paths ### Planner MCP path ( McpToolStep ) 1. Planner returns CALL_TOOL or ANSWER . 2. Tool results are appended to context.mcp.observations . 3. For ANSWER , final text is written to context.mcp.finalAnswer . 4. Rules run in phase POST_AGENT_MCP . 5. Response resolution runs after rule transitions. ### Direct tool path ( ToolOrchestrationStep ) 1. Request contains tool_request . 2. Exactly one tool executes. 3. Result stored in inputParams.tool_result and context.mcp.toolExecution . 4. Rules run in phase POST_TOOL_EXECUTION . 5. Response resolution runs with updated state/context. ## Guardrail blocked answer semantics When MCP_STATUS=GUARDRAIL_BLOCKED_NEXT_TOOL : 1. McpToolStep writes fallback text ( McpConstants.FALLBACK_GUARDRAIL_BLOCKED ) to context.mcp.finalAnswer . 2. Rules in POST_AGENT_MCP still execute. 3. ce_response remains the final response authority (commonly DERIVED using context.mcp.finalAnswer ). ## MCP metadata model for rules context.mcp.lifecycle : - phase , status , outcome , finished - blocked , error , errorMessage - lastAction , lastToolCode , lastToolGroup , lastToolArgs - toolExecuted context.mcp.toolExecution : - phase , status , outcome , finished - error , scopeMismatch , toolExecuted - toolCode , toolGroup , meta , result , errorMessage ## JSON_PATH patterns you can use in ce_rule.match_pattern text $[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.outcome == 'BLOCKED')] $[?(@.context.mcp.lifecycle.error == true)] $[?(@.context.mcp.toolExecution.phase == 'POST_TOOL_EXECUTION' && @.context.mcp.toolExecution.status == 'SUCCESS')] $[?(@.context.mcp.toolExecution.scopeMismatch == true)] ## Direct tool example ( POST_TOOL_EXECUTION ) User asks: Check order ORD-7017 status. json { \"tool_request\": { \"tool_code\": \"mock.order.status\", \"tool_group\": \"HTTP_API\", \"args\": { \"orderId\": \"ORD-7017\" } } } Execution: - ToolOrchestrationStep executes one tool. - Writes tool_result + tool_status=SUCCESS . - Writes context.mcp.toolExecution.* . - Executes POST_TOOL_EXECUTION rules. - Example: rule sets state to ORDER_SUBMITTED_DIAGNOSIS when tool status is submitted. ## ce_mcp_tool and ce_mcp_planner scoping rules intent_code and state_code are mandatory (no null/blank scope). Allowed values: - intent_code : defined ce_intent.intent_code or ANY or UNKNOWN - state_code : values present in ce_rule.state_code or ANY or UNKNOWN Invalid scope rows are blocked at startup by static scope validation. ## Planner prompt source ( ce_mcp_planner ) Planner prompt selection: 1. exact intent_code + state_code 2. exact intent_code + ANY 3. global ANY + ANY 4. legacy fallback ( ce_config McpPlanner keys) if planner rows are unavailable ## SQL snippets <Tabs groupId=\"mcp-advanced-sql\"> <TabItem value=\"planner\" label=\"Planner Rows\" default> sql INSERT INTO ce_mcp_planner (planner_id, intent_code, state_code, system_prompt, user_prompt, enabled) VALUES (1001, 'ANY', 'ANY', '...', '...', true), (1002, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', '...', '...', true); </TabItem> <TabItem value=\"tool\" label=\"Tool Rows\"> sql INSERT INTO ce_mcp_tool (tool_id, tool_code, tool_group, intent_code, state_code, enabled, description) VALUES (9001, 'db.knowledge.graph', 'DB', 'ANY', 'ANY', true, 'DB knowledge graph'), (9002, 'order.status.api', 'HTTP_API', 'ANY', 'ANY', true, 'Order status API'); </TabItem> </Tabs> <Highlight type=\"info\" title=\"Recommended response pattern\"> For MCP chains, keep final user text in ce_response / ce_prompt_template and treat context.mcp.finalAnswer as a derived source, not the final transport payload. </Highlight>",
    "excerpt": "MCP Advanced Guide (v2.0.7) This page documents the production MCP model in ConvEngine 2.0.7 , including planner guardrails, post phase rules, and MCP context metadata used by ce_rule JSON_PATH. Read order 1. 2. MCP Adva…"
  },
  {
    "id": "consumer/mcp/basics.mdx",
    "version": "v2",
    "title": "basics",
    "permalink": "/docs/v2/consumer/mcp/basics",
    "content": "MCP Basics This page is the simple mental model for MCP in ConvEngine. What MCP does MCP lets the engine decide and call tools during a chat turn. Basic flow: 1. user asks a question 2. planner chooses CALL_TOOL or ANSWER 3. tool output is stored in context.mcp.observations 4. planner eventually writes context.mcp.finalAnswer 5. response resolver generates final user output Core tables Two execution modes Use planner mode first for real chat behavior. Use direct mode only for deterministic tool testing. Read next",
    "rawContent": "# MCP Basics This page is the simple mental model for MCP in ConvEngine. ## What MCP does MCP lets the engine decide and call tools during a chat turn. Basic flow: 1. user asks a question 2. planner chooses CALL_TOOL or ANSWER 3. tool output is stored in context.mcp.observations 4. planner eventually writes context.mcp.finalAnswer 5. response resolver generates final user output ## Core tables <DbTable title=\"MCP table map\" columns={[\"Table\", \"Purpose\", \"Used by\"]} rows={[ [\"ce_mcp_tool\", \"Tool registry and scope\", \"McpToolStep / ToolOrchestrationStep\"], [\"ce_mcp_db_tool\", \"DB SQL template fallback config\", \"McpDbToolExecutor\"], [\"ce_mcp_planner\", \"Planner prompts by intent/state\", \"McpPlanner\"], ]} /> ## Two execution modes <DbTable title=\"When each mode is used\" columns={[\"Mode\", \"Trigger\", \"Main output\"]} rows={[ [\"Planner mode\", \"Natural chat request (no direct tool_request)\", \"context.mcp.observations + context.mcp.finalAnswer\"], [\"Direct mode\", \"inputParams.tool_request provided\", \"inputParams.tool_result\"], ]} /> <Highlight type=\"tip\" title=\"Start here for testing\"> Use planner mode first for real chat behavior. Use direct mode only for deterministic tool testing. </Highlight> ## Read next - [MCP Advanced Guide](/docs/v2/consumer/mcp/advanced) - [MCP HTTP Tool](/docs/v2/consumer/mcp/http-tool) - [MCP Example 1 (Mockey + Demo)](/docs/v2/consumer/mcp/example1) - [MCP Example 2 - Loan Application](/docs/v2/consumer/mcp/example2) - [MCP Example 3 - Loan Application Extended](/docs/v2/consumer/mcp/example3)",
    "excerpt": "MCP Basics This page is the simple mental model for MCP in ConvEngine. What MCP does MCP lets the engine decide and call tools during a chat turn. Basic flow: 1. user asks a question 2. planner chooses CALL_TOOL or ANSWE…"
  },
  {
    "id": "consumer/mcp/deep-dive.mdx",
    "version": "v2",
    "title": "deep dive",
    "permalink": "/docs/v2/consumer/mcp/deep-dive",
    "content": "}, }, }, }, }, }, }, }, }, }, }, } ]; , , , , , , , , , , ]; u: , i: , s: , c: , pm: , p1: , t1: , p2: , r1: , r2: , rr: , o: }; MCP Deep Dive (v2.0.9) This page shows the exact MCP execution order using the confirmation first Loan Application flow. Exact phase order in the confirmation first loan flow 1. SchemaExtractionStep completes field extraction. 2. POST_SCHEMA_EXTRACTION rules can move the flow into CONFIRMATION . 3. CorrectionStep can patch edits or set routing_decision=PROCEED_CONFIRMED . 4. PRE_AGENT_MCP rules run inside McpToolStep before planner/tool execution and can move CONFIRMATION PROCESS_APPLICATION . 5. POST_AGENT_MCP rules run after MCP work finishes. 6. PRE_RESPONSE_RESOLUTION rules run next. 7. ResponseResolutionStep runs after both rule passes. So yes, MCP turns can now be shaped by both the new pre MCP phase and the existing post MCP / pre response phases. Prompt template interaction semantics ce_prompt_template now carries two fields that consumers should treat as the canonical turn contract: interaction_mode : broad semantics for the turn ( COLLECT , CONFIRM , PROCESSING , FINAL , and related modes) interaction_contract : extensible JSON for concrete capabilities and expectations Recommended interaction_mode values: NORMAL : generic prompt with no special turn contract IDLE : waiting for the user to begin or restate the task COLLECT : gather missing required fields CONFIRM : allow affirm/edit over already collected values PROCESSING : keep work in progress; retry can be enabled here FINAL : terminal response branch ERROR : failure branch DISAMBIGUATE : ask the user to choose between options FOLLOW_UP : follow up question branch PENDING_ACTION : approval/pending action branch REVIEW : evidence review branch Recommended interaction_contract shape: json Current conventions: allows : turn capabilities such as affirm , edit , retry , reset expects : input expectations such as structured_input This is the preferred place to model confirmation and retry semantics. Do not rely on state name substrings such as CONFIRM . Guardrail blocked path For MCP_STATUS=GUARDRAIL_BLOCKED_NEXT_TOOL : 1. McpToolStep writes McpConstants.FALLBACK_GUARDRAIL_BLOCKED to context.mcp.finalAnswer . 2. POST_AGENT_MCP rules run. 3. PRE_RESPONSE_RESOLUTION rules run. 4. ce_response + ce_prompt_template still shape final user text. Example 3: Confirmation first Loan Application CONFIRMATION.\"]} / fraud debt submit.\" json= \" }, \" }, \" }, \" } ], lifecycle: } }} tables= info= / COMPLETED using JSON_PATH on context.mcp.finalAnswer.\", \"PRE_RESPONSE_RESOLUTION runs after that and can still apply final state/context adjustments.\" ]} / CONFIRMATION PRE_AGENT_MCP planner/tool loop POST_AGENT_MCP PRE_RESPONSE_RESOLUTION response\" nodes= edges= detailsById= defaultSelectedId=\"c\" / PROCESS_APPLICATION\"], [\"MCP planner\", \"ce_mcp_tool, ce_mcp_planner\", \"ce_audit\", \"mcp_action/mcp_tool_code\"], [\"Tool execution\", \"(tool specific)\", \"ce_audit\", \"context.mcp.observations[]\"], [\"Planner ANSWER\", \"ce_mcp_planner\", \"ce_audit\", \"context.mcp.finalAnswer + lifecycle\"], [\"POST_AGENT_MCP\", \"ce_rule\", \"ce_audit\", \"MCP driven transition\"], [\"PRE_RESPONSE_RESOLUTION\", \"ce_rule\", \"ce_audit\", \"Final pre response transition\"], [\"Response resolution\", \"ce_response, ce_prompt_template\", \"ce_audit, ce_conversation\", \"assistant payload\"] ]} / } } } Rule ready JSON_PATH recipes text $[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.outcome == 'BLOCKED')] $[?(@.context.mcp.lifecycle.error == true)] $[?(@.context.mcp.toolExecution.phase == 'POST_TOOL_EXECUTION' && @.context.mcp.toolExecution.status == 'SUCCESS')] $[?(@.context.mcp.toolExecution.scopeMismatch == true)] Use ce_rule for deterministic transitions and keep final wording in ce_response / ce_prompt_template . Use context.mcp. as rule evidence, then let response resolution produce final output.",
    "rawContent": "{ id: \"u\", data: { label: \"User input\" } }, { id: \"i\", data: { label: \"Intent + State\" } }, { id: \"s\", data: { label: \"Schema + POST_SCHEMA_EXTRACTION\" } }, { id: \"c\", data: { label: \"CONFIRMATION\" } }, { id: \"pm\", data: { label: \"PRE_AGENT_MCP\" } }, { id: \"p1\", data: { label: \"Planner loop\" } }, { id: \"t1\", data: { label: \"Tool calls\" } }, { id: \"p2\", data: { label: \"Planner ANSWER\" } }, { id: \"r1\", data: { label: \"POST_AGENT_MCP rules\" } }, { id: \"r2\", data: { label: \"PRE_RESPONSE_RESOLUTION rules\" } }, { id: \"rr\", data: { label: \"ResponseResolutionStep\" } }, { id: \"o\", data: { label: \"Assistant output\" } } ]; { id: \"e1\", source: \"u\", target: \"i\" }, { id: \"e2\", source: \"i\", target: \"s\" }, { id: \"e3\", source: \"s\", target: \"c\" }, { id: \"e4\", source: \"c\", target: \"pm\" }, { id: \"e5\", source: \"pm\", target: \"p1\" }, { id: \"e6\", source: \"p1\", target: \"t1\" }, { id: \"e7\", source: \"t1\", target: \"p2\" }, { id: \"e8\", source: \"p2\", target: \"r1\" }, { id: \"e9\", source: \"r1\", target: \"r2\" }, { id: \"e10\", source: \"r2\", target: \"rr\" }, { id: \"e11\", source: \"rr\", target: \"o\" } ]; u: { title: \"User input\", stage: \"REQUEST\", summary: \"Loan application request enters the engine.\", session: [\"userText\"], tables: [\"ce_audit (W)\"] }, i: { title: \"Intent + State\", stage: \"INTENT\", summary: \"Classifier resolves LOAN_APPLICATION and initial rules move state into ELIGIBILITY_GATE.\", session: [\"intent=LOAN_APPLICATION\", \"state=ELIGIBILITY_GATE\"], tables: [\"ce_intent (R)\", \"ce_intent_classifier (R)\", \"ce_rule (R)\"] }, s: { title: \"Schema + POST_SCHEMA_EXTRACTION\", stage: \"SCHEMA_EXTRACTION\", summary: \"Schema extraction fills customerId/amount/tenure. POST_SCHEMA_EXTRACTION moves the flow to CONFIRMATION once complete.\", session: [\"context fields extracted\", \"state=CONFIRMATION\"], tables: [\"ce_output_schema (R)\", \"ce_prompt_template (R)\", \"ce_rule (R)\", \"ce_audit (W)\"] }, c: { title: \"CONFIRMATION\", stage: \"CORRECTION\", summary: \"CorrectionStep handles edits in place and routes affirmations forward with routing_decision.\", session: [\"routing_decision\", \"skip_schema_extraction\"], tables: [\"ce_audit (W)\"] }, pm: { title: \"PRE_AGENT_MCP\", stage: \"RULES\", summary: \"PRE_AGENT_MCP is the last chance to move CONFIRMATION into PROCESS_APPLICATION before MCP starts.\", session: [\"state=PROCESS_APPLICATION\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"] }, p1: { title: \"Planner loop\", stage: \"MCP_PLAN_LLM_OUTPUT\", summary: \"Planner selects next action CALL_TOOL/ANSWER from scoped tools and planner prompt.\", session: [\"mcp_action\", \"mcp_tool_code\", \"mcp_tool_args\"], tables: [\"ce_mcp_tool (R)\", \"ce_mcp_planner (R)\", \"ce_audit (W)\"] }, t1: { title: \"Tool calls\", stage: \"MCP_TOOL_RESULT\", summary: \"Loan chain runs: rating -> fraud -> debt -> submit (conditionally).\", session: [\"context.mcp.observations[]\"], tables: [\"ce_audit (W)\"] }, p2: { title: \"Planner ANSWER\", stage: \"MCP_FINAL_ANSWER\", summary: \"Planner writes final result into context.mcp.finalAnswer.\", session: [\"mcp_final_answer\", \"context.mcp.lifecycle.*\"], tables: [\"ce_audit (W)\"] }, r1: { title: \"POST_AGENT_MCP rules\", stage: \"RULES\", summary: \"Post-MCP rules react to context.mcp.finalAnswer and MCP metadata.\", session: [\"state mutation candidates\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"] }, r2: { title: \"PRE_RESPONSE_RESOLUTION rules\", stage: \"RULES\", summary: \"General pre-response rule pass runs after POST_AGENT_MCP.\", session: [\"final state/context before resolution\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"] }, rr: { title: \"ResponseResolutionStep\", stage: \"RESOLVE_RESPONSE\", summary: \"Resolves ce_response + ce_prompt_template from final intent/state/context.\", session: [\"payload\"], tables: [\"ce_response (R)\", \"ce_prompt_template (R)\"] }, o: { title: \"Assistant output\", stage: \"ASSISTANT_OUTPUT\", summary: \"Final response is returned and conversation/audit persisted.\", session: [\"finalResult\"], tables: [\"ce_conversation (W)\", \"ce_conversation_history (W async)\", \"ce_audit (W)\"] } }; # MCP Deep Dive (v2.0.9) This page shows the exact MCP execution order using the confirmation-first Loan Application flow. ## Exact phase order in the confirmation-first loan flow 1. SchemaExtractionStep completes field extraction. 2. POST_SCHEMA_EXTRACTION rules can move the flow into CONFIRMATION . 3. CorrectionStep can patch edits or set routing_decision=PROCEED_CONFIRMED . 4. PRE_AGENT_MCP rules run inside McpToolStep before planner/tool execution and can move CONFIRMATION -> PROCESS_APPLICATION . 5. POST_AGENT_MCP rules run after MCP work finishes. 6. PRE_RESPONSE_RESOLUTION rules run next. 7. ResponseResolutionStep runs after both rule passes. So yes, MCP turns can now be shaped by both the new pre-MCP phase and the existing post-MCP / pre-response phases. ## Prompt-template interaction semantics ce_prompt_template now carries two fields that consumers should treat as the canonical turn contract: - interaction_mode : broad semantics for the turn ( COLLECT , CONFIRM , PROCESSING , FINAL , and related modes) - interaction_contract : extensible JSON for concrete capabilities and expectations Recommended interaction_mode values: - NORMAL : generic prompt with no special turn contract - IDLE : waiting for the user to begin or restate the task - COLLECT : gather missing required fields - CONFIRM : allow affirm/edit over already-collected values - PROCESSING : keep work in progress; retry can be enabled here - FINAL : terminal response branch - ERROR : failure branch - DISAMBIGUATE : ask the user to choose between options - FOLLOW_UP : follow-up question branch - PENDING_ACTION : approval/pending-action branch - REVIEW : evidence review branch Recommended interaction_contract shape: json {\"allows\":[\"affirm\",\"edit\",\"retry\",\"reset\"],\"expects\":[\"structured_input\"]} Current conventions: - allows : turn capabilities such as affirm , edit , retry , reset - expects : input expectations such as structured_input This is the preferred place to model confirmation and retry semantics. Do not rely on state name substrings such as CONFIRM . ## Guardrail blocked path For MCP_STATUS=GUARDRAIL_BLOCKED_NEXT_TOOL : 1. McpToolStep writes McpConstants.FALLBACK_GUARDRAIL_BLOCKED to context.mcp.finalAnswer . 2. POST_AGENT_MCP rules run. 3. PRE_RESPONSE_RESOLUTION rules run. 4. ce_response + ce_prompt_template still shape final user text. ## Example 3: Confirmation-first Loan Application <Tabs groupId=\"mcp-deep-dive-main\"> <TabItem value=\"chat\" label=\"Chat + Internal Trace\" default> <ChatContainer> <TraceChatBubble role=\"user\" name=\"Turn 1 - User\" message=\"I need a loan for my customer. Customer id 1234, 35000, 24 months.\" info={[\"Intent resolves to LOAN_APPLICATION.\", \"State enters ELIGIBILITY_GATE and schema extraction runs.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 1 - Assistant\" message=\"Please confirm: customerId 1234, requestedAmount 35000, tenureMonths 24. Proceed?\" json={{ routing_decision: \"CONTINUE_STANDARD_FLOW\", state: \"CONFIRMATION\" }} tables={[\"ce_output_schema (R)\", \"ce_rule (POST_SCHEMA_EXTRACTION)\", \"ce_audit (W)\"]} info={[\"Schema is complete, so POST_SCHEMA_EXTRACTION moves ELIGIBILITY_GATE -> CONFIRMATION.\"]} /> <TraceChatBubble role=\"user\" name=\"Turn 2 - User\" message=\"Oh wait, change amount to 350000.\" info={[\"DialogueActStep resolves EDIT.\", \"CorrectionStep patches only requestedAmount and keeps state in CONFIRMATION.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 2 - Assistant\" message=\"Updated. Please confirm: customerId 1234, requestedAmount 350000, tenureMonths 24. Proceed?\" json={{ routing_decision: \"APPLY_CORRECTION\", correction_applied: true, correction_target_field: \"requestedAmount\", state: \"CONFIRMATION\" }} tables={[\"ce_audit (W)\"]} info={[\"No full schema re-extraction is needed for the single-field correction path.\"]} /> <TraceChatBubble role=\"user\" name=\"Turn 3 - User\" message=\"Looks good, go ahead.\" info={[\"DialogueActStep resolves AFFIRM.\", \"CorrectionStep sets routing_decision=PROCEED_CONFIRMED.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 3 - Internal MCP Loop\" message=\"PRE_AGENT_MCP moves state to PROCESS_APPLICATION. Planner executes rating -> fraud -> debt -> submit.\" json={{ mcp: { observations: [ { toolCode: \"loan.credit.rating.check\", json: \"{\\\"creditRating\\\":782}\" }, { toolCode: \"loan.credit.fraud.check\", json: \"{\\\"flagged\\\":false}\" }, { toolCode: \"loan.debt.credit.summary\", json: \"{\\\"dti\\\":0.31,\\\"availableCredit\\\":220000}\" }, { toolCode: \"loan.application.submit\", json: \"{\\\"applicationId\\\":\\\"LA-90311\\\",\\\"status\\\":\\\"SUBMITTED\\\"}\" } ], lifecycle: { phase: \"POST_AGENT_MCP\", status: \"TOOL_RESULT\", outcome: \"IN_PROGRESS\", finished: false, toolExecuted: true, lastToolCode: \"loan.application.submit\" } } }} tables={[\"ce_rule (PRE_AGENT_MCP)\", \"ce_mcp_tool (R)\", \"ce_mcp_planner (R)\", \"ce_audit (W)\"]} info={[\"Tool results append to context.mcp.observations after CONFIRMATION -> PROCESS_APPLICATION.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 3 - Rules + Final\" message=\"Loan application submitted for customer 1234. Amount 350000, tenure 24 months. Application ID LA-90311.\" json={{ mcp: { finalAnswer: \"Loan approved and submitted with applicationId LA-90311.\", lifecycle: { phase: \"POST_AGENT_MCP\", status: \"ANSWER\", outcome: \"ANSWERED\", finished: true, blocked: false, error: false } }, state: \"COMPLETED\" }} tables={[\"ce_rule (R)\", \"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_conversation (W)\"]} info={[ \"POST_AGENT_MCP can move PROCESS_APPLICATION -> COMPLETED using JSON_PATH on context.mcp.finalAnswer.\", \"PRE_RESPONSE_RESOLUTION runs after that and can still apply final state/context adjustments.\" ]} /> </ChatContainer> </TabItem> <TabItem value=\"flow\" label=\"Step Graph\"> <EngineDebugFlow title=\"Loan MCP flow\" subtitle=\"Schema -> CONFIRMATION -> PRE_AGENT_MCP -> planner/tool loop -> POST_AGENT_MCP -> PRE_RESPONSE_RESOLUTION -> response\" nodes={mcpDeepNodes} edges={mcpDeepEdges} detailsById={mcpDeepDetails} defaultSelectedId=\"c\" /> </TabItem> <TabItem value=\"table\" label=\"Turn Table\"> <DbTable title=\"Table impact by stage\" columns={[\"Stage\", \"Reads\", \"Writes\", \"Context impact\"]} rows={[ [\"Intent/State\", \"ce_intent, ce_intent_classifier, ce_rule\", \"ce_audit\", \"session.intent/session.state\"], [\"Schema + confirm gate\", \"ce_output_schema, ce_prompt_template, ce_rule\", \"ce_audit\", \"state=CONFIRMATION, routing_decision\"], [\"PRE_AGENT_MCP\", \"ce_rule\", \"ce_audit\", \"CONFIRMATION -> PROCESS_APPLICATION\"], [\"MCP planner\", \"ce_mcp_tool, ce_mcp_planner\", \"ce_audit\", \"mcp_action/mcp_tool_code\"], [\"Tool execution\", \"(tool-specific)\", \"ce_audit\", \"context.mcp.observations[]\"], [\"Planner ANSWER\", \"ce_mcp_planner\", \"ce_audit\", \"context.mcp.finalAnswer + lifecycle\"], [\"POST_AGENT_MCP\", \"ce_rule\", \"ce_audit\", \"MCP-driven transition\"], [\"PRE_RESPONSE_RESOLUTION\", \"ce_rule\", \"ce_audit\", \"Final pre-response transition\"], [\"Response resolution\", \"ce_response, ce_prompt_template\", \"ce_audit, ce_conversation\", \"assistant payload\"] ]} /> </TabItem> <TabItem value=\"direct\" label=\"Direct Tool Mode\"> <CodeBlockToggle title=\"Direct tool request\" language=\"json\"> { { \"tool_request\": { \"tool_code\": \"loan.credit.rating.check\", \"tool_group\": \"HTTP_API\", \"args\": { \"customerId\": \"CUST-1001\" } } } } </CodeBlockToggle> <DbTable title=\" POST_TOOL_EXECUTION sequence\" columns={[\"Step\", \"What happens\"]} rows={[ [\"ToolOrchestrationStep\", \"Executes exactly one tool and writes inputParams.tool_result.\"], [\"Context metadata\", \"Writes context.mcp.toolExecution with status/outcome/meta/result.\"], [\"Rules\", \"Runs POST_TOOL_EXECUTION rules for direct-tool mode.\"], [\"RulesStep\", \"Runs PRE_RESPONSE_RESOLUTION rules before response resolution.\"], [\"Response\", \"ResponseResolutionStep uses final state/context.\"] ]} /> </TabItem> </Tabs> ## Rule-ready JSON_PATH recipes text $[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.outcome == 'BLOCKED')] $[?(@.context.mcp.lifecycle.error == true)] $[?(@.context.mcp.toolExecution.phase == 'POST_TOOL_EXECUTION' && @.context.mcp.toolExecution.status == 'SUCCESS')] $[?(@.context.mcp.toolExecution.scopeMismatch == true)] <Highlight type=\"tip\" title=\"Recommended production pattern\"> Use ce_rule for deterministic transitions and keep final wording in ce_response / ce_prompt_template . Use context.mcp.* as rule evidence, then let response resolution produce final output. </Highlight>",
    "excerpt": "}, }, }, }, }, }, }, }, }, }, }, } ]; , , , , , , , , , , ]; u: , i: , s: , c: , pm: , p1: , t1: , p2: , r1: , r2: , rr: , o: }; MCP Deep Dive (v2.0.9) This page shows the exact MCP execution order using the confirmation…"
  },
  {
    "id": "consumer/mcp/example1.mdx",
    "version": "v2",
    "title": "example1",
    "permalink": "/docs/v2/consumer/mcp/example1",
    "content": "}, }, }, }, }, }, }, }, }, }, ]; , , , , , , , , , ]; u1: , i1: , m1: , t1: , m2: , t2: , m3: , r2: , r1: , out: }; MCP Example 1 (ConvEngine Demo + Mockey) This guide shows a complete local test of ConvEngine 2.0.7 advanced MCP HTTP tools using convengine demo and . It covers: 1. starting mock APIs in 2. wiring demo MCP tools to endpoints 3. seeding ce_mcp_tool and planner prompts 4. testing via SQL panel + chat requests Prerequisites repo available locally convengine demo repo available locally Postgres running for convengine demo ConvEngine dependency 2.0.7 What is already wired in demo convengine demo now includes four HttpApiRequestingToolHandler mappings: mock.order.submit POST /api/mock/order/submit mock.order.status GET /api/mock/order/status mock.order.async.trace GET /api/mock/order/async/trace mock.customer.profile GET /api/mock/customer/profile Base URL is configured by: yaml convengine: demo: mockey: base url: http://localhost:31333 api key: demo live key Step 1: Start From root: bash npm install npm start Expected log: text listening to 31333 Step 2: Quick endpoint smoke tests bash curl s \"http://localhost:31333/api/mock/order/status?orderId=ORD 7017\" curl s \"http://localhost:31333/api/mock/order/async/trace?orderId=ORD 7017\" curl s \"http://localhost:31333/api/mock/customer/profile?customerId=CUST 1001\" curl s X POST \"http://localhost:31333/api/mock/order/submit\" H \"Content Type: application/json\" d ' ' Step 3: Start convengine demo From convengine demo root: bash ./mvnw spring boot:run Step 4: Seed MCP tools and planner prompts (SQL panel) Run convengine demo/src/main/resources/sql/seed.sql . That seed includes the live MCP tools and ORDER_DIAGNOSTICS response/rule wiring (ANALYZE COMPLETED via POST_AGENT_MCP when context.mcp.finalAnswer exists): sql INSERT INTO ce_mcp_tool (tool_id, tool_code, tool_group, intent_code, state_code, enabled, description) VALUES (3, 'mock.order.submit', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Submit order through mockey live API'), (4, 'mock.order.status', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Fetch order status from mockey live API'), (5, 'mock.order.async.trace', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Fetch async callback trace from mockey live API'), (6, 'mock.customer.profile', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Fetch customer profile from mockey live API'); Then seed planner prompts (framework seed) if your environment uses scoped MCP planner rows: Postgres: convengine/src/main/resources/sql/mcp_planner_seed.sql (or mcp_planner_seed_postgres.sql ) SQLite: convengine/src/main/resources/sql/mcp_planner_seed_sqlite.sql Step 5: Run as chat style walkthrough mock.order.async.trace\" json= }\" }, }\" } ] } }} tables= info= / COMPLETED when context.mcp.finalAnswer exists.\", \"ResponseResolutionStep uses context + derivation_hint.\"]} / json \", \"inputParams\": } Direct deterministic tool payload (optional): json \", \"inputParams\": } } } Step 6: Validate advanced HTTP behavior HttpApiRequestingToolHandler calls are executed by framework HttpApiToolInvoker . Observation payload will include: status attempt latencyMs mapped Expected shape: json } Step 7: Verify MCP audit stages Check audit timeline in audit APIs for: TOOL_ORCHESTRATION_REQUEST TOOL_ORCHESTRATION_RESULT MCP_TOOL_CALL MCP_TOOL_RESULT MCP Output to Final Response (Deep Dive) This is the exact handoff path from MCP tools to response text/json in the same request turn: 1. McpToolStep clears stale context.mcp. at start of turn. 2. Planner ( McpPlanner ) receives user_input , context , mcp_tools , and current mcp_observations . 3. Each CALL_TOOL result is appended into context.mcp.observations[] as . 4. When planner returns ANSWER , step writes: context.mcp.finalAnswer input param mcp_final_answer 5. RulesStep runs POST_AGENT_MCP phase; when context.mcp.finalAnswer exists, rule transitions ANALYZE COMPLETED. 6. ResponseResolutionStep selects ce_response for current intent/state. 7. If selected response is DERIVED , resolver selects matching ce_prompt_template and invokes LLM with: rendered prompt derivation_hint from ce_response session.contextDict() as context (includes the MCP block) 8. Final assistant output is audited ( ASSISTANT_OUTPUT ) and persisted. Even if your template does not explicitly reference mcp_final_answer , it still receives full context JSON. If context.mcp.observations and context.mcp.finalAnswer exist, response derivation can use them. Turn by Turn E2E (Tab View) Example 1: Explicit prompt wiring (recommended) Keep it simple: direct tool_request path uses inputParams.tool_result planner path uses context.mcp.observations and context.mcp.finalAnswer Use these SQL updates so prompt behavior is explicit: sql Direct tool_request path (ToolOrchestrationStep output) UPDATE ce_prompt_template SET user_prompt = 'User input: }\\nTool result: }\\nContext: }\\nSummarize status and next action.' WHERE intent_code = 'FAQ' AND state_code = 'IDLE' AND response_type = 'JSON'; Planner path (McpToolStep output) UPDATE ce_prompt_template SET user_prompt = 'Context JSON:\\n }\\n\\nRead context.mcp.observations and context.mcp.finalAnswer. Produce a concise diagnostic summary.' WHERE intent_code = 'ORDER_DIAGNOSTICS' AND state_code = 'COMPLETED' AND response_type = 'TEXT'; ORDER_DIAGNOSTICS is now included in demo seed with POST_AGENT_MCP completion and DERIVED final response from context.mcp.finalAnswer. ReactFlow View Optional planner driven test After deterministic tool_request tests pass, ask natural prompts without tool_request , for example: Order ORD 7017 was submitted by admin but async callback is null. Check status and trace. Planner should choose one or more mock. tools based on descriptions and context. Troubleshooting No HttpApiToolHandler... : ensure convengine demo depends on ConvEngine 2.0.7 ensure handler toolCode() matches DB ce_mcp_tool.tool_code API not called: confirm running on 31333 confirm convengine.demo.mockey.base url tool not found: re run seed.sql verify ce_mcp_tool.enabled=true Related pages",
    "rawContent": "{ id: \"u1\", data: { label: \"User Input\" } }, { id: \"i1\", data: { label: \"Intent + State Resolution\" } }, { id: \"m1\", data: { label: \"McpToolStep: plan #1\" } }, { id: \"t1\", data: { label: \"Tool call: mock.order.status\" } }, { id: \"m2\", data: { label: \"McpToolStep: plan #2\" } }, { id: \"t2\", data: { label: \"Tool call: mock.order.async.trace\" } }, { id: \"m3\", data: { label: \"McpToolStep: ANSWER\" } }, { id: \"r2\", data: { label: \"Rule: ANALYZE -> COMPLETED (POST_AGENT_MCP)\" } }, { id: \"r1\", data: { label: \"ResponseResolutionStep\" } }, { id: \"out\", data: { label: \"Assistant Output\" } }, ]; { id: \"e1\", source: \"u1\", target: \"i1\" }, { id: \"e2\", source: \"i1\", target: \"m1\" }, { id: \"e3\", source: \"m1\", target: \"t1\" }, { id: \"e4\", source: \"t1\", target: \"m2\" }, { id: \"e5\", source: \"m2\", target: \"t2\" }, { id: \"e6\", source: \"t2\", target: \"m3\" }, { id: \"e7\", source: \"m3\", target: \"r2\" }, { id: \"e8\", source: \"r2\", target: \"r1\" }, { id: \"e9\", source: \"r1\", target: \"out\" }, ]; u1: { title: \"User Input\", stage: \"REQUEST\", summary: \"User asks order status/callback question.\", session: [\"userText captured\"], tables: [\"ce_audit (W)\"] }, i1: { title: \"Intent + State Resolution\", stage: \"INTENT\", summary: \"Classifier and rules set runtime intent/state for tool eligibility.\", session: [\"intent/state resolved\"], tables: [\"ce_intent (R)\", \"ce_intent_classifier (R)\", \"ce_rule (R)\", \"ce_audit (W)\"] }, m1: { title: \"McpToolStep plan #1\", stage: \"MCP_PLAN_LLM_OUTPUT\", summary: \"Planner selects first tool based on prompt and available tools.\", session: [\"mcp_action=CALL_TOOL\", \"mcp_tool_code=mock.order.status\"], tables: [\"ce_mcp_tool (R)\", \"ce_mcp_planner (R)\", \"ce_audit (W)\"] }, t1: { title: \"Tool call: mock.order.status\", stage: \"MCP_TOOL_RESULT\", summary: \"HTTP tool executes via HttpApiToolInvoker and returns mapped payload.\", session: [\"mcp.observations[0] written\"], tables: [\"ce_audit (W)\"] }, m2: { title: \"McpToolStep plan #2\", stage: \"MCP_PLAN_LLM_OUTPUT\", summary: \"Planner sees first observation and requests async trace tool.\", session: [\"mcp_tool_code=mock.order.async.trace\"], tables: [\"ce_mcp_tool (R)\", \"ce_mcp_planner (R)\", \"ce_audit (W)\"] }, t2: { title: \"Tool call: mock.order.async.trace\", stage: \"MCP_TOOL_RESULT\", summary: \"Second observation appended to context.mcp.observations.\", session: [\"mcp.observations[1] written\"], tables: [\"ce_audit (W)\"] }, m3: { title: \"McpToolStep ANSWER\", stage: \"MCP_FINAL_ANSWER\", summary: \"Planner returns final answer and it is stored in context.mcp.finalAnswer.\", session: [\"mcp_final_answer set\", \"mcp_status=ANSWER\"], tables: [\"ce_audit (W)\"] }, r2: { title: \"Post-MCP transition\", stage: \"POST_AGENT_MCP\", summary: \"If context.mcp.finalAnswer exists, rule moves ORDER_DIAGNOSTICS from ANALYZE to COMPLETED.\", session: [\"state=COMPLETED\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"] }, r1: { title: \"ResponseResolutionStep\", stage: \"RESOLVE_RESPONSE\", summary: \"Resolves ce_response + ce_prompt_template for ORDER_DIAGNOSTICS+COMPLETED using MCP-enriched context.\", session: [\"payload generated\"], tables: [\"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"] }, out: { title: \"Assistant Output\", stage: \"ASSISTANT_OUTPUT\", summary: \"Resolved output is returned and persisted.\", session: [\"finalResult returned\"], tables: [\"ce_conversation (W)\", \"ce_conversation_history (W async)\", \"ce_audit (W)\"] } }; # MCP Example 1 (ConvEngine Demo + Mockey) This guide shows a complete local test of ConvEngine 2.0.7 advanced MCP HTTP tools using convengine-demo and [mockey](https://github.com/salilvnair/mockey). It covers: 1. starting mock APIs in [mockey](https://github.com/salilvnair/mockey) 2. wiring demo MCP tools to [mockey](https://github.com/salilvnair/mockey) endpoints 3. seeding ce_mcp_tool and planner prompts 4. testing via SQL panel + chat requests ## Prerequisites - [mockey](https://github.com/salilvnair/mockey) repo available locally - convengine-demo repo available locally - Postgres running for convengine-demo - ConvEngine dependency 2.0.7 ## What is already wired in demo convengine-demo now includes four HttpApiRequestingToolHandler mappings: - mock.order.submit -> POST /api/mock/order/submit - mock.order.status -> GET /api/mock/order/status - mock.order.async.trace -> GET /api/mock/order/async/trace - mock.customer.profile -> GET /api/mock/customer/profile Base URL is configured by: yaml convengine: demo: mockey: base-url: http://localhost:31333 api-key: demo-live-key ## Step 1: Start [mockey](https://github.com/salilvnair/mockey) From [mockey](https://github.com/salilvnair/mockey) root: bash npm install npm start Expected log: text listening to 31333 ## Step 2: Quick endpoint smoke tests bash curl -s \"http://localhost:31333/api/mock/order/status?orderId=ORD-7017\" curl -s \"http://localhost:31333/api/mock/order/async/trace?orderId=ORD-7017\" curl -s \"http://localhost:31333/api/mock/customer/profile?customerId=CUST-1001\" curl -s -X POST \"http://localhost:31333/api/mock/order/submit\" -H \"Content-Type: application/json\" -d '{\"orderId\":\"ORD-7017\",\"customerId\":\"CUST-1001\",\"submittedByRole\":\"ADMIN\"}' ## Step 3: Start convengine-demo From convengine-demo root: bash ./mvnw spring-boot:run ## Step 4: Seed MCP tools and planner prompts (SQL panel) Run convengine-demo/src/main/resources/sql/seed.sql . That seed includes the live MCP tools and ORDER_DIAGNOSTICS response/rule wiring (ANALYZE -> COMPLETED via POST_AGENT_MCP when context.mcp.finalAnswer exists): sql INSERT INTO ce_mcp_tool (tool_id, tool_code, tool_group, intent_code, state_code, enabled, description) VALUES (3, 'mock.order.submit', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Submit order through mockey live API'), (4, 'mock.order.status', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Fetch order status from mockey live API'), (5, 'mock.order.async.trace', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Fetch async callback trace from mockey live API'), (6, 'mock.customer.profile', 'HTTP_API', 'ORDER_DIAGNOSTICS', 'ANALYZE', true, 'Fetch customer profile from mockey live API'); Then seed planner prompts (framework seed) if your environment uses scoped MCP planner rows: - Postgres: convengine/src/main/resources/sql/mcp_planner_seed.sql (or mcp_planner_seed_postgres.sql ) - SQLite: convengine/src/main/resources/sql/mcp_planner_seed_sqlite.sql ## Step 5: Run as chat-style walkthrough <Tabs groupId=\"example1-chat-flow\"> <TabItem value=\"chat\" label=\"Conversation\" default> <ChatContainer> <TraceChatBubble role=\"user\" name=\"Turn 1 - User\" message=\"Order ORD-7017 was submitted by admin, callback is still null. Can you check status and trace?\" info={[\"Intent resolves to diagnostics scope.\", \"Planner mode starts.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 1 - Assistant (internal MCP)\" intent=\"ORDER_DIAGNOSTICS\" state=\"ANALYZE\" message=\"Calling tools: mock.order.status -> mock.order.async.trace\" json={{ mcp: { observations: [ { toolCode: \"mock.order.status\", json: \"{\\\"mapped\\\":{\\\"orderId\\\":\\\"ORD-7017\\\",\\\"status\\\":\\\"SUBMITTED\\\"}}\" }, { toolCode: \"mock.order.async.trace\", json: \"{\\\"mapped\\\":{\\\"orderId\\\":\\\"ORD-7017\\\",\\\"callbackAt\\\":null}}\" } ] } }} tables={[\"ce_mcp_tool (R)\", \"ce_mcp_planner (R)\", \"ce_audit (W)\"]} info={[\"MCP loop runs until planner returns ANSWER.\", \"Observations are written in context.mcp.observations.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 1 - Final Assistant Output\" intent=\"ORDER_DIAGNOSTICS\" state=\"COMPLETED\" message=\"Order ORD-7017 is submitted. Async callback is pending/missing, so no callback timestamp is available yet.\" json={{ mcp: { finalAnswer: \"Order submitted, callback pending.\" } }} tables={[\"ce_rule (R)\", \"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_conversation (W)\"]} info={[\"POST_AGENT_MCP moves ANALYZE -> COMPLETED when context.mcp.finalAnswer exists.\", \"ResponseResolutionStep uses context + derivation_hint.\"]} /> </ChatContainer> </TabItem> <TabItem value=\"turn-table\" label=\"Turn Table\"> <DbTable title=\"Turn-by-turn summary\" columns={[\"Turn/Phase\", \"What happens\", \"Tables touched\", \"Output\"]} rows={[ [\"Turn 1 / Planner loop\", \"Planner selects status then async-trace tool.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"context.mcp.observations[]\"], [\"Turn 1 / Planner answer\", \"Planner writes final MCP answer.\", \"ce_audit(W)\", \"context.mcp.finalAnswer\"], [\"Turn 1 / Post-MCP rule\", \"POST_AGENT_MCP checks context.mcp.finalAnswer and moves state to COMPLETED.\", \"ce_rule(R), ce_audit(W)\", \"state=COMPLETED\"], [\"Turn 1 / Response resolution\", \"DERIVED response rendered from context for COMPLETED state.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"assistant text\"], ]} /> </TabItem> <TabItem value=\"api\" label=\"Request Payloads\"> json { \"userInput\": \"Order ORD-7017 was submitted by admin, callback is still null. Can you check status and trace?\", \"contextJson\": \"{}\", \"inputParams\": {} } Direct deterministic tool payload (optional): json { \"userInput\": \"Check order status\", \"contextJson\": \"{}\", \"inputParams\": { \"tool_request\": { \"tool_code\": \"mock.order.status\", \"tool_group\": \"HTTP_API\", \"args\": { \"orderId\": \"ORD-7017\" } } } } </TabItem> </Tabs> ## Step 6: Validate advanced HTTP behavior HttpApiRequestingToolHandler calls are executed by framework HttpApiToolInvoker . Observation payload will include: - status - attempt - latencyMs - mapped Expected shape: json { \"status\": 200, \"attempt\": 1, \"latencyMs\": 40, \"mapped\": { \"orderId\": \"ORD-7017\", \"status\": \"SUBMITTED\", \"api4AsyncStatus\": null } } ## Step 7: Verify MCP audit stages Check audit timeline in audit APIs for: - TOOL_ORCHESTRATION_REQUEST - TOOL_ORCHESTRATION_RESULT - MCP_TOOL_CALL - MCP_TOOL_RESULT ## MCP Output to Final Response (Deep Dive) This is the exact handoff path from MCP tools to response text/json in the same request turn: 1. McpToolStep clears stale context.mcp.* at start of turn. 2. Planner ( McpPlanner ) receives user_input , context , mcp_tools , and current mcp_observations . 3. Each CALL_TOOL result is appended into context.mcp.observations[] as {toolCode, json} . 4. When planner returns ANSWER , step writes: - context.mcp.finalAnswer - input param mcp_final_answer 5. RulesStep runs POST_AGENT_MCP phase; when context.mcp.finalAnswer exists, rule transitions ANALYZE -> COMPLETED. 6. ResponseResolutionStep selects ce_response for current intent/state. 7. If selected response is DERIVED , resolver selects matching ce_prompt_template and invokes LLM with: - rendered prompt - derivation_hint from ce_response - session.contextDict() as context (includes the MCP block) 8. Final assistant output is audited ( ASSISTANT_OUTPUT ) and persisted. <Highlight type=\"tip\" title=\"Why this works\"> Even if your template does not explicitly reference mcp_final_answer , it still receives full context JSON. If context.mcp.observations and context.mcp.finalAnswer exist, response derivation can use them. </Highlight> ## Turn-by-Turn E2E (Tab View) <Tabs groupId=\"mcp-live-e2e\"> <TabItem value=\"planner-path\" label=\"Planner Path\" default> <DbTable title=\"Natural language planner path (single request turn)\" columns={[\"Loop/Step\", \"What LLM deduces\", \"Tables touched\", \"Artifact produced\"]} rows={[ [\"Intent+state phase\", \"Question is an order diagnostics request in tool-eligible scope.\", \"ce_intent(R), ce_intent_classifier(R), ce_rule(R), ce_audit(W)\", \"resolved intent/state\"], [\"MCP loop #1\", \"Need order status first.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL mock.order.status\"], [\"Tool exec #1\", \"HTTP mapped status payload available.\", \"ce_audit(W)\", \"context.mcp.observations[0]\"], [\"MCP loop #2\", \"Need callback trace to confirm async issue.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL mock.order.async.trace\"], [\"Tool exec #2\", \"Trace confirms callback missing/pending.\", \"ce_audit(W)\", \"context.mcp.observations[1]\"], [\"MCP loop #3\", \"Enough evidence; produce conclusion.\", \"ce_mcp_planner(R), ce_audit(W)\", \"context.mcp.finalAnswer + mcp_final_answer\"], [\"Post-MCP rule\", \"When context.mcp.finalAnswer exists, move ANALYZE to COMPLETED.\", \"ce_rule(R), ce_audit(W)\", \"state=COMPLETED\"], [\"Response resolution\", \"Render user-facing answer with MCP evidence.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"final payload\"] ]} /> </TabItem> <TabItem value=\"direct-tool\" label=\"Direct tool_request\"> <DbTable title=\"Deterministic direct tool path\" columns={[\"Step\", \"What happens\", \"Tables touched\", \"Output source\"]} rows={[ [\"ToolOrchestrationStep\", \"Executes exactly the requested tool without planner loop.\", \"ce_mcp_tool(R), ce_audit(W)\", \"inputParams.tool_request\"], [\"HTTP execution\", \"Handler + HttpApiToolInvoker returns mapped response.\", \"ce_audit(W)\", \"tool_result\"], [\"Response resolution\", \"Depending on response mapping, output may be EXACT or DERIVED.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"tool_result + context\"], ]} /> </TabItem> <TabItem value=\"response-internals\" label=\"Response Internals\"> <DbTable title=\"How response derivation consumes MCP data\" columns={[\"Resolver input\", \"Source\", \"Example\"]} rows={[ [\"context\", \"session.contextJson (includes mcp.observations and mcp.finalAnswer)\", \"{\\\"mcp\\\":{\\\"observations\\\":[...],\\\"finalAnswer\\\":\\\"...\\\"}}\"], [\"user_input\", \"current request text\", \"Order ORD-7017 was submitted by admin...\"], [\"derivation_hint\", \"ce_response.derivation_hint\", \"Use MCP observations to explain status and callback condition.\"], [\"prompt template\", \"ce_prompt_template by intent/state/output format\", \"TEXT template for ORDER_DIAGNOSTICS + COMPLETED\"], [\"LLM output\", \"TextOutputFormatResolver / JsonOutputFormatResolver\", \"final assistant payload\"], ]} /> </TabItem> </Tabs> ## Example 1: Explicit prompt wiring (recommended) Keep it simple: - direct tool_request path uses inputParams.tool_result - planner path uses context.mcp.observations and context.mcp.finalAnswer Use these SQL updates so prompt behavior is explicit: sql -- Direct tool_request path (ToolOrchestrationStep output) UPDATE ce_prompt_template SET user_prompt = 'User input: {{user_input}}\\nTool result: {{tool_result}}\\nContext: {{context}}\\nSummarize status and next action.' WHERE intent_code = 'FAQ' AND state_code = 'IDLE' AND response_type = 'JSON'; -- Planner path (McpToolStep output) UPDATE ce_prompt_template SET user_prompt = 'Context JSON:\\n{{context}}\\n\\nRead context.mcp.observations and context.mcp.finalAnswer. Produce a concise diagnostic summary.' WHERE intent_code = 'ORDER_DIAGNOSTICS' AND state_code = 'COMPLETED' AND response_type = 'TEXT'; ORDER_DIAGNOSTICS is now included in demo seed with POST_AGENT_MCP completion and DERIVED final response from context.mcp.finalAnswer. ## ReactFlow View <EngineDebugFlow title=\"MCP Live Request Execution\" subtitle=\"Planner loop, tool observations, and response resolution handoff.\" nodes={liveExampleNodes} edges={liveExampleEdges} detailsById={liveExampleDetails} defaultSelectedId=\"m1\" /> ## Optional planner-driven test After deterministic tool_request tests pass, ask natural prompts without tool_request , for example: - Order ORD-7017 was submitted by admin but async callback is null. Check status and trace. Planner should choose one or more mock.* tools based on descriptions and context. ## Troubleshooting - No HttpApiToolHandler... : - ensure convengine-demo depends on ConvEngine 2.0.7 - ensure handler toolCode() matches DB ce_mcp_tool.tool_code - API not called: - confirm [mockey](https://github.com/salilvnair/mockey) running on 31333 - confirm convengine.demo.mockey.base-url - tool not found: - re-run seed.sql - verify ce_mcp_tool.enabled=true ## Related pages - [MCP Basics](/docs/v2/consumer/mcp/basics) - [MCP Advanced Guide](/docs/v2/consumer/mcp/advanced) - [MCP Example 2 - Loan Application](/docs/v2/consumer/mcp/example2) - [Caching & Persistence](/docs/v2/consumer/caching-and-persistence)",
    "excerpt": "}, }, }, }, }, }, }, }, }, }, ]; , , , , , , , , , ]; u1: , i1: , m1: , t1: , m2: , t2: , m3: , r2: , r1: , out: }; MCP Example 1 (ConvEngine Demo + Mockey) This guide shows a complete local test of ConvEngine 2.0.7 adva…"
  },
  {
    "id": "consumer/mcp/example2.mdx",
    "version": "v2",
    "title": "example2",
    "permalink": "/docs/v2/consumer/mcp/example2",
    "content": "}, }, }, }, }, }, }, }, }, }, }, }, }, }, }, ]; , , , , , , , , , , , , , , ]; u1: , s1: , r1: , r2: , m1: , t1: , m2: , t2: , m3: , t3: , m4: , t4: , m5: , resp: , out: }; MCP Example 2 Loan Application (Conditional API Chain) This example demonstrates a real world conditional MCP chain: 1. call Credit Union Rating API 2. if creditRating 750 , call Credit Card Fraud API 3. if not flagged, call Debt/Credit Summary API 4. if debt profile is acceptable, call Loan Submit API All APIs are mocked through with response delays to simulate real external systems. Repos and files used Mock APIs ( ) GET /api/mock/loan/credit union/rating GET /api/mock/loan/credit card/fraud check GET /api/mock/loan/debt credit/summary POST /api/mock/loan/application/submit Key files: mockey/src/resolver/provider/live api.resolver.js mockey/src/resolver/core/resolver.registry.js mockey/src/route/mockey route.json mockey/src/response/loan/ .json (includes delay via responseDelayInMillis ) Demo MCP handlers ( convengine demo ) loan.credit.rating.check loan.credit.fraud.check loan.debt.credit.summary loan.application.submit Handler files: convengine demo/.../LoanCreditRatingToolHandler.java convengine demo/.../LoanFraudCheckToolHandler.java convengine demo/.../LoanDebtSummaryToolHandler.java convengine demo/.../LoanApplicationSubmitToolHandler.java Seed packs Postgres: convengine demo/src/main/resources/sql/example2_seed.sql SQLite: convengine demo/src/main/resources/sql/example2_sqlite_seed.sql These seed files include all required DML: ce_intent ce_intent_classifier ce_output_schema ce_prompt_template ce_response ce_rule ce_mcp_tool (with intent_code + state_code ) ce_mcp_planner scoped prompt rows (default + LOAN_APPLICATION/ELIGIBILITY_GATE) Required rule/response rows for this flow Use these key rows so classifier + MCP + response resolution line up correctly: sql 1) Bootstrap state after classifier picks LOAN_APPLICATION INSERT INTO ce_rule (intent_code, state_code, rule_type, match_pattern, action, action_value, phase, priority, enabled, description) VALUES ('LOAN_APPLICATION', 'UNKNOWN', 'REGEX', '. ', 'SET_STATE', 'ELIGIBILITY_GATE', 'POST_AGENT_INTENT', 20, true, 'Move LOAN_APPLICATION from UNKNOWN into ELIGIBILITY_GATE.'); 2) After MCP planner returns ANSWER, close state for final response mapping INSERT INTO ce_rule (intent_code, state_code, rule_type, match_pattern, action, action_value, phase, priority, enabled, description) VALUES ('LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'JSON_PATH', '$[?(@.context.mcp.finalAnswer != null && @.context.mcp.finalAnswer != '''')]', 'SET_STATE', 'COMPLETED', 'POST_AGENT_MCP', 30, true, 'Move loan flow to COMPLETED only when context.mcp.finalAnswer exists.'); 3) Final response row should target COMPLETED and derive from MCP context INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled, description) VALUES ('LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'DERIVED', 'Use context.mcp.finalAnswer as primary summary. Validate with context.mcp.observations (rating/fraud/debt/submit). Do not invent values.', 20, true, 'Loan decision derived from MCP outputs.'); 4) Prompt template should explicitly read context.mcp. INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, interaction_mode, interaction_contract, enabled) VALUES ('LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'You are a precise loan workflow summarizer. Use only MCP evidence from context JSON.', 'Context JSON:\\n }\\n\\nRead context.mcp.observations and context.mcp.finalAnswer. Return a concise final loan decision.', 'FINAL', ' ', true); Step by step test 1) Start bash cd /Users/salilvnair/workspace/git/salilvnair/mockey npm install npm start Expected: text listening to 31333 2) Optional quick mock checks bash curl s \"http://localhost:31333/api/mock/loan/credit union/rating?customerId=CUST 1001\" curl s \"http://localhost:31333/api/mock/loan/credit card/fraud check?customerId=CUST 1001\" curl s \"http://localhost:31333/api/mock/loan/debt credit/summary?customerId=CUST 1001\" curl s X POST \"http://localhost:31333/api/mock/loan/application/submit\" H \"Content Type: application/json\" d ' ' 3) Start convengine demo bash cd /Users/salilvnair/workspace/git/salilvnair/convengine demo ./mvnw spring boot:run 4) Seed Example 2 DML For Postgres run: convengine demo/src/main/resources/sql/example2_seed.sql For SQLite run: convengine demo/src/main/resources/sql/example2_sqlite_seed.sql 5) Run as chat style walkthrough fraud debt summary submit.\" json= }\" }, }\" }, }\" }, }\" } ] } }} tables= info= / Planner mode payload: json \", \"inputParams\": } Direct branch payload (low rating): json \", \"inputParams\": } } } Direct branch payload (fraud): json \", \"inputParams\": } } } 6) Verify audit stages Look for: MCP_PLAN_LLM_INPUT MCP_PLAN_LLM_OUTPUT MCP_TOOL_CALL MCP_TOOL_RESULT MCP_FINAL_ANSWER Also for direct tool requests: TOOL_ORCHESTRATION_REQUEST TOOL_ORCHESTRATION_RESULT 7) Verify advanced HTTP execution metadata Mapped output includes framework execution details: json } The latency reflects mock delays ( responseDelayInMillis ) configured in responses. How MCP Tool Output Is Used in Response Resolution (Step by Step) For this example, the final assistant text is not hardcoded. It is derived from MCP evidence in runtime context: 1. McpToolStep starts and clears stale context.mcp.finalAnswer and context.mcp.observations . 2. Every successful tool call appends one entry into context.mcp.observations : toolCode json (stringified mapped payload) 3. When planner returns ANSWER , McpToolStep writes: context.mcp.finalAnswer input param mcp_final_answer 4. In the confirmation first pattern, POST_SCHEMA_EXTRACTION can move the flow to CONFIRMATION , PRE_AGENT_MCP can move CONFIRMATION PROCESS_APPLICATION , and POST_AGENT_MCP can set COMPLETED when context.mcp.finalAnswer is present. 5. ResponseResolutionStep selects ce_response for: intent_code=LOAN_APPLICATION state_code=COMPLETED response type DERIVED , output format TEXT 6. It then selects matching ce_prompt_template ( TEXT ) for the same intent/state. 7. TextOutputFormatResolver invokes LLM with: rendered system/user prompt ce_response.derivation_hint context payload ( session.contextDict() ), which includes MCP observations/finalAnswer 8. LLM produces final summary text. Engine audits RESOLVE_RESPONSE_LLM_OUTPUT and ASSISTANT_OUTPUT , then persists conversation. In this setup, the response LLM is grounded by two things together: derivation_hint policy from ce_response and MCP evidence from context.mcp. . That is why the final answer reflects rating/fraud/debt/applicationId consistently. The provided Example 2 seed now makes this explicit in SQL as well: ce_prompt_template.user_prompt explicitly instructs reading context.mcp.observations and context.mcp.finalAnswer ce_response.derivation_hint explicitly references context.mcp. E2E Turn by Turn (Tab View) CONFIRMATION after schema extraction, then PRE_AGENT_MCP moves CONFIRMATION PROCESS_APPLICATION before MCP.\", \"ce_rule(R), ce_audit(W)\", \"state confirmation gate before MCP\"], [\"MCP 1\", \"Need credit rating first.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL rating\"], [\"Tool 1\", \"Rating available and 750.\", \"ce_audit(W)\", \"obs[0]=creditRating\"], [\"MCP 2\", \"Proceed to fraud check.\", \"ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL fraud\"], [\"Tool 2\", \"Fraud clear.\", \"ce_audit(W)\", \"obs[1]=flagged:false\"], [\"MCP 3\", \"Need affordability metrics.\", \"ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL debt summary\"], [\"Tool 3\", \"DTI acceptable and credit sufficient.\", \"ce_audit(W)\", \"obs[2]=dti/availableCredit\"], [\"MCP 4\", \"Submit application now.\", \"ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL submit\"], [\"Tool 4\", \"Submission succeeded.\", \"ce_audit(W)\", \"obs[3]=applicationId/status\"], [\"MCP ANSWER\", \"Enough evidence for final decision.\", \"ce_audit(W)\", \"context.mcp.finalAnswer\"], [\"ResponseResolutionStep\", \"Generate final user facing summary.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"assistant text payload\"] ]} / ReactFlow Execution Map Response Field Provenance Notes on state and scope ce_mcp_tool rows in example2 are scoped as: intent_code = LOAN_APPLICATION state_code = ELIGIBILITY_GATE This ensures tools are visible only in the loan decision state. Troubleshooting Tool not resolved: verify tool_code in DB matches handler toolCode() exactly No tool call in planner path: check McpPlanner prompt rows in ce_mcp_planner confirm active intent is LOAN_APPLICATION Timeouts/retries unexpected: inspect handler specific HttpApiExecutionPolicy inspect mock delay values in mockey/src/response/loan/ .json Related docs",
    "rawContent": "{ id: \"u1\", data: { label: \"User Input: apply loan\" } }, { id: \"s1\", data: { label: \"SchemaExtractionStep\" } }, { id: \"r1\", data: { label: \"Rule: UNKNOWN/IDLE -> ELIGIBILITY_GATE\" } }, { id: \"m1\", data: { label: \"MCP plan #1\" } }, { id: \"t1\", data: { label: \"loan.credit.rating.check\" } }, { id: \"m2\", data: { label: \"MCP plan #2\" } }, { id: \"t2\", data: { label: \"loan.credit.fraud.check\" } }, { id: \"m3\", data: { label: \"MCP plan #3\" } }, { id: \"t3\", data: { label: \"loan.debt.credit.summary\" } }, { id: \"m4\", data: { label: \"MCP plan #4\" } }, { id: \"t4\", data: { label: \"loan.application.submit\" } }, { id: \"m5\", data: { label: \"MCP ANSWER\" } }, { id: \"r2\", data: { label: \"Rule: ELIGIBILITY_GATE -> COMPLETED (POST_AGENT_MCP)\" } }, { id: \"resp\", data: { label: \"ResponseResolutionStep (DERIVED TEXT)\" } }, { id: \"out\", data: { label: \"Assistant Output\" } }, ]; { id: \"e1\", source: \"u1\", target: \"s1\" }, { id: \"e2\", source: \"s1\", target: \"r1\" }, { id: \"e3\", source: \"r1\", target: \"m1\" }, { id: \"e4\", source: \"m1\", target: \"t1\" }, { id: \"e5\", source: \"t1\", target: \"m2\" }, { id: \"e6\", source: \"m2\", target: \"t2\" }, { id: \"e7\", source: \"t2\", target: \"m3\" }, { id: \"e8\", source: \"m3\", target: \"t3\" }, { id: \"e9\", source: \"t3\", target: \"m4\" }, { id: \"e10\", source: \"m4\", target: \"t4\" }, { id: \"e11\", source: \"t4\", target: \"m5\" }, { id: \"e12\", source: \"m5\", target: \"r2\" }, { id: \"e13\", source: \"r2\", target: \"resp\" }, { id: \"e14\", source: \"resp\", target: \"out\" }, ]; u1: { title: \"User Input\", stage: \"REQUEST\", summary: \"User asks to apply for loan with customer and amount details.\", session: [\"userText set\", \"inputParams initialized\"], tables: [\"ce_audit (W)\"] }, s1: { title: \"SchemaExtractionStep\", stage: \"SCHEMA\", summary: \"Extracts customerId, requestedAmount, tenureMonths from user text.\", session: [\"context updated with extracted schema fields\"], tables: [\"ce_output_schema (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"] }, r1: { title: \"Rule transition\", stage: \"POST_AGENT_INTENT\", summary: \"Rule moves LOAN_APPLICATION from UNKNOWN or IDLE into ELIGIBILITY_GATE.\", session: [\"state=ELIGIBILITY_GATE -> COMPLETED\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"] }, r2: { title: \"Post-MCP transition\", stage: \"POST_AGENT_MCP\", summary: \"After planner ANSWER, POST_AGENT_MCP rule checks context.mcp.finalAnswer and moves state from ELIGIBILITY_GATE to COMPLETED.\", session: [\"state=COMPLETED\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"] }, m1: { title: \"MCP plan #1\", stage: \"MCP_PLAN_LLM_OUTPUT\", summary: \"Planner decides first check must be credit rating.\", session: [\"CALL_TOOL loan.credit.rating.check\"], tables: [\"ce_mcp_tool (R)\", \"ce_mcp_planner (R)\", \"ce_audit (W)\"] }, t1: { title: \"loan.credit.rating.check\", stage: \"MCP_TOOL_RESULT\", summary: \"Mapped rating response appended to context.mcp.observations.\", session: [\"observation[0]=rating\"], tables: [\"ce_audit (W)\"] }, m2: { title: \"MCP plan #2\", stage: \"MCP_PLAN_LLM_OUTPUT\", summary: \"If rating > 750 planner proceeds to fraud check.\", session: [\"CALL_TOOL loan.credit.fraud.check\"], tables: [\"ce_mcp_planner (R)\", \"ce_audit (W)\"] }, t2: { title: \"loan.credit.fraud.check\", stage: \"MCP_TOOL_RESULT\", summary: \"Fraud result stored as second observation.\", session: [\"observation[1]=fraud\"], tables: [\"ce_audit (W)\"] }, m3: { title: \"MCP plan #3\", stage: \"MCP_PLAN_LLM_OUTPUT\", summary: \"If fraud false planner asks debt/credit summary.\", session: [\"CALL_TOOL loan.debt.credit.summary\"], tables: [\"ce_mcp_planner (R)\", \"ce_audit (W)\"] }, t3: { title: \"loan.debt.credit.summary\", stage: \"MCP_TOOL_RESULT\", summary: \"Debt metrics (dti, availableCredit) added to observations.\", session: [\"observation[2]=debt\"], tables: [\"ce_audit (W)\"] }, m4: { title: \"MCP plan #4\", stage: \"MCP_PLAN_LLM_OUTPUT\", summary: \"If affordability passes, planner triggers submit API.\", session: [\"CALL_TOOL loan.application.submit\"], tables: [\"ce_mcp_planner (R)\", \"ce_audit (W)\"] }, t4: { title: \"loan.application.submit\", stage: \"MCP_TOOL_RESULT\", summary: \"Submission response includes applicationId and status.\", session: [\"observation[3]=submit result\"], tables: [\"ce_audit (W)\"] }, m5: { title: \"MCP ANSWER\", stage: \"MCP_FINAL_ANSWER\", summary: \"Planner synthesizes final decision and stores context.mcp.finalAnswer.\", session: [\"mcp_final_answer set\", \"mcp_status=ANSWER\"], tables: [\"ce_audit (W)\"] }, resp: { title: \"ResponseResolutionStep\", stage: \"RESOLVE_RESPONSE\", summary: \"Selects LOAN_APPLICATION+COMPLETED DERIVED response and renders final text from MCP-enriched context.\", session: [\"payload generated via TextOutputFormatResolver\"], tables: [\"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"] }, out: { title: \"Assistant Output\", stage: \"ASSISTANT_OUTPUT\", summary: \"Final decision text returned and persisted.\", session: [\"final payload returned\"], tables: [\"ce_conversation (W)\", \"ce_conversation_history (W async)\", \"ce_audit (W)\"] } }; # MCP Example 2 - Loan Application (Conditional API Chain) This example demonstrates a real-world conditional MCP chain: 1. call Credit Union Rating API 2. if creditRating > 750 , call Credit Card Fraud API 3. if not flagged, call Debt/Credit Summary API 4. if debt profile is acceptable, call Loan Submit API All APIs are mocked through [mockey](https://github.com/salilvnair/mockey) with response delays to simulate real external systems. ## Repos and files used ## Mock APIs ([mockey](https://github.com/salilvnair/mockey)) - GET /api/mock/loan/credit-union/rating - GET /api/mock/loan/credit-card/fraud-check - GET /api/mock/loan/debt-credit/summary - POST /api/mock/loan/application/submit Key files: - mockey/src/resolver/provider/live-api.resolver.js - mockey/src/resolver/core/resolver.registry.js - mockey/src/route/mockey-route.json - mockey/src/response/loan/*.json (includes delay via responseDelayInMillis ) ## Demo MCP handlers ( convengine-demo ) - loan.credit.rating.check - loan.credit.fraud.check - loan.debt.credit.summary - loan.application.submit Handler files: - convengine-demo/.../LoanCreditRatingToolHandler.java - convengine-demo/.../LoanFraudCheckToolHandler.java - convengine-demo/.../LoanDebtSummaryToolHandler.java - convengine-demo/.../LoanApplicationSubmitToolHandler.java ## Seed packs - Postgres: convengine-demo/src/main/resources/sql/example2_seed.sql - SQLite: convengine-demo/src/main/resources/sql/example2_sqlite_seed.sql These seed files include all required DML: - ce_intent - ce_intent_classifier - ce_output_schema - ce_prompt_template - ce_response - ce_rule - ce_mcp_tool (with intent_code + state_code ) - ce_mcp_planner scoped prompt rows (default + LOAN_APPLICATION/ELIGIBILITY_GATE) ## Required rule/response rows for this flow Use these key rows so classifier + MCP + response resolution line up correctly: sql -- 1) Bootstrap state after classifier picks LOAN_APPLICATION INSERT INTO ce_rule (intent_code, state_code, rule_type, match_pattern, action, action_value, phase, priority, enabled, description) VALUES ('LOAN_APPLICATION', 'UNKNOWN', 'REGEX', '.*', 'SET_STATE', 'ELIGIBILITY_GATE', 'POST_AGENT_INTENT', 20, true, 'Move LOAN_APPLICATION from UNKNOWN into ELIGIBILITY_GATE.'); -- 2) After MCP planner returns ANSWER, close state for final response mapping INSERT INTO ce_rule (intent_code, state_code, rule_type, match_pattern, action, action_value, phase, priority, enabled, description) VALUES ('LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'JSON_PATH', '$[?(@.context.mcp.finalAnswer != null && @.context.mcp.finalAnswer != '''')]', 'SET_STATE', 'COMPLETED', 'POST_AGENT_MCP', 30, true, 'Move loan flow to COMPLETED only when context.mcp.finalAnswer exists.'); -- 3) Final response row should target COMPLETED and derive from MCP context INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled, description) VALUES ('LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'DERIVED', 'Use context.mcp.finalAnswer as primary summary. Validate with context.mcp.observations (rating/fraud/debt/submit). Do not invent values.', 20, true, 'Loan decision derived from MCP outputs.'); -- 4) Prompt template should explicitly read context.mcp.* INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, interaction_mode, interaction_contract, enabled) VALUES ('LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'You are a precise loan workflow summarizer. Use only MCP evidence from context JSON.', 'Context JSON:\\n{{context}}\\n\\nRead context.mcp.observations and context.mcp.finalAnswer. Return a concise final loan decision.', 'FINAL', '{\"allows\":[\"reset\"],\"expects\":[]}', true); ## Step-by-step test ## 1) Start [mockey](https://github.com/salilvnair/mockey) bash cd /Users/salilvnair/workspace/git/salilvnair/mockey npm install npm start Expected: text listening to 31333 ## 2) Optional quick mock checks bash curl -s \"http://localhost:31333/api/mock/loan/credit-union/rating?customerId=CUST-1001\" curl -s \"http://localhost:31333/api/mock/loan/credit-card/fraud-check?customerId=CUST-1001\" curl -s \"http://localhost:31333/api/mock/loan/debt-credit/summary?customerId=CUST-1001\" curl -s -X POST \"http://localhost:31333/api/mock/loan/application/submit\" -H \"Content-Type: application/json\" -d '{\"customerId\":\"CUST-1001\",\"requestedAmount\":350000,\"tenureMonths\":36}' ## 3) Start convengine-demo bash cd /Users/salilvnair/workspace/git/salilvnair/convengine-demo ./mvnw spring-boot:run ## 4) Seed Example 2 DML For Postgres run: - convengine-demo/src/main/resources/sql/example2_seed.sql For SQLite run: - convengine-demo/src/main/resources/sql/example2_sqlite_seed.sql ## 5) Run as chat-style walkthrough <Tabs groupId=\"example2-chat-flow\"> <TabItem value=\"chat\" label=\"Conversation\" default> <ChatContainer> <TraceChatBubble role=\"user\" name=\"Turn 1 - User\" message=\"Apply loan for customer CUST-1001, amount 350000 for 36 months.\" info={[\"SchemaExtractionStep pulls customerId, amount, tenure.\", \"Rule moves state to ELIGIBILITY_GATE.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 1 - Assistant (internal MCP)\" intent=\"LOAN_APPLICATION\" state=\"ELIGIBILITY_GATE\" message=\"Running eligibility chain: rating -> fraud -> debt summary -> submit.\" json={{ mcp: { observations: [ { toolCode: \"loan.credit.rating.check\", json: \"{\\\"mapped\\\":{\\\"customerId\\\":\\\"CUST-1001\\\",\\\"creditRating\\\":782}}\" }, { toolCode: \"loan.credit.fraud.check\", json: \"{\\\"mapped\\\":{\\\"customerId\\\":\\\"CUST-1001\\\",\\\"flagged\\\":false}}\" }, { toolCode: \"loan.debt.credit.summary\", json: \"{\\\"mapped\\\":{\\\"dti\\\":0.31,\\\"availableCredit\\\":220000}}\" }, { toolCode: \"loan.application.submit\", json: \"{\\\"mapped\\\":{\\\"applicationId\\\":\\\"LA-90311\\\",\\\"status\\\":\\\"SUBMITTED\\\"}}\" } ] } }} tables={[\"ce_mcp_tool (R)\", \"ce_mcp_planner (R)\", \"ce_audit (W)\"]} info={[\"Planner decides each next tool from previous observation.\", \"Observations are persisted in context.mcp.observations.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 1 - Final Assistant Output\" intent=\"LOAN_APPLICATION\" state=\"COMPLETED\" message=\"Loan application submitted successfully. Application ID: LA-90311. Credit and fraud checks passed; debt profile is within threshold.\" json={{ mcp: { finalAnswer: \"Approved and submitted with applicationId LA-90311.\" } }} tables={[\"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_conversation (W)\"]} info={[\"Response is DERIVED TEXT for LOAN_APPLICATION + COMPLETED.\", \"TextOutputFormatResolver uses context + derivation_hint.\"]} /> </ChatContainer> </TabItem> <TabItem value=\"turn-table\" label=\"Turn Table\"> <DbTable title=\"Loan flow summary\" columns={[\"Phase\", \"What happens\", \"Tables touched\", \"Output\"]} rows={[ [\"Schema + state\", \"Extract fields and switch to ELIGIBILITY_GATE.\", \"ce_output_schema(R), ce_rule(R), ce_audit(W)\", \"context fields + state\"], [\"Post-MCP transition\", \"POST_AGENT_MCP rule moves state to COMPLETED only when context.mcp.finalAnswer is present.\", \"ce_rule(R), ce_audit(W)\", \"state=COMPLETED\"], [\"MCP tool chain\", \"Rating, fraud, debt, submit executed conditionally.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"context.mcp.observations[]\"], [\"MCP final answer\", \"Planner writes final decision text.\", \"ce_audit(W)\", \"context.mcp.finalAnswer\"], [\"Response resolution\", \"DERIVED TEXT generated for user.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"assistant payload\"], ]} /> </TabItem> <TabItem value=\"api\" label=\"Request Payloads\"> Planner mode payload: json { \"userInput\": \"Apply loan for customer CUST-1001, amount 350000 for 36 months\", \"contextJson\": \"{}\", \"inputParams\": {} } Direct branch payload (low rating): json { \"userInput\": \"Apply loan\", \"contextJson\": \"{}\", \"inputParams\": { \"tool_request\": { \"tool_code\": \"loan.credit.rating.check\", \"tool_group\": \"HTTP_API\", \"args\": { \"customerId\": \"CUST-LOW\" } } } } Direct branch payload (fraud): json { \"userInput\": \"Apply loan\", \"contextJson\": \"{}\", \"inputParams\": { \"tool_request\": { \"tool_code\": \"loan.credit.fraud.check\", \"tool_group\": \"HTTP_API\", \"args\": { \"customerId\": \"CUST-FRAUD\" } } } } </TabItem> </Tabs> ## 6) Verify audit stages Look for: - MCP_PLAN_LLM_INPUT - MCP_PLAN_LLM_OUTPUT - MCP_TOOL_CALL - MCP_TOOL_RESULT - MCP_FINAL_ANSWER Also for direct tool requests: - TOOL_ORCHESTRATION_REQUEST - TOOL_ORCHESTRATION_RESULT ## 7) Verify advanced HTTP execution metadata Mapped output includes framework execution details: json { \"status\": 200, \"attempt\": 1, \"latencyMs\": 1205, \"mapped\": { \"customerId\": \"CUST-1001\", \"creditRating\": 782 } } The latency reflects mock delays ( responseDelayInMillis ) configured in [mockey](https://github.com/salilvnair/mockey) responses. ## How MCP Tool Output Is Used in Response Resolution (Step-by-Step) For this example, the final assistant text is not hardcoded. It is derived from MCP evidence in runtime context: 1. McpToolStep starts and clears stale context.mcp.finalAnswer and context.mcp.observations . 2. Every successful tool call appends one entry into context.mcp.observations : - toolCode - json (stringified mapped payload) 3. When planner returns ANSWER , McpToolStep writes: - context.mcp.finalAnswer - input param mcp_final_answer 4. In the confirmation-first pattern, POST_SCHEMA_EXTRACTION can move the flow to CONFIRMATION , PRE_AGENT_MCP can move CONFIRMATION -> PROCESS_APPLICATION , and POST_AGENT_MCP can set COMPLETED when context.mcp.finalAnswer is present. 5. ResponseResolutionStep selects ce_response for: - intent_code=LOAN_APPLICATION - state_code=COMPLETED - response type DERIVED , output format TEXT 6. It then selects matching ce_prompt_template ( TEXT ) for the same intent/state. 7. TextOutputFormatResolver invokes LLM with: - rendered system/user prompt - ce_response.derivation_hint - context payload ( session.contextDict() ), which includes MCP observations/finalAnswer 8. LLM produces final summary text. Engine audits RESOLVE_RESPONSE_LLM_OUTPUT and ASSISTANT_OUTPUT , then persists conversation. <Highlight type=\"info\" title=\"Practical implication\"> In this setup, the response LLM is grounded by two things together: derivation_hint policy from ce_response and MCP evidence from context.mcp.* . That is why the final answer reflects rating/fraud/debt/applicationId consistently. </Highlight> The provided Example 2 seed now makes this explicit in SQL as well: - ce_prompt_template.user_prompt explicitly instructs reading context.mcp.observations and context.mcp.finalAnswer - ce_response.derivation_hint explicitly references context.mcp.* ## E2E Turn-by-Turn (Tab View) <Tabs groupId=\"loan-example-e2e\"> <TabItem value=\"approved\" label=\"Approved Path\" default> <DbTable title=\"Single request turn (approved branch)\" columns={[\"Loop/Step\", \"LLM deduction\", \"Tables touched\", \"Produced state/data\"]} rows={[ [\"Schema extraction\", \"customerId/requestedAmount/tenure extracted.\", \"ce_output_schema(R), ce_prompt_template(R), ce_audit(W)\", \"context fields set\"], [\"State rule\", \"loan flow can move ELIGIBILITY_GATE -> CONFIRMATION after schema extraction, then PRE_AGENT_MCP moves CONFIRMATION -> PROCESS_APPLICATION before MCP.\", \"ce_rule(R), ce_audit(W)\", \"state confirmation gate before MCP\"], [\"MCP #1\", \"Need credit rating first.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL rating\"], [\"Tool #1\", \"Rating available and > 750.\", \"ce_audit(W)\", \"obs[0]=creditRating\"], [\"MCP #2\", \"Proceed to fraud check.\", \"ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL fraud\"], [\"Tool #2\", \"Fraud clear.\", \"ce_audit(W)\", \"obs[1]=flagged:false\"], [\"MCP #3\", \"Need affordability metrics.\", \"ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL debt summary\"], [\"Tool #3\", \"DTI acceptable and credit sufficient.\", \"ce_audit(W)\", \"obs[2]=dti/availableCredit\"], [\"MCP #4\", \"Submit application now.\", \"ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL submit\"], [\"Tool #4\", \"Submission succeeded.\", \"ce_audit(W)\", \"obs[3]=applicationId/status\"], [\"MCP ANSWER\", \"Enough evidence for final decision.\", \"ce_audit(W)\", \"context.mcp.finalAnswer\"], [\"ResponseResolutionStep\", \"Generate final user-facing summary.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"assistant text payload\"] ]} /> </TabItem> <TabItem value=\"low-rating\" label=\"Low Rating\"> <DbTable title=\"Early-stop branch: low credit score\" columns={[\"Loop/Step\", \"LLM deduction\", \"Tables touched\", \"Produced state/data\"]} rows={[ [\"MCP #1\", \"Call rating check.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"CALL_TOOL rating\"], [\"Tool #1\", \"creditRating <= 750.\", \"ce_audit(W)\", \"obs[0]=low rating\"], [\"MCP ANSWER\", \"Stop chain; reject without fraud/debt/submit.\", \"ce_mcp_planner(R), ce_audit(W)\", \"context.mcp.finalAnswer (rejection)\"], [\"ResponseResolutionStep\", \"Render low-score rejection summary.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"assistant text payload\"] ]} /> </TabItem> <TabItem value=\"fraud\" label=\"Fraud Flagged\"> <DbTable title=\"Branch: fraud hit after good rating\" columns={[\"Loop/Step\", \"LLM deduction\", \"Tables touched\", \"Produced state/data\"]} rows={[ [\"MCP #1 + Tool #1\", \"Rating is high enough to continue.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"obs[0]=rating\"], [\"MCP #2 + Tool #2\", \"Fraud flagged=true.\", \"ce_mcp_planner(R), ce_audit(W)\", \"obs[1]=fraud flagged\"], [\"MCP ANSWER\", \"Stop chain immediately; reject.\", \"ce_mcp_planner(R), ce_audit(W)\", \"context.mcp.finalAnswer (fraud rejection)\"], [\"ResponseResolutionStep\", \"Produce fraud-specific final text.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"assistant text payload\"] ]} /> </TabItem> <TabItem value=\"high-debt\" label=\"High Debt\"> <DbTable title=\"Branch: affordability fails after fraud clears\" columns={[\"Loop/Step\", \"LLM deduction\", \"Tables touched\", \"Produced state/data\"]} rows={[ [\"MCP #1 + Tool #1\", \"Rating allows continuation.\", \"ce_mcp_tool(R), ce_mcp_planner(R), ce_audit(W)\", \"obs[0]=rating\"], [\"MCP #2 + Tool #2\", \"Fraud clear.\", \"ce_mcp_planner(R), ce_audit(W)\", \"obs[1]=fraud false\"], [\"MCP #3 + Tool #3\", \"DTI too high or available credit too low.\", \"ce_mcp_planner(R), ce_audit(W)\", \"obs[2]=poor affordability\"], [\"MCP ANSWER\", \"Reject or mark manual review; skip submit.\", \"ce_mcp_planner(R), ce_audit(W)\", \"context.mcp.finalAnswer\"], [\"ResponseResolutionStep\", \"Generate debt/affordability explanation.\", \"ce_response(R), ce_prompt_template(R), ce_audit(W)\", \"assistant text payload\"] ]} /> </TabItem> </Tabs> ## ReactFlow Execution Map <EngineDebugFlow title=\"Example 2 End-to-End Execution\" subtitle=\"Conditional MCP chain from eligibility checks to final response resolution.\" nodes={loanExampleNodes} edges={loanExampleEdges} detailsById={loanExampleDetails} defaultSelectedId=\"m1\" /> ## Response Field Provenance <DbTable title=\"Where final response facts come from\" columns={[\"Response fact\", \"Primary source\", \"Stage where it enters context\"]} rows={[ [\"creditRating\", \"loan.credit.rating.check mapped payload\", \"MCP_TOOL_RESULT #1\"], [\"fraudFlag\", \"loan.credit.fraud.check mapped payload\", \"MCP_TOOL_RESULT #2\"], [\"dti / availableCredit\", \"loan.debt.credit.summary mapped payload\", \"MCP_TOOL_RESULT #3\"], [\"applicationId / submitStatus\", \"loan.application.submit mapped payload\", \"MCP_TOOL_RESULT #4 (approved path)\"], [\"Final decision sentence\", \"planner answer + response derivation\", \"MCP_FINAL_ANSWER + RESOLVE_RESPONSE_LLM_OUTPUT\"], ]} /> ## Notes on state and scope ce_mcp_tool rows in example2 are scoped as: - intent_code = LOAN_APPLICATION - state_code = ELIGIBILITY_GATE This ensures tools are visible only in the loan decision state. ## Troubleshooting - Tool not resolved: - verify tool_code in DB matches handler toolCode() exactly - No tool call in planner path: - check McpPlanner prompt rows in ce_mcp_planner - confirm active intent is LOAN_APPLICATION - Timeouts/retries unexpected: - inspect handler-specific HttpApiExecutionPolicy - inspect mock delay values in mockey/src/response/loan/*.json ## Related docs - [MCP Basics](/docs/v2/consumer/mcp/basics) - [MCP Advanced Guide](/docs/v2/consumer/mcp/advanced) - [MCP Example 1 (Mockey + Demo)](/docs/v2/consumer/mcp/example1)",
    "excerpt": "}, }, }, }, }, }, }, }, }, }, }, }, }, }, }, ]; , , , , , , , , , , , , , , ]; u1: , s1: , r1: , r2: , m1: , t1: , m2: , t2: , m3: , t3: , m4: , t4: , m5: , resp: , out: }; MCP Example 2 Loan Application (Conditional API…"
  },
  {
    "id": "consumer/mcp/example3.mdx",
    "version": "v2",
    "title": "example3",
    "permalink": "/docs/v2/consumer/mcp/example3",
    "content": "}, }, }, }, }, }, }, }, }, }, }, }, }, }, }, ]; , , , , , , , , , , , , , , , ]; g: , i: , s: , ps: , c: , fix: , ok: , pm: , p: , t1: , t2: , t3: , t4: , post: , done: }; MCP Example 3 Loan Application Extended This is the confirmation first version of the loan flow built around the newer runtime behavior: CorrectionStep handles confirmation affirmations and in place edits POST_DIALOGUE_ACT can override guarded dialogue act output before interaction policy runs POST_SCHEMA_EXTRACTION moves the flow into confirmation once required data is complete PRE_AGENT_MCP delays MCP until the user explicitly confirms SET_INPUT_PARAM can mark confirmation runtime flags without extra Java code SET_DIALOGUE_ACT can safely promote an LLM candidate act (for example EDIT ) back into the final dialogue_act ConvEngineVerboseAdapter / ce_verbose can emit custom progress messages for the confirm and process path This is the recommended state machine for the extended loan workflow: IDLE ELIGIBILITY_GATE CONFIRMATION PROCESS_APPLICATION COMPLETED The current convengine demo mcp_planner_seed.sql still scopes the loan planner and tools to ELIGIBILITY_GATE and closes directly to COMPLETED . It does not yet model CONFIRMATION and PROCESS_APPLICATION . This example shows the missing shape to add. Flow summary fraud debt submit in sequence.\"], [\"COMPLETED\", \"Final answer\", \"Derived response uses context.mcp.finalAnswer as the primary summary.\"] ]} / fraud debt submit.\" json= \" }, \" }, \" }, \" } ] } }} tables= info= / ELIGIBILITY_GATE CONFIRMATION PROCESS_APPLICATION COMPLETED\" nodes= edges= detailsById= defaultSelectedId=\"s\" / COMPLETED.\"], [\"Final response\", \"ce_response, ce_prompt_template\", \"ce_conversation, ce_audit\", \"Return the final derived summary from context.mcp.finalAnswer.\"] ]} / COMPLETED\", \"No confirmation checkpoint\", \"Add CONFIRMATION and PROCESS_APPLICATION phases in between.\"], [\"No confirmation prompt row\", \"No explicit user review step\", \"Add CONFIRMATION TEXT prompt + response.\"], [\"No PRE_AGENT_MCP confirmation rule\", \"No confirm before run gate\", \"Route only after routing_decision=PROCEED_CONFIRMED.\"] ]} / , \"requestedAmount\": , \"tenureMonths\": }, \"additionalProperties\":false }'::jsonb, 'Loan application required fields before confirmation', true, 1 ); Prompt templates Schema extraction prompt INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 124, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'SCHEMA_JSON', 'You are a strict structured extractor for loan application fields.', 'User input: } Context JSON: } Extract only: customerId requestedAmount tenureMonths Return actual values only if explicitly present in input/context. Return null for missing values. Return valid JSON only.', 0.00, 'COLLECT', ' ', true, CURRENT_TIMESTAMP ); IDLE intake prompt INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 122, 'LOAN_APPLICATION', 'IDLE', 'TEXT', 'You are a strict loan intake assistant.', 'Ask the user for the required fields needed to start the loan application: customerId, requestedAmount, and tenureMonths.', 0.00, 'IDLE', ' ', true, CURRENT_TIMESTAMP ); Intake / missing fields response INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 123, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'TEXT', 'You are a strict loan intake assistant.', 'Context JSON: } If } is not empty, ask only for the missing required fields. Do not confirm yet unless all required fields are present.', 0.00, 'COLLECT', ' ', true, CURRENT_TIMESTAMP ); Confirmation response INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 125, 'LOAN_APPLICATION', 'CONFIRMATION', 'TEXT', 'You are a strict confirmation assistant.', 'Context JSON: } Ask the user to confirm exactly these values: customerId: [[$'||' ]] requestedAmount: [[$'||' ]] tenureMonths: [[$'||' ]] If correction_applied is true, mention that the value was updated. Ask: Proceed?', 0.00, 'CONFIRM', ' ', true, CURRENT_TIMESTAMP ); Processing / retry enabled prompt (recommended so retry is contract driven in PROCESS_APPLICATION) INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 127, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'TEXT', 'You are a strict loan workflow processor.', 'Context JSON: } If context.mcp.finalAnswer exists, return it directly. If the latest MCP lifecycle shows an error, tell the user they can retry. Otherwise keep the reply concise and indicate processing is in progress.', 0.00, 'PROCESSING', ' ', true, CURRENT_TIMESTAMP ); Final response INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 126, 'LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'You are a strict loan workflow summarizer.', 'Context JSON: } Use context.mcp.finalAnswer as primary final answer. Use context.mcp.observations only to validate details.', 0.00, 'FINAL', ' ', true, CURRENT_TIMESTAMP ); Responses INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 223, 'LOAN_APPLICATION', 'IDLE', 'TEXT', 'DERIVED', NULL, 'Ask the user for any missing required fields needed to start loan processing.', NULL, 10, true, 'Loan intake response', CURRENT_TIMESTAMP ); INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 224, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'TEXT', 'DERIVED', NULL, 'If missing_fields is not empty, ask only for those fields.', NULL, 20, true, 'Loan missing fields response', CURRENT_TIMESTAMP ); INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 225, 'LOAN_APPLICATION', 'CONFIRMATION', 'TEXT', 'DERIVED', NULL, 'Display collected values and ask for confirmation. If correction_applied=true, mention the update first.', NULL, 10, true, 'Loan confirmation response', CURRENT_TIMESTAMP ); INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 226, 'LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'DERIVED', NULL, 'Use context.mcp.finalAnswer as primary answer. Include applicationId when present.', NULL, 10, true, 'Loan completed response', CURRENT_TIMESTAMP ); Optional exact response while processing if you expose it INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 227, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'TEXT', 'EXACT', 'Processing your loan application now.', NULL, NULL, 50, true, 'Optional processing placeholder', CURRENT_TIMESTAMP ); Rules Move loan flow from UNKNOWN IDLE after intent INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 128, 'POST_AGENT_INTENT', 'LOAN_APPLICATION', 'UNKNOWN', 'REGEX', '. ', 'SET_STATE', 'IDLE', 10, true, 'Move loan flow to IDLE when classifier returns UNKNOWN state', CURRENT_TIMESTAMP ); Move IDLE ELIGIBILITY_GATE after intent INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 129, 'POST_AGENT_INTENT', 'LOAN_APPLICATION', 'IDLE', 'REGEX', '. ', 'SET_STATE', 'ELIGIBILITY_GATE', 20, true, 'Move loan flow into ELIGIBILITY_GATE', CURRENT_TIMESTAMP ); Once schema is complete, move to confirmation INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 130, 'POST_SCHEMA_EXTRACTION', 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'JSON_PATH', '$[?(@.schemaComplete == true)]', 'SET_STATE', 'CONFIRMATION', 10, true, 'Move to CONFIRMATION when schema is complete', CURRENT_TIMESTAMP ); Safety net: if DialogueActStep guarded an LLM EDIT back to NEW_REQUEST, restore EDIT before policy runs INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 135, 'POST_DIALOGUE_ACT', 'LOAN_APPLICATION', 'ANY', 'JSON_PATH', '$[?(@.inputParams.dialogue_act == ''NEW_REQUEST'' && @.inputParams.dialogue_act_source == ''REGEX_GUARD'' && @.inputParams.dialogue_act_llm_candidate == ''EDIT'')]', 'SET_DIALOGUE_ACT', ' ', 5, true, 'Promote guarded LLM EDIT back to EDIT before interaction policy', CURRENT_TIMESTAMP ); If confirmation accepted, move to processing before MCP starts INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 131, 'PRE_AGENT_MCP', 'LOAN_APPLICATION', 'CONFIRMATION', 'JSON_PATH', '$[?(@.inputParams.routing_decision == ''PROCEED_CONFIRMED'')]', 'SET_STATE', 'PROCESS_APPLICATION', 10, true, 'Move CONFIRMATION PROCESS_APPLICATION when user confirms', CURRENT_TIMESTAMP ); Optional: if correction patch applied, keep explicit confirmation state INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 132, 'PRE_RESPONSE_RESOLUTION', 'LOAN_APPLICATION', 'CONFIRMATION', 'JSON_PATH', '$[?(@.inputParams.correction_applied == true)]', 'SET_STATE', 'CONFIRMATION', 50, true, 'Stay in confirmation after correction patch', CURRENT_TIMESTAMP ); When MCP final answer exists, finish the flow INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 133, 'POST_AGENT_MCP', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'JSON_PATH', '$[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.error == false && @.context.mcp.finalAnswer != null && @.context.mcp.finalAnswer != '''')]', 'SET_STATE', 'COMPLETED', 10, true, 'Move PROCESS_APPLICATION COMPLETED only when MCP finishes successfully with final answer', CURRENT_TIMESTAMP ); Example runtime flags using SET_INPUT_PARAM (optional) INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 134, 'POST_SCHEMA_EXTRACTION', 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'JSON_PATH', '$[?(@.schemaComplete == true)]', 'SET_INPUT_PARAM', ' ', 11, true, 'Legacy optional runtime flags when schema becomes complete (prompt template interaction metadata is now preferred)', CURRENT_TIMESTAMP ); MCP planner INSERT INTO ce_mcp_planner (planner_id, intent_code, state_code, system_prompt, user_prompt, enabled, created_at) VALUES ( 6202, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'You are an MCP planning agent for a loan application workflow. You MUST follow tool order: 1) loan.credit.rating.check 2) If creditRating ANSWER reject 3) Else loan.credit.fraud.check 4) If flagged=true = ANSWER reject 5) Else loan.debt.credit.summary 6) If dti 0.65 or availableCredit ANSWER reject/manual review 7) Else loan.application.submit 8) ANSWER with applicationId. Return JSON only.', 'User input: } Context JSON: } Available MCP tools: } Existing MCP observations: } Return strict JSON: , \"answer\":\" \" }', true, CURRENT_TIMESTAMP ); MCP tools (only visible in PROCESS_APPLICATION) INSERT INTO ce_mcp_tool (tool_id, tool_code, tool_group, intent_code, state_code, enabled, description, created_at) VALUES (10201, 'loan.credit.rating.check', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 1: credit rating check', CURRENT_TIMESTAMP), (10202, 'loan.credit.fraud.check', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 2: fraud check', CURRENT_TIMESTAMP), (10203, 'loan.debt.credit.summary', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 3: debt and credit summary', CURRENT_TIMESTAMP), (10204, 'loan.application.submit', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 4: submit application', CURRENT_TIMESTAMP); Optional ce_verbose rows for the new flow INSERT INTO ce_verbose (verbose_id, intent_code, state_code, step_match, step_value, determinant, rule_id, tool_code, message, error_message, priority, enabled, created_at) VALUES ( 201, 'LOAN_APPLICATION', 'CONFIRMATION', 'EXACT', 'CorrectionStep', 'CONFIRM_ACCEPT', NULL, NULL, 'Confirmation accepted. Starting loan processing.', 'Could not continue after confirmation.', 10, true, CURRENT_TIMESTAMP ), ( 202, 'LOAN_APPLICATION', 'CONFIRMATION', 'EXACT', 'CorrectionStep', 'CORRECTION_PATCH_APPLIED', NULL, NULL, 'Updated [[$'||' ]]. Please confirm again.', 'Could not apply the requested correction.', 10, true, CURRENT_TIMESTAMP ), ( 203, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'EXACT', 'McpToolStep', 'MCP_TOOL_CALL', NULL, 'loan.application.submit', 'Submitting loan application now.', 'Loan submission failed.', 10, true, CURRENT_TIMESTAMP ); } fraud debt submit in order.\"], [\"9\", \"Assistant final\", \"POST_AGENT_MCP moves to COMPLETED and returns the final loan summary.\"] ]} / For the exact phrase “I missed one zero, it is 350000”, the cleanest path is: 1. DialogueActStep keeps the LLM candidate as dialogue_act_llm_candidate=EDIT 2. POST_DIALOGUE_ACT can use SET_DIALOGUE_ACT to restore EDIT if the guarded final result stayed NEW_REQUEST 3. CorrectionStep patches the field in place Explicit forms like “change amount to 350000” are still the most reliable with the current deterministic patch path. Why this flow is the recommended pattern This example exists to solve two common problems cleanly: “I need rules after schema extraction, but before MCP starts.” “I asked for confirmation, the user said yes, and I do not want to run schema extraction again.” The correct answer is not “stuff more prompt context into every turn.” The correct answer is to treat the turn type as a routing decision. Post schema, pre MCP control points Use both phases, but for different reasons: In this loan flow: 1. POST_SCHEMA_EXTRACTION sees schemaComplete=true 2. it sets state=CONFIRMATION 3. the active ce_prompt_template for CONFIRMATION should use interaction_mode=CONFIRM 4. optional interaction_contract can allow affirm , edit , and reset 5. optional POST_DIALOGUE_ACT rule with SET_DIALOGUE_ACT restores guarded LLM EDIT before interaction policy runs 6. user replies 7. CorrectionStep interprets the reply from prompt template interaction metadata 8. PRE_AGENT_MCP decides whether MCP should start That is the clean way to run rules after schema extraction but before MCP. How confirmation turns should work When the engine asks: Please confirm: customerId 1234, requestedAmount 350000, tenureMonths 24. Proceed? the next user turn should not be treated like a fresh extraction request. Use this shape instead: DialogueActStep normalizes yes , go ahead , please do it , looks good into AFFIRM CorrectionStep checks the active prompt template ( interaction_mode=CONFIRM ) plus dialogue act if the active template allows affirm and dialogue act is AFFIRM , it sets a routing flag such as routing_decision=PROCEED_CONFIRMED downstream steps skip expensive or unnecessary work This is why DialogueActStep is crucial: rules should match on the normalized signal, not raw free form text. How to apply rules on “yes”, “go ahead”, and similar replies Do not write ce_rule against raw strings like: yes go ahead confirm That is fragile and ambiguous. Use a scoped runtime pattern: Then your rules can check: current state active prompt template interaction_mode active prompt template interaction_contract dialogue_act inputParams.routing_decision That is much safer than parsing raw “yes” in SQL. How retry should work after MCP failure If an MCP call fails in PROCESS_APPLICATION , the flow should stay in PROCESS_APPLICATION , not jump to COMPLETED . Use this shape: POST_AGENT_MCP completion rule matches only when context.mcp.lifecycle.finished == true and context.mcp.lifecycle.error == false the PROCESS_APPLICATION prompt template uses interaction_mode=PROCESSING the PROCESS_APPLICATION interaction_contract includes retry CorrectionStep detects retry phrases like retry , try again , and again it sets routing_decision=RETRY_IN_PLACE , skip_intent_resolution=true , and skip_schema_extraction=true McpToolStep then runs again in the same state and re calls the API That gives you deterministic retry behavior without depending on state name parsing or arbitrary runtime flags. How to avoid another schema extraction call This is the key optimization. When the user has already supplied: customerId requestedAmount tenureMonths and the engine is already in CONFIRMATION , a reply like: Looks good, go ahead. should not trigger a full schema extraction again. Recommended behavior: 1. DialogueActStep returns AFFIRM 2. CorrectionStep sees an active confirmation prompt ( interaction_mode=CONFIRM ) 3. it sets routing_decision=PROCEED_CONFIRMED 4. it also sets skip_schema_extraction=true 5. SchemaExtractionStep is skipped 6. PRE_AGENT_MCP sees routing_decision=PROCEED_CONFIRMED and moves to PROCESS_APPLICATION That avoids: one more LLM call redundant re parsing of already collected data accidental mutation of existing schema values How partial edits should work When the user says: Ohh wait, I missed one zero. Change amount to 350000. the engine should not perform a full schema extraction from scratch. Recommended CorrectionStep behavior: 1. detect dialogue_act=EDIT 2. inspect existing schema in context 3. patch only the changed field ( requestedAmount ) 4. keep untouched fields ( customerId , tenureMonths ) 5. recompute schema completeness 6. stay in CONFIRMATION 7. set: correction_applied=true correction_target_field=requestedAmount skip_schema_extraction=true Then the assistant re renders the confirmation view with only the changed value updated. That is exactly why this example uses: CONFIRMATION as a dedicated state CorrectionStep before rework SET_INPUT_PARAM for lightweight runtime flags SET_DIALOGUE_ACT for safe post classification dialogue act overrides PRE_AGENT_MCP as the final start gate Recommended step level strategy For confirmation first business flows, the best pipeline behavior is: Keep control in structured runtime state ( inputParams , context , dialogue_act , routing_decision ) and keep prompts focused on wording. Use rules and steps for routing, not prompt text for control flow.",
    "rawContent": "{ id: \"g\", data: { label: \"GREETING\" } }, { id: \"i\", data: { label: \"IDLE -> ELIGIBILITY_GATE\" } }, { id: \"s\", data: { label: \"SchemaExtractionStep\" } }, { id: \"ps\", data: { label: \"POST_SCHEMA_EXTRACTION\" } }, { id: \"c\", data: { label: \"CONFIRMATION\" } }, { id: \"fix\", data: { label: \"CorrectionStep (EDIT)\" } }, { id: \"ok\", data: { label: \"CorrectionStep (AFFIRM)\" } }, { id: \"pm\", data: { label: \"PRE_AGENT_MCP\" } }, { id: \"p\", data: { label: \"PROCESS_APPLICATION\" } }, { id: \"t1\", data: { label: \"loan.credit.rating.check\" } }, { id: \"t2\", data: { label: \"loan.credit.fraud.check\" } }, { id: \"t3\", data: { label: \"loan.debt.credit.summary\" } }, { id: \"t4\", data: { label: \"loan.application.submit\" } }, { id: \"post\", data: { label: \"POST_AGENT_MCP\" } }, { id: \"done\", data: { label: \"COMPLETED\" } }, ]; { id: \"e1\", source: \"g\", target: \"i\" }, { id: \"e2\", source: \"i\", target: \"s\" }, { id: \"e3\", source: \"s\", target: \"ps\" }, { id: \"e4\", source: \"ps\", target: \"c\" }, { id: \"e5\", source: \"c\", target: \"fix\" }, { id: \"e6\", source: \"fix\", target: \"c\" }, { id: \"e7\", source: \"c\", target: \"ok\" }, { id: \"e8\", source: \"ok\", target: \"pm\" }, { id: \"e9\", source: \"pm\", target: \"p\" }, { id: \"e10\", source: \"p\", target: \"t1\" }, { id: \"e11\", source: \"t1\", target: \"t2\" }, { id: \"e12\", source: \"t2\", target: \"t3\" }, { id: \"e13\", source: \"t3\", target: \"t4\" }, { id: \"e14\", source: \"t4\", target: \"post\" }, { id: \"e15\", source: \"post\", target: \"done\" }, ]; g: { title: \"Greeting turn\", stage: \"REQUEST\", summary: \"User says hi. Normal greeting flow stays outside the loan path.\", session: [\"intent=GREETING\", \"state=IDLE\"], tables: [\"ce_intent_classifier (R)\", \"ce_response (R)\", \"ce_audit (W)\"] }, i: { title: \"Loan intake bootstrap\", stage: \"POST_AGENT_INTENT\", summary: \"Loan intent starts in IDLE, then rules move the flow into ELIGIBILITY_GATE.\", session: [\"intent=LOAN_APPLICATION\", \"state=ELIGIBILITY_GATE\"], tables: [\"ce_intent_classifier (R)\", \"ce_rule (POST_AGENT_INTENT)\", \"ce_audit (W)\"] }, s: { title: \"Schema extraction\", stage: \"SCHEMA_EXTRACTION\", summary: \"Collects customerId, requestedAmount, and tenureMonths using the ELIGIBILITY_GATE schema + prompt template.\", session: [\"context.customerId\", \"context.requestedAmount\", \"context.tenureMonths\", \"schemaComplete\"], tables: [\"ce_output_schema (R)\", \"ce_prompt_template (SCHEMA_JSON)\", \"ce_audit (W)\"] }, ps: { title: \"Schema complete transition\", stage: \"POST_SCHEMA_EXTRACTION\", summary: \"When schemaComplete=true, the engine moves ELIGIBILITY_GATE -> CONFIRMATION and the active prompt template becomes the confirmation contract.\", session: [\"state=CONFIRMATION\", \"interaction_mode=CONFIRM\"], tables: [\"ce_rule (POST_SCHEMA_EXTRACTION)\", \"ce_audit (W)\"] }, c: { title: \"Confirmation response\", stage: \"RESOLVE_RESPONSE\", summary: \"The confirmation prompt shows only the collected values and asks the user to proceed or correct them.\", session: [\"state=CONFIRMATION\"], tables: [\"ce_response (R)\", \"ce_prompt_template (TEXT)\", \"ce_audit (W)\"] }, fix: { title: \"In-place correction\", stage: \"CORRECTION\", summary: \"CorrectionStep patches only the changed field, keeps CONFIRMATION, and avoids full schema re-extraction.\", session: [\"correction_applied=true\", \"correction_target_field=requestedAmount\"], tables: [\"ce_audit (W)\", \"ce_verbose (optional R)\"] }, ok: { title: \"Confirmation accepted\", stage: \"CORRECTION\", summary: \"AFFIRM in confirmation sets routing_decision=PROCEED_CONFIRMED.\", session: [\"routing_decision=PROCEED_CONFIRMED\"], tables: [\"ce_audit (W)\", \"ce_verbose (optional R)\"] }, pm: { title: \"Pre-MCP gate\", stage: \"PRE_AGENT_MCP\", summary: \"Rule checks routing_decision and moves CONFIRMATION -> PROCESS_APPLICATION just before MCP starts.\", session: [\"state=PROCESS_APPLICATION\"], tables: [\"ce_rule (PRE_AGENT_MCP)\", \"ce_audit (W)\"] }, p: { title: \"Processing state\", stage: \"MCP_PLAN\", summary: \"Planner and tools are scoped to PROCESS_APPLICATION only, so no APIs run before user confirmation.\", session: [\"state=PROCESS_APPLICATION\", \"context.mcp.lifecycle active\"], tables: [\"ce_mcp_planner (R)\", \"ce_mcp_tool (R)\", \"ce_audit (W)\"] }, t1: { title: \"Credit rating\", stage: \"MCP_TOOL_CALL\", summary: \"Tool 1 checks credit rating.\", session: [\"context.mcp.observations[0]=credit rating\"], tables: [\"ce_audit (W)\", \"ce_verbose (optional R)\"] }, t2: { title: \"Fraud check\", stage: \"MCP_TOOL_CALL\", summary: \"Tool 2 runs only when rating passes the threshold.\", session: [\"context.mcp.observations[1]=fraud result\"], tables: [\"ce_audit (W)\"] }, t3: { title: \"Debt summary\", stage: \"MCP_TOOL_CALL\", summary: \"Tool 3 evaluates dti and availableCredit.\", session: [\"context.mcp.observations[2]=debt profile\"], tables: [\"ce_audit (W)\"] }, t4: { title: \"Application submit\", stage: \"MCP_TOOL_CALL\", summary: \"Tool 4 submits the loan application when all prior checks pass.\", session: [\"context.mcp.observations[3]=submit result\"], tables: [\"ce_audit (W)\", \"ce_verbose (optional R)\"] }, post: { title: \"Final MCP transition\", stage: \"POST_AGENT_MCP\", summary: \"When context.mcp.finalAnswer exists, rules move PROCESS_APPLICATION -> COMPLETED.\", session: [\"state=COMPLETED\", \"context.mcp.finalAnswer set\"], tables: [\"ce_rule (POST_AGENT_MCP)\", \"ce_audit (W)\"] }, done: { title: \"Completed response\", stage: \"ASSISTANT_OUTPUT\", summary: \"The completed response uses context.mcp.finalAnswer as the primary answer and validates against MCP observations.\", session: [\"final payload returned\"], tables: [\"ce_response (R)\", \"ce_prompt_template (TEXT)\", \"ce_conversation (W)\", \"ce_audit (W)\"] } }; # MCP Example 3 - Loan Application Extended This is the confirmation-first version of the loan flow built around the newer runtime behavior: - CorrectionStep handles confirmation affirmations and in-place edits - POST_DIALOGUE_ACT can override guarded dialogue-act output before interaction policy runs - POST_SCHEMA_EXTRACTION moves the flow into confirmation once required data is complete - PRE_AGENT_MCP delays MCP until the user explicitly confirms - SET_INPUT_PARAM can mark confirmation runtime flags without extra Java code - SET_DIALOGUE_ACT can safely promote an LLM candidate act (for example EDIT ) back into the final dialogue_act - ConvEngineVerboseAdapter / ce_verbose can emit custom progress messages for the confirm-and-process path This is the recommended state machine for the extended loan workflow: IDLE -> ELIGIBILITY_GATE -> CONFIRMATION -> PROCESS_APPLICATION -> COMPLETED <Highlight type=\"warning\" title=\"Current demo seed gap\"> The current convengine-demo mcp_planner_seed.sql still scopes the loan planner and tools to ELIGIBILITY_GATE and closes directly to COMPLETED . It does not yet model CONFIRMATION and PROCESS_APPLICATION . This example shows the missing shape to add. </Highlight> ## Flow summary <DbTable title=\"State flow\" columns={[\"State\", \"Purpose\", \"What happens here\"]} rows={[ [\"IDLE\", \"Loan intake entry\", \"Intent is recognized; rule moves into ELIGIBILITY_GATE.\"], [\"ELIGIBILITY_GATE\", \"Required field collection\", \"Schema extraction collects customerId, requestedAmount, tenureMonths.\"], [\"CONFIRMATION\", \"User review\", \"Show exact collected values; allow AFFIRM or EDIT.\"], [\"PROCESS_APPLICATION\", \"MCP execution\", \"Planner runs credit -> fraud -> debt -> submit in sequence.\"], [\"COMPLETED\", \"Final answer\", \"Derived response uses context.mcp.finalAnswer as the primary summary.\"] ]} /> <Tabs groupId=\"mcp-example-3\"> <TabItem value=\"chat\" label=\"Chat + Trace\" default> <ChatContainer> <TraceChatBubble role=\"user\" name=\"Turn 1 - User\" message=\"Hi\" info={[\"Greeting classifier matches.\", \"Loan flow has not started yet.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 1 - Assistant\" intent=\"GREETING\" state=\"IDLE\" message=\"Hi, how can I help you today?\" json={{ intent: \"GREETING\", state: \"IDLE\" }} tables={[\"ce_intent_classifier (R)\", \"ce_response (R)\", \"ce_audit (W)\"]} info={[\"Normal greeting response.\"]} /> <TraceChatBubble role=\"user\" name=\"Turn 2 - User\" message=\"I need a loan for my customer\" info={[\"Loan classifier matches LOAN_APPLICATION.\", \"POST_AGENT_INTENT rules move the flow into ELIGIBILITY_GATE.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 2 - Assistant\" intent=\"LOAN_APPLICATION\" state=\"ELIGIBILITY_GATE\" message=\"Please provide customerId, requestedAmount, and tenureMonths.\" json={{ intent: \"LOAN_APPLICATION\", state: \"ELIGIBILITY_GATE\", missing_fields: [\"customerId\", \"requestedAmount\", \"tenureMonths\"] }} tables={[\"ce_rule (POST_AGENT_INTENT)\", \"ce_output_schema (R)\", \"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"]} info={[\"Schema is incomplete, so the engine asks only for missing required fields.\"]} /> <TraceChatBubble role=\"user\" name=\"Turn 3 - User\" message=\"customer id 1234, 35000, 24 months\" info={[\"Schema extraction fills all three required fields.\", \"POST_SCHEMA_EXTRACTION can now move the flow into CONFIRMATION.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 3 - Assistant\" intent=\"LOAN_APPLICATION\" state=\"CONFIRMATION\" message=\"Please confirm: customerId 1234, requestedAmount 35000, tenureMonths 24. Proceed?\" json={{ state: \"CONFIRMATION\", interaction_mode: \"CONFIRM\", interaction_contract: { allows: [\"affirm\", \"edit\", \"reset\"], expects: [] } }} tables={[\"ce_output_schema (R)\", \"ce_rule (POST_SCHEMA_EXTRACTION)\", \"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"]} info={[\"Schema is complete.\", \"No MCP tools run yet because the flow stops at confirmation first.\"]} /> <TraceChatBubble role=\"user\" name=\"Turn 4 - User\" message=\"Ohh wait, I missed one zero. Change amount to 350000.\" info={[\"DialogueActStep should resolve EDIT.\", \"CorrectionStep patches only requestedAmount in place.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 4 - Assistant\" intent=\"LOAN_APPLICATION\" state=\"CONFIRMATION\" message=\"Updated. Please confirm: customerId 1234, requestedAmount 350000, tenureMonths 24. Proceed?\" json={{ state: \"CONFIRMATION\", correction_applied: true, correction_target_field: \"requestedAmount\" }} tables={[\"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\", \"ce_verbose (optional R)\"]} info={[\"Only the amount changes.\", \"The engine stays in CONFIRMATION and skips full schema re-extraction.\"]} /> <TraceChatBubble role=\"user\" name=\"Turn 5 - User\" message=\"Looks good, go ahead.\" info={[\"DialogueActStep resolves AFFIRM.\", \"CorrectionStep sets routing_decision=PROCEED_CONFIRMED.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 5 - Internal MCP Loop\" intent=\"LOAN_APPLICATION\" state=\"PROCESS_APPLICATION\" message=\"Confirmation accepted. Starting loan processing. PRE_AGENT_MCP moves to PROCESS_APPLICATION. Planner executes credit -> fraud -> debt -> submit.\" json={{ state: \"PROCESS_APPLICATION\", routing_decision: \"PROCEED_CONFIRMED\", mcp: { observations: [ { toolCode: \"loan.credit.rating.check\", json: \"{\\\"creditRating\\\":782}\" }, { toolCode: \"loan.credit.fraud.check\", json: \"{\\\"flagged\\\":false}\" }, { toolCode: \"loan.debt.credit.summary\", json: \"{\\\"dti\\\":0.31,\\\"availableCredit\\\":220000}\" }, { toolCode: \"loan.application.submit\", json: \"{\\\"applicationId\\\":\\\"APP-90817\\\",\\\"status\\\":\\\"SUBMITTED\\\"}\" } ] } }} tables={[\"ce_rule (PRE_AGENT_MCP)\", \"ce_mcp_planner (R)\", \"ce_mcp_tool (R)\", \"ce_audit (W)\", \"ce_verbose (optional R)\"]} info={[\"Tools are now scoped to PROCESS_APPLICATION.\", \"This is the missing step in the current demo seed.\"]} /> <TraceChatBubble role=\"assistant\" name=\"Turn 5 - Final\" intent=\"LOAN_APPLICATION\" state=\"COMPLETED\" message=\"Loan application submitted successfully for customer 1234. Requested amount: 350000, tenure: 24 months. Credit rating passed, fraud check clear, debt profile acceptable. Application ID: APP-90817.\" json={{ state: \"COMPLETED\", mcp: { finalAnswer: \"Loan application submitted successfully for customer 1234. Requested amount: 350000, tenure: 24 months. Application ID: APP-90817.\", lifecycle: { phase: \"POST_AGENT_MCP\", status: \"ANSWER\", outcome: \"ANSWERED\", finished: true } } }} tables={[\"ce_rule (POST_AGENT_MCP)\", \"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_conversation (W)\", \"ce_audit (W)\"]} info={[\"POST_AGENT_MCP closes the flow only after context.mcp.finalAnswer exists.\", \"COMPLETED response derives from final MCP context.\"]} /> </ChatContainer> </TabItem> <TabItem value=\"flow\" label=\"Step Graph\"> <EngineDebugFlow title=\"Extended loan confirmation-first flow\" subtitle=\"IDLE -> ELIGIBILITY_GATE -> CONFIRMATION -> PROCESS_APPLICATION -> COMPLETED\" nodes={loanExtendedNodes} edges={loanExtendedEdges} detailsById={loanExtendedDetails} defaultSelectedId=\"s\" /> </TabItem> <TabItem value=\"tables\" label=\"Component Tables\"> <DbTable title=\"Table usage by phase\" columns={[\"Phase\", \"Reads\", \"Writes\", \"Why it matters\"]} rows={[ [\"Intent bootstrap\", \"ce_intent_classifier, ce_rule\", \"ce_audit\", \"Classifier starts in IDLE; rules move into ELIGIBILITY_GATE.\"], [\"Schema collection\", \"ce_output_schema, ce_prompt_template, ce_response\", \"ce_audit\", \"Collect and ask only for missing fields.\"], [\"Schema complete gate\", \"ce_rule\", \"ce_audit\", \"POST_SCHEMA_EXTRACTION moves to CONFIRMATION and can set runtime flags.\"], [\"Confirmation response\", \"ce_response, ce_prompt_template\", \"ce_audit\", \"Shows exact collected values before any MCP call.\"], [\"Correction path\", \"session/context, optional ce_verbose\", \"ce_audit\", \"Patch only the changed field and stay in CONFIRMATION.\"], [\"Pre-MCP gate\", \"ce_rule\", \"ce_audit\", \"PRE_AGENT_MCP checks routing_decision and unlocks PROCESS_APPLICATION.\"], [\"Planner + tools\", \"ce_mcp_planner, ce_mcp_tool\", \"ce_audit\", \"Run the credit/fraud/debt/submit chain only after confirmation.\"], [\"Post-MCP close\", \"ce_rule\", \"ce_audit\", \"POST_AGENT_MCP moves PROCESS_APPLICATION -> COMPLETED.\"], [\"Final response\", \"ce_response, ce_prompt_template\", \"ce_conversation, ce_audit\", \"Return the final derived summary from context.mcp.finalAnswer.\"] ]} /> <DbTable title=\"What is missing from the current demo seed\" columns={[\"Current seed\", \"Missing piece\", \"Needed for this example\"]} rows={[ [\"Classifier starts LOAN_APPLICATION in ELIGIBILITY_GATE\", \"No clean IDLE intake entry\", \"Classifier starts in IDLE, then POST_AGENT_INTENT advances.\"], [\"Planner scoped to ELIGIBILITY_GATE\", \"Runs too early\", \"Planner row should be scoped to PROCESS_APPLICATION.\"], [\"Tools scoped to ELIGIBILITY_GATE\", \"APIs can run before confirmation\", \"Tool rows should be scoped to PROCESS_APPLICATION.\"], [\"POST_AGENT_MCP closes ELIGIBILITY_GATE -> COMPLETED\", \"No confirmation checkpoint\", \"Add CONFIRMATION and PROCESS_APPLICATION phases in between.\"], [\"No confirmation prompt row\", \"No explicit user review step\", \"Add CONFIRMATION TEXT prompt + response.\"], [\"No PRE_AGENT_MCP confirmation rule\", \"No confirm-before-run gate\", \"Route only after routing_decision=PROCEED_CONFIRMED.\"] ]} /> </TabItem> <TabItem value=\"sql\" label=\"Complete SQL\"> <CodeBlockToggle title=\"Extended loan flow DDL/DML\" language=\"sql\" defaultOpen={false}> { -- ------------------------------------------------------------ -- Intents -- ------------------------------------------------------------ INSERT INTO ce_intent (intent_code, description, priority, enabled, created_at, display_name, llm_hint) VALUES ('LOAN_APPLICATION', 'Loan application eligibility and submission workflow', 30, true, CURRENT_TIMESTAMP, 'Loan Application', 'Handle loan checks and submission using MCP APIs in strict sequence.'); INSERT INTO ce_intent (intent_code, description, priority, enabled, created_at, display_name, llm_hint) VALUES ('GREETING', 'When user greets you', 15, true, CURRENT_TIMESTAMP, 'GREETING', 'Reply with firm greetings'); INSERT INTO ce_intent (intent_code, description, priority, enabled, created_at, display_name, llm_hint) VALUES ('UNKNOWN', 'Fallback intent', 999, true, CURRENT_TIMESTAMP, 'Unknown', 'Fallback when no intent matches'); -- ------------------------------------------------------------ -- Intent classifier -- ------------------------------------------------------------ INSERT INTO ce_intent_classifier (classifier_id, intent_code, state_code, rule_type, pattern, priority, enabled, description) VALUES (108, 'LOAN_APPLICATION', 'IDLE', 'REGEX', '(?i)\\\\b(loan|apply loan|personal loan|home loan|loan application)\\\\b', 30, true, 'Loan application classifier -> start in IDLE'); -- ------------------------------------------------------------ -- Output schema (collect required fields in ELIGIBILITY_GATE) -- ------------------------------------------------------------ INSERT INTO ce_output_schema (schema_id, intent_code, state_code, json_schema, description, enabled, priority) VALUES ( 109, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', '{ \"type\":\"object\", \"required\":[\"customerId\",\"requestedAmount\",\"tenureMonths\"], \"properties\":{ \"customerId\":{\"type\":\"string\",\"maxLength\":64,\"minLength\":1}, \"requestedAmount\":{\"type\":\"number\",\"minimum\":1000,\"maximum\":50000000}, \"tenureMonths\":{\"type\":\"integer\",\"minimum\":6,\"maximum\":480} }, \"additionalProperties\":false }'::jsonb, 'Loan application required fields before confirmation', true, 1 ); -- ------------------------------------------------------------ -- Prompt templates -- ------------------------------------------------------------ -- Schema extraction prompt INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 124, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'SCHEMA_JSON', 'You are a strict structured extractor for loan application fields.', 'User input: {{resolved_user_input}} Context JSON: {{context}} Extract only: - customerId - requestedAmount - tenureMonths Return actual values only if explicitly present in input/context. Return null for missing values. Return valid JSON only.', 0.00, 'COLLECT', '{\"allows\":[\"reset\"],\"expects\":[\"structured_input\"]}', true, CURRENT_TIMESTAMP ); -- IDLE intake prompt INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 122, 'LOAN_APPLICATION', 'IDLE', 'TEXT', 'You are a strict loan intake assistant.', 'Ask the user for the required fields needed to start the loan application: customerId, requestedAmount, and tenureMonths.', 0.00, 'IDLE', '{\"allows\":[\"reset\"],\"expects\":[]}', true, CURRENT_TIMESTAMP ); -- Intake / missing-fields response INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 123, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'TEXT', 'You are a strict loan intake assistant.', 'Context JSON: {{context}} If {{missing_fields}} is not empty, ask only for the missing required fields. Do not confirm yet unless all required fields are present.', 0.00, 'COLLECT', '{\"allows\":[\"reset\"],\"expects\":[\"structured_input\"]}', true, CURRENT_TIMESTAMP ); -- Confirmation response INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 125, 'LOAN_APPLICATION', 'CONFIRMATION', 'TEXT', 'You are a strict confirmation assistant.', 'Context JSON: {{context}} Ask the user to confirm exactly these values: - customerId: [[$'||'{context.customerId}]] - requestedAmount: [[$'||'{context.requestedAmount}]] - tenureMonths: [[$'||'{context.tenureMonths}]] If correction_applied is true, mention that the value was updated. Ask: Proceed?', 0.00, 'CONFIRM', '{\"allows\":[\"affirm\",\"edit\",\"reset\"],\"expects\":[]}', true, CURRENT_TIMESTAMP ); -- Processing / retry-enabled prompt (recommended so retry is contract-driven in PROCESS_APPLICATION) INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 127, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'TEXT', 'You are a strict loan workflow processor.', 'Context JSON: {{context}} If context.mcp.finalAnswer exists, return it directly. If the latest MCP lifecycle shows an error, tell the user they can retry. Otherwise keep the reply concise and indicate processing is in progress.', 0.00, 'PROCESSING', '{\"allows\":[\"retry\",\"reset\"],\"expects\":[]}', true, CURRENT_TIMESTAMP ); -- Final response INSERT INTO ce_prompt_template (template_id, intent_code, state_code, response_type, system_prompt, user_prompt, temperature, interaction_mode, interaction_contract, enabled, created_at) VALUES ( 126, 'LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'You are a strict loan workflow summarizer.', 'Context JSON: {{context}} Use context.mcp.finalAnswer as primary final answer. Use context.mcp.observations only to validate details.', 0.00, 'FINAL', '{\"allows\":[\"reset\"],\"expects\":[]}', true, CURRENT_TIMESTAMP ); -- ------------------------------------------------------------ -- Responses -- ------------------------------------------------------------ INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 223, 'LOAN_APPLICATION', 'IDLE', 'TEXT', 'DERIVED', NULL, 'Ask the user for any missing required fields needed to start loan processing.', NULL, 10, true, 'Loan intake response', CURRENT_TIMESTAMP ); INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 224, 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'TEXT', 'DERIVED', NULL, 'If missing_fields is not empty, ask only for those fields.', NULL, 20, true, 'Loan missing-fields response', CURRENT_TIMESTAMP ); INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 225, 'LOAN_APPLICATION', 'CONFIRMATION', 'TEXT', 'DERIVED', NULL, 'Display collected values and ask for confirmation. If correction_applied=true, mention the update first.', NULL, 10, true, 'Loan confirmation response', CURRENT_TIMESTAMP ); INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 226, 'LOAN_APPLICATION', 'COMPLETED', 'TEXT', 'DERIVED', NULL, 'Use context.mcp.finalAnswer as primary answer. Include applicationId when present.', NULL, 10, true, 'Loan completed response', CURRENT_TIMESTAMP ); -- Optional exact response while processing if you expose it INSERT INTO ce_response (response_id, intent_code, state_code, output_format, response_type, exact_text, derivation_hint, json_schema, priority, enabled, description, created_at) VALUES ( 227, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'TEXT', 'EXACT', 'Processing your loan application now.', NULL, NULL, 50, true, 'Optional processing placeholder', CURRENT_TIMESTAMP ); -- ------------------------------------------------------------ -- Rules -- ------------------------------------------------------------ -- Move loan flow from UNKNOWN -> IDLE after intent INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 128, 'POST_AGENT_INTENT', 'LOAN_APPLICATION', 'UNKNOWN', 'REGEX', '.*', 'SET_STATE', 'IDLE', 10, true, 'Move loan flow to IDLE when classifier returns UNKNOWN state', CURRENT_TIMESTAMP ); -- Move IDLE -> ELIGIBILITY_GATE after intent INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 129, 'POST_AGENT_INTENT', 'LOAN_APPLICATION', 'IDLE', 'REGEX', '.*', 'SET_STATE', 'ELIGIBILITY_GATE', 20, true, 'Move loan flow into ELIGIBILITY_GATE', CURRENT_TIMESTAMP ); -- Once schema is complete, move to confirmation INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 130, 'POST_SCHEMA_EXTRACTION', 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'JSON_PATH', '$[?(@.schemaComplete == true)]', 'SET_STATE', 'CONFIRMATION', 10, true, 'Move to CONFIRMATION when schema is complete', CURRENT_TIMESTAMP ); -- Safety net: if DialogueActStep guarded an LLM EDIT back to NEW_REQUEST, restore EDIT before policy runs INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 135, 'POST_DIALOGUE_ACT', 'LOAN_APPLICATION', 'ANY', 'JSON_PATH', '$[?(@.inputParams.dialogue_act == ''NEW_REQUEST'' && @.inputParams.dialogue_act_source == ''REGEX_GUARD'' && @.inputParams.dialogue_act_llm_candidate == ''EDIT'')]', 'SET_DIALOGUE_ACT', '{\"dialogueAct\":\"EDIT\",\"source\":\"POST_DIALOGUE_ACT_RULE\"}', 5, true, 'Promote guarded LLM EDIT back to EDIT before interaction policy', CURRENT_TIMESTAMP ); -- If confirmation accepted, move to processing before MCP starts INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 131, 'PRE_AGENT_MCP', 'LOAN_APPLICATION', 'CONFIRMATION', 'JSON_PATH', '$[?(@.inputParams.routing_decision == ''PROCEED_CONFIRMED'')]', 'SET_STATE', 'PROCESS_APPLICATION', 10, true, 'Move CONFIRMATION -> PROCESS_APPLICATION when user confirms', CURRENT_TIMESTAMP ); -- Optional: if correction patch applied, keep explicit confirmation state INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 132, 'PRE_RESPONSE_RESOLUTION', 'LOAN_APPLICATION', 'CONFIRMATION', 'JSON_PATH', '$[?(@.inputParams.correction_applied == true)]', 'SET_STATE', 'CONFIRMATION', 50, true, 'Stay in confirmation after correction patch', CURRENT_TIMESTAMP ); -- When MCP final answer exists, finish the flow INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 133, 'POST_AGENT_MCP', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'JSON_PATH', '$[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.error == false && @.context.mcp.finalAnswer != null && @.context.mcp.finalAnswer != '''')]', 'SET_STATE', 'COMPLETED', 10, true, 'Move PROCESS_APPLICATION -> COMPLETED only when MCP finishes successfully with final answer', CURRENT_TIMESTAMP ); -- Example runtime flags using SET_INPUT_PARAM (optional) INSERT INTO ce_rule (rule_id, phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled, description, created_at) VALUES ( 134, 'POST_SCHEMA_EXTRACTION', 'LOAN_APPLICATION', 'ELIGIBILITY_GATE', 'JSON_PATH', '$[?(@.schemaComplete == true)]', 'SET_INPUT_PARAM', '{\"awaiting_confirmation\":true,\"confirmation_key\":\"LOAN_APPLICATION_CONFIRM\"}', 11, true, 'Legacy optional runtime flags when schema becomes complete (prompt-template interaction metadata is now preferred)', CURRENT_TIMESTAMP ); -- ------------------------------------------------------------ -- MCP planner -- ------------------------------------------------------------ INSERT INTO ce_mcp_planner (planner_id, intent_code, state_code, system_prompt, user_prompt, enabled, created_at) VALUES ( 6202, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'You are an MCP planning agent for a loan application workflow. You MUST follow tool order: 1) loan.credit.rating.check 2) If creditRating <= 750 => ANSWER reject 3) Else loan.credit.fraud.check 4) If flagged=true => ANSWER reject 5) Else loan.debt.credit.summary 6) If dti > 0.65 or availableCredit < requestedAmount*0.15 => ANSWER reject/manual-review 7) Else loan.application.submit 8) ANSWER with applicationId. Return JSON only.', 'User input: {{resolved_user_input}} Context JSON: {{context}} Available MCP tools: {{mcp_tools}} Existing MCP observations: {{mcp_observations}} Return strict JSON: { \"action\":\"CALL_TOOL\" | \"ANSWER\", \"tool_code\":\"<tool_code_or_null>\", \"args\":{}, \"answer\":\"<text_or_null>\" }', true, CURRENT_TIMESTAMP ); -- ------------------------------------------------------------ -- MCP tools (only visible in PROCESS_APPLICATION) -- ------------------------------------------------------------ INSERT INTO ce_mcp_tool (tool_id, tool_code, tool_group, intent_code, state_code, enabled, description, created_at) VALUES (10201, 'loan.credit.rating.check', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 1: credit rating check', CURRENT_TIMESTAMP), (10202, 'loan.credit.fraud.check', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 2: fraud check', CURRENT_TIMESTAMP), (10203, 'loan.debt.credit.summary', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 3: debt and credit summary', CURRENT_TIMESTAMP), (10204, 'loan.application.submit', 'HTTP_API', 'LOAN_APPLICATION', 'PROCESS_APPLICATION', true, 'Step 4: submit application', CURRENT_TIMESTAMP); -- ------------------------------------------------------------ -- Optional ce_verbose rows for the new flow -- ------------------------------------------------------------ INSERT INTO ce_verbose (verbose_id, intent_code, state_code, step_match, step_value, determinant, rule_id, tool_code, message, error_message, priority, enabled, created_at) VALUES ( 201, 'LOAN_APPLICATION', 'CONFIRMATION', 'EXACT', 'CorrectionStep', 'CONFIRM_ACCEPT', NULL, NULL, 'Confirmation accepted. Starting loan processing.', 'Could not continue after confirmation.', 10, true, CURRENT_TIMESTAMP ), ( 202, 'LOAN_APPLICATION', 'CONFIRMATION', 'EXACT', 'CorrectionStep', 'CORRECTION_PATCH_APPLIED', NULL, NULL, 'Updated [[$'||'{correction_target_field}]]. Please confirm again.', 'Could not apply the requested correction.', 10, true, CURRENT_TIMESTAMP ), ( 203, 'LOAN_APPLICATION', 'PROCESS_APPLICATION', 'EXACT', 'McpToolStep', 'MCP_TOOL_CALL', NULL, 'loan.application.submit', 'Submitting loan application now.', 'Loan submission failed.', 10, true, CURRENT_TIMESTAMP ); } </CodeBlockToggle> </TabItem> <TabItem value=\"conversation\" label=\"Expected Conversation\"> <DbTable title=\"Expected next conversation\" columns={[\"Turn\", \"User / System\", \"Expected behavior\"]} rows={[ [\"1\", \"User: Hi\", \"Intent GREETING, state IDLE, normal greeting response.\"], [\"2\", \"User: I need a loan for my customer\", \"Intent LOAN_APPLICATION, POST_AGENT_INTENT moves to ELIGIBILITY_GATE, ask for missing fields.\"], [\"3\", \"User: customer id 1234, 35000, 24 months\", \"Schema extraction fills all required fields, POST_SCHEMA_EXTRACTION moves to CONFIRMATION.\"], [\"4\", \"Assistant\", \"Please confirm: customerId 1234, requestedAmount 35000, tenureMonths 24. Proceed?\"], [\"5\", \"User: Ohh wait, I missed one zero. Change amount to 350000.\", \"DialogueAct=EDIT, CorrectionStep patches requestedAmount only, stays in CONFIRMATION.\"], [\"6\", \"Assistant\", \"Updated. Please confirm: customerId 1234, requestedAmount 350000, tenureMonths 24. Proceed?\"], [\"7\", \"User: Looks good, go ahead.\", \"DialogueAct=AFFIRM, routing_decision=PROCEED_CONFIRMED, PRE_AGENT_MCP moves to PROCESS_APPLICATION.\"], [\"8\", \"System internal\", \"Planner runs credit -> fraud -> debt -> submit in order.\"], [\"9\", \"Assistant final\", \"POST_AGENT_MCP moves to COMPLETED and returns the final loan summary.\"] ]} /> <Highlight type=\"tip\" title=\"Natural-language correction note\"> For the exact phrase “I missed one zero, it is 350000”, the cleanest path is: 1. DialogueActStep keeps the LLM candidate as dialogue_act_llm_candidate=EDIT 2. POST_DIALOGUE_ACT can use SET_DIALOGUE_ACT to restore EDIT if the guarded final result stayed NEW_REQUEST 3. CorrectionStep patches the field in place Explicit forms like “change amount to 350000” are still the most reliable with the current deterministic patch path. </Highlight> </TabItem> </Tabs> ## Why this flow is the recommended pattern This example exists to solve two common problems cleanly: - “I need rules after schema extraction, but before MCP starts.” - “I asked for confirmation, the user said yes, and I do not want to run schema extraction again.” The correct answer is not “stuff more prompt context into every turn.” The correct answer is to treat the turn type as a routing decision. ## Post-schema, pre-MCP control points Use both phases, but for different reasons: <DbTable title=\"Why both rule phases exist\" columns={[\"Phase\", \"When it runs\", \"Use it for\"]} rows={[ [\"POST_SCHEMA_EXTRACTION\", \"Immediately after schema merge and schemaComplete recompute\", \"Move to CONFIRMATION, set confirmation flags, seed lightweight runtime variables.\"], [\"PRE_AGENT_MCP\", \"At the start of MCP execution, just before planner/tool logic\", \"Final gate for starting MCP, changing state, or skipping MCP entirely.\"] ]} /> In this loan flow: 1. POST_SCHEMA_EXTRACTION sees schemaComplete=true 2. it sets state=CONFIRMATION 3. the active ce_prompt_template for CONFIRMATION should use interaction_mode=CONFIRM 4. optional interaction_contract can allow affirm , edit , and reset 5. optional POST_DIALOGUE_ACT rule with SET_DIALOGUE_ACT restores guarded LLM EDIT before interaction policy runs 6. user replies 7. CorrectionStep interprets the reply from prompt-template interaction metadata 8. PRE_AGENT_MCP decides whether MCP should start That is the clean way to run rules after schema extraction but before MCP. ## How confirmation turns should work When the engine asks: Please confirm: customerId 1234, requestedAmount 350000, tenureMonths 24. Proceed? the next user turn should not be treated like a fresh extraction request. Use this shape instead: - DialogueActStep normalizes yes , go ahead , please do it , looks good into AFFIRM - CorrectionStep checks the active prompt template ( interaction_mode=CONFIRM ) plus dialogue act - if the active template allows affirm and dialogue act is AFFIRM , it sets a routing flag such as routing_decision=PROCEED_CONFIRMED - downstream steps skip expensive or unnecessary work This is why DialogueActStep is crucial: rules should match on the normalized signal, not raw free-form text. ## How to apply rules on “yes”, “go ahead”, and similar replies Do not write ce_rule against raw strings like: - yes - go ahead - confirm That is fragile and ambiguous. Use a scoped runtime pattern: <DbTable title=\"Confirmation interaction pattern\" columns={[\"Variable\", \"Who sets it\", \"Why it exists\"]} rows={[ [\"interaction_mode\", \"ce_prompt_template\", \"Marks that this turn is a confirmation checkpoint.\"], [\"interaction_contract\", \"ce_prompt_template\", \"Declares allowed capabilities such as affirm/edit/reset.\"], [\"routing_decision\", \"CorrectionStep\", \"Normalizes the next branch, for example PROCEED_CONFIRMED.\"], [\"skip_schema_extraction\", \"CorrectionStep or later rule\", \"Prevents another schema extraction call for confirm-accept turns.\"], [\"correction_applied\", \"CorrectionStep\", \"Lets confirmation response explain that a value was updated.\"] ]} /> Then your rules can check: - current state - active prompt-template interaction_mode - active prompt-template interaction_contract - dialogue_act - inputParams.routing_decision That is much safer than parsing raw “yes” in SQL. ## How retry should work after MCP failure If an MCP call fails in PROCESS_APPLICATION , the flow should stay in PROCESS_APPLICATION , not jump to COMPLETED . Use this shape: - POST_AGENT_MCP completion rule matches only when context.mcp.lifecycle.finished == true and context.mcp.lifecycle.error == false - the PROCESS_APPLICATION prompt template uses interaction_mode=PROCESSING - the PROCESS_APPLICATION interaction_contract includes retry - CorrectionStep detects retry phrases like retry , try again , and again - it sets routing_decision=RETRY_IN_PLACE , skip_intent_resolution=true , and skip_schema_extraction=true - McpToolStep then runs again in the same state and re-calls the API That gives you deterministic retry behavior without depending on state-name parsing or arbitrary runtime flags. ## How to avoid another schema extraction call This is the key optimization. When the user has already supplied: - customerId - requestedAmount - tenureMonths and the engine is already in CONFIRMATION , a reply like: Looks good, go ahead. should not trigger a full schema extraction again. Recommended behavior: 1. DialogueActStep returns AFFIRM 2. CorrectionStep sees an active confirmation prompt ( interaction_mode=CONFIRM ) 3. it sets routing_decision=PROCEED_CONFIRMED 4. it also sets skip_schema_extraction=true 5. SchemaExtractionStep is skipped 6. PRE_AGENT_MCP sees routing_decision=PROCEED_CONFIRMED and moves to PROCESS_APPLICATION That avoids: - one more LLM call - redundant re-parsing of already-collected data - accidental mutation of existing schema values ## How partial edits should work When the user says: Ohh wait, I missed one zero. Change amount to 350000. the engine should not perform a full schema extraction from scratch. Recommended CorrectionStep behavior: 1. detect dialogue_act=EDIT 2. inspect existing schema in context 3. patch only the changed field ( requestedAmount ) 4. keep untouched fields ( customerId , tenureMonths ) 5. recompute schema completeness 6. stay in CONFIRMATION 7. set: - correction_applied=true - correction_target_field=requestedAmount - skip_schema_extraction=true Then the assistant re-renders the confirmation view with only the changed value updated. That is exactly why this example uses: - CONFIRMATION as a dedicated state - CorrectionStep before rework - SET_INPUT_PARAM for lightweight runtime flags - SET_DIALOGUE_ACT for safe post-classification dialogue-act overrides - PRE_AGENT_MCP as the final start gate ## Recommended step-level strategy For confirmation-first business flows, the best pipeline behavior is: <DbTable title=\"Recommended routing behavior\" columns={[\"Situation\", \"What should happen\", \"What should be skipped\"]} rows={[ [\"Schema just became complete\", \"POST_SCHEMA_EXTRACTION moves to CONFIRMATION\", \"No MCP yet\"], [\"User AFFIRM in CONFIRMATION\", \"CorrectionStep sets routing_decision and PRE_AGENT_MCP starts MCP\", \"Skip schema extraction; usually skip intent re-resolution\"], [\"User EDIT in CONFIRMATION\", \"CorrectionStep patches the field and re-confirms\", \"Skip full schema extraction when patch is deterministic\"], [\"User reply is ambiguous\", \"Fall back to clarification or a small patch path\", \"Do not blindly rerun the full flow\"] ]} /> <Highlight type=\"tip\" title=\"The design principle\"> Keep control in structured runtime state ( inputParams , context , dialogue_act , routing_decision ) and keep prompts focused on wording. Use rules and steps for routing, not prompt text for control flow. </Highlight>",
    "excerpt": "}, }, }, }, }, }, }, }, }, }, }, }, }, }, }, ]; , , , , , , , , , , , , , , , ]; g: , i: , s: , ps: , c: , fix: , ok: , pm: , p: , t1: , t2: , t3: , t4: , post: , done: }; MCP Example 3 Loan Application Extended This is …"
  },
  {
    "id": "consumer/mcp/http-tool.mdx",
    "version": "v2",
    "title": "http tool",
    "permalink": "/docs/v2/consumer/mcp/http-tool",
    "content": "MCP HTTP Tool ConvEngine supports two HTTP MCP integration models. Two ways delegate.invoke processResponse\"], ]} / Related libraries: Model A: HttpApiRequestingToolHandler Flow 1. Handler returns HttpApiRequestSpec 2. Framework executes HTTP call 3. Mapping mode resolves output 4. MCP observation is stored Supported mapping modes: RAW_JSON JSON_PATH FIELD_TEMPLATE MAPPER_CLASS TEXT MAPPER_CLASS example: java new HttpApiResponseMapping( HttpApiResponseMappingMode.MAPPER_CLASS, null, Map.of(), \"com.acme.api.OrderStatusResponse\"); Model B: HttpApiProcessorToolHandler Flow 1. wsContext(...) builds tool context 2. wsHandler(...) returns RestWebServiceHandler 3. Framework calls RestWebServiceFacade.initiate(...) 4. prepareRequest(...) runs 5. delegate invoke(...) runs 6. processResponse(...) maps output 7. framework calls extractResponse(...) and stores MCP observation convengine demo package convention In demo we now keep each MCP tool in its own folder tree with dedicated handler/delegate: mcp/handler/loan/credit/rating/... mcp/handler/loan/credit/fraud/... mcp/handler/loan/application/submit/... mcp/handler/mock/customer/profile/... mcp/handler/mock/order/status/... mcp/handler/mock/order/async/trace/... mcp/handler/mock/order/submit/... Each tool folder contains: ToolHandler (MCP SPI class) handler/ WsHandler delegate/ WsDelegate Shared lightweight helper types are in: mcp/handler/common/... As requested, LoanDebtSummaryToolHandler remains HttpApiRequestingToolHandler to demonstrate the framework managed HTTP model side by side with mode. What MockOrderAsyncTraceToolHandler does mock.order.async.trace fetches async callback trace details for an order: traceId api4AsyncStatus callbackReceivedAt message It is used in order diagnostics flow to explain why an order can be submitted while async callback is still pending or null. Related",
    "rawContent": "# MCP HTTP Tool ConvEngine supports two HTTP MCP integration models. ## Two ways <DbTable title=\"HTTP MCP models\" columns={[\"Model\", \"Use when\", \"How it executes\"]} rows={[ [\"HttpApiRequestingToolHandler\", \"You want framework-managed retries/timeouts/circuit/auth/mapping\", \"HttpApiToolInvoker (framework HttpClient)\"], [\"HttpApiProcessorToolHandler\", \"You already use [api-processor](https://github.com/salilvnair/api-processor) in your app\", \"RestWebServiceFacade -> delegate.invoke -> processResponse\"], ]} /> Related libraries: - [api-processor](https://github.com/salilvnair/api-processor) - [ccf-core](https://github.com/salilvnair/ccf-core) ## Model A: HttpApiRequestingToolHandler ### Flow 1. Handler returns HttpApiRequestSpec 2. Framework executes HTTP call 3. Mapping mode resolves output 4. MCP observation is stored Supported mapping modes: - RAW_JSON - JSON_PATH - FIELD_TEMPLATE - MAPPER_CLASS - TEXT MAPPER_CLASS example: java new HttpApiResponseMapping( HttpApiResponseMappingMode.MAPPER_CLASS, null, Map.of(), \"com.acme.api.OrderStatusResponse\"); ## Model B: HttpApiProcessorToolHandler ### Flow 1. wsContext(...) builds tool context 2. wsHandler(...) returns RestWebServiceHandler 3. Framework calls RestWebServiceFacade.initiate(...) 4. prepareRequest(...) runs 5. delegate invoke(...) runs 6. processResponse(...) maps output 7. framework calls extractResponse(...) and stores MCP observation ## convengine-demo package convention In demo we now keep each [api-processor](https://github.com/salilvnair/api-processor) MCP tool in its own folder tree with dedicated handler/delegate: - mcp/handler/loan/credit/rating/... - mcp/handler/loan/credit/fraud/... - mcp/handler/loan/application/submit/... - mcp/handler/mock/customer/profile/... - mcp/handler/mock/order/status/... - mcp/handler/mock/order/async/trace/... - mcp/handler/mock/order/submit/... Each tool folder contains: - <Tool>ToolHandler (MCP SPI class) - handler/<Tool>WsHandler - delegate/<Tool>WsDelegate Shared lightweight helper types are in: - mcp/handler/common/... <Highlight type=\"tip\" title=\"Debt tool intentionally unchanged\"> As requested, LoanDebtSummaryToolHandler remains HttpApiRequestingToolHandler to demonstrate the framework-managed HTTP model side-by-side with [api-processor](https://github.com/salilvnair/api-processor) mode. </Highlight> ## What MockOrderAsyncTraceToolHandler does mock.order.async.trace fetches async callback trace details for an order: - traceId - api4AsyncStatus - callbackReceivedAt - message It is used in order diagnostics flow to explain why an order can be submitted while async callback is still pending or null. ## Related - [MCP Basics](/docs/v2/consumer/mcp/basics) - [MCP Advanced Guide](/docs/v2/consumer/mcp/advanced) - [MCP Example 1](/docs/v2/consumer/mcp/example1) - [MCP Example 2](/docs/v2/consumer/mcp/example2)",
    "excerpt": "MCP HTTP Tool ConvEngine supports two HTTP MCP integration models. Two ways delegate.invoke processResponse\"], ]} / Related libraries: Model A: HttpApiRequestingToolHandler Flow 1. Handler returns HttpApiRequestSpec 2. F…"
  },
  {
    "id": "consumer/new-consumer-onboarding.mdx",
    "version": "v2",
    "title": "new consumer onboarding",
    "permalink": "/docs/v2/consumer/new-consumer-onboarding",
    "content": "New Consumer Onboarding This is the current onboarding path for teams integrating ConvEngine on the active v2 release line. The older onboarding page was written around the original 2.0.0 launch assumptions. The framework has moved on. The current line includes: CorrectionStep ce_mcp_planner ce_verbose extra rule phases ( POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP , POST_DIALOGUE_ACT ) richer MCP metadata shared Thymeleaf prompt rendering So a modern integration should be set up with those capabilities in mind from day one. Start with the right baseline Dependency version Use the current framework version from the repo: convengine:2.0.9 1. Add the framework dependency 2. Enable the framework in your Spring Boot app The minimal production friendly baseline is: @EnableConvEngine @EnableConvEngineCaching @EnableConvEngineAsyncConversation Add async audit dispatch only if your deployment needs it. } } 3. Provide required consumer side beans You still need consumer owned infrastructure: one production grade LlmClient bean datasource + JPA configuration your own tool handlers / task executors / transformers when you use those features LLM adapter expectations Your LlmClient should be treated as production infrastructure, not demo glue code: define strict timeout policy define retry policy appropriate to your provider log failures in a trace friendly way make request identity and conversation correlation observable 4. Apply the framework schema Before you test any conversation flow, create the ce_ tables from the current DDL for your dialect. At minimum, new consumers usually need these control plane areas seeded: ce_intent ce_intent_classifier ce_output_schema ce_prompt_template ce_response ce_rule Use these only when the feature is actually in scope: ce_pending_action ce_mcp_tool ce_mcp_planner ce_verbose ce_container_config ce_policy 5. Seed one complete vertical slice first Do not try to model your entire product on day one. Build one narrow, fully testable path: one intent one or two states one response path one optional schema zero or one tool That first slice should prove: intent resolves correctly state transitions are deterministic a final response always exists audit/trace output is understandable 6. Treat prompt templates as behavior contracts This is one of the biggest differences in the current v2 line. ce_prompt_template is no longer just prompt text. In 2.0.9+ , prompt rows also document how a state is expected to behave. Relevant metadata: interaction_mode interaction_contract Recommended contract patterns: collection state: interaction_mode=COLLECT interaction_contract= confirmation state: interaction_mode=CONFIRM interaction_contract= in flight processing state: interaction_mode=PROCESSING interaction_contract= final state: interaction_mode=FINAL This is what allows CorrectionStep to safely do in place confirm/edit/retry routing. 7. Start with a safe configuration baseline 8. If you adopt MCP, start narrow Current MCP is much stronger than earlier docs implied: ce_mcp_tool uses mandatory scoped intent_code and state_code ce_mcp_planner selects prompts by scoped fallback order PRE_AGENT_MCP and POST_AGENT_MCP can drive rule based branching context.mcp.lifecycle. and context.mcp.toolExecution. expose deterministic state for rule matching Good first MCP rollout: one tool one intent exact scope, not ANY one planner row plus one fallback row one explicit ce_response path for success and one for failure/fallback Bad first MCP rollout: many ANY scoped tools no response coverage no rule inspection of lifecycle outcomes no handler level business authorization 9. Use ce_verbose early Modern onboarding should include ce_verbose , not just raw audit inspection. Why: it gives clearer runtime progress for UI and QA it exposes skipped/error/step transitions more readably it turns invisible config mistakes into visible operator signals Even a small first rollout should seed a handful of verbose rows for: STEP_ENTER STEP_ERROR INTENT_RESOLVED SCHEMA_STATUS RESOLVE_RESPONSE_SELECTED MCP_TOOL_CALL / MCP_TOOL_ERROR if you use MCP 10. Validate with a real pre production checklist 11. Recommended onboarding sequence Add the 2.0.9 dependency, enable ConvEngine, and provide a production grade LlmClient . Create the ce_ tables and seed one intent with one clean end to end conversation path. Turn on audit, inspect /api/v1/conversation/audit/ and /api/v1/conversation/audit/ /trace , and seed a minimal ce_verbose layer. Test missing fields, user edits, retries, guardrail skips, and no response edge cases. Expand into tools or task execution after the base conversational path is deterministic and traceable. Common onboarding mistakes in the current framework The right first milestone is not \"all features enabled.\" It is one narrow, testable, traceable business flow that your team can explain end to end from input to persisted state to final response.",
    "rawContent": "# New Consumer Onboarding This is the current onboarding path for teams integrating ConvEngine on the active v2 release line. The older onboarding page was written around the original 2.0.0 launch assumptions. The framework has moved on. The current line includes: - CorrectionStep - ce_mcp_planner - ce_verbose - extra rule phases ( POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP , POST_DIALOGUE_ACT ) - richer MCP metadata - shared Thymeleaf prompt rendering So a modern integration should be set up with those capabilities in mind from day one. ## Start with the right baseline <DbTable title=\"Day-0 decisions\" columns={[\"Decision\", \"Why it matters\", \"Recommended default\"]} rows={[ [\"Java baseline\", \"ConvEngine compiles against Java 21.\", \"Standardize on Java 21 in all environments.\"], [\"Conversation concurrency\", \"The framework does not enforce optimistic locking for ce_conversation .\", \"Allow only one active turn per conversationId .\"], [\"Transport\", \"Streaming is optional but changes operational setup.\", \"Start with SSE only; enable STOMP later if you truly need it.\"], [\"Prompt contract discipline\", \"Current v2 uses prompts for both text generation and turn behavior metadata.\", \"Treat ce_prompt_template as a runtime contract, not just copy.\"], [\"MCP adoption\", \"The current MCP model is powerful, but it adds scope, planner, and tool-governance responsibilities.\", \"Start with one narrow intent-scoped tool flow before scaling out.\"] ]} /> ## Dependency version Use the current framework version from the repo: - convengine:2.0.9 ## 1. Add the framework dependency <Tabs groupId=\"bootstrap\"> <TabItem value=\"maven\" label=\"pom.xml\" default> <CodeBlockToggle title=\"Maven dependency\" language=\"xml\"> { <dependency> <groupId>com.github.salilvnair</groupId> <artifactId>convengine</artifactId> <version>2.0.9</version> </dependency> } </CodeBlockToggle> </TabItem> <TabItem value=\"gradle\" label=\"build.gradle.kts\"> <CodeBlockToggle title=\"Gradle dependency\" language=\"kotlin\"> { implementation(\"com.github.salilvnair:convengine:2.0.9\") } </CodeBlockToggle> </TabItem> </Tabs> ## 2. Enable the framework in your Spring Boot app The minimal production-friendly baseline is: - @EnableConvEngine - @EnableConvEngineCaching - @EnableConvEngineAsyncConversation Add async audit dispatch only if your deployment needs it. <CodeBlockToggle title=\"Application bootstrap\" language=\"java\"> { @SpringBootApplication @EnableConvEngine(stream = true) @EnableConvEngineCaching @EnableConvEngineAsyncConversation public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } } </CodeBlockToggle> ## 3. Provide required consumer-side beans You still need consumer-owned infrastructure: - one production-grade LlmClient bean - datasource + JPA configuration - your own tool handlers / task executors / transformers when you use those features ### LLM adapter expectations Your LlmClient should be treated as production infrastructure, not demo glue code: - define strict timeout policy - define retry policy appropriate to your provider - log failures in a trace-friendly way - make request identity and conversation correlation observable ## 4. Apply the framework schema Before you test any conversation flow, create the ce_* tables from the current DDL for your dialect. At minimum, new consumers usually need these control-plane areas seeded: - ce_intent - ce_intent_classifier - ce_output_schema - ce_prompt_template - ce_response - ce_rule Use these only when the feature is actually in scope: - ce_pending_action - ce_mcp_tool - ce_mcp_planner - ce_verbose - ce_container_config - ce_policy ## 5. Seed one complete vertical slice first Do not try to model your entire product on day one. Build one narrow, fully testable path: - one intent - one or two states - one response path - one optional schema - zero or one tool That first slice should prove: - intent resolves correctly - state transitions are deterministic - a final response always exists - audit/trace output is understandable ## 6. Treat prompt templates as behavior contracts This is one of the biggest differences in the current v2 line. ce_prompt_template is no longer just prompt text. In 2.0.9+ , prompt rows also document how a state is expected to behave. Relevant metadata: - interaction_mode - interaction_contract Recommended contract patterns: - collection state: - interaction_mode=COLLECT - interaction_contract={\"expects\":[\"structured_input\"]} - confirmation state: - interaction_mode=CONFIRM - interaction_contract={\"allows\":[\"affirm\",\"edit\",\"reset\"]} - in-flight processing state: - interaction_mode=PROCESSING - interaction_contract={\"allows\":[\"retry\",\"reset\"]} - final state: - interaction_mode=FINAL This is what allows CorrectionStep to safely do in-place confirm/edit/retry routing. ## 7. Start with a safe configuration baseline <CodeBlockToggle title=\"Recommended starter config\" language=\"yaml\"> { convengine: flow: dialogue-act: resolute: REGEX_THEN_LLM llm-threshold: 0.90 conversation-history: max-turns: 20 interaction-policy: execute-pending-on-affirm: true reject-pending-on-negate: true fill-pending-slot-on-non-new-request: true require-resolved-intent-and-state: true action-lifecycle: enabled: true ttl-turns: 3 ttl-minutes: 30 tool-orchestration: enabled: true guardrail: enabled: true sanitize-input: true require-approval-for-sensitive-actions: false approval-gate-fail-closed: false sensitive-patterns: [] state-graph: enabled: true soft-block-on-violation: false disambiguation: enabled: true max-options: 5 memory: enabled: true summary-max-chars: 1200 recent-turns-for-summary: 3 query-rewrite: enabled: true transport: sse: enabled: true stomp: enabled: false audit: enabled: true persist-meta: true level: ALL persistence: mode: IMMEDIATE dispatch: async-enabled: false mcp: guardrail: enabled: false fail-closed: false experimental: enabled: false } </CodeBlockToggle> ## 8. If you adopt MCP, start narrow Current MCP is much stronger than earlier docs implied: - ce_mcp_tool uses mandatory scoped intent_code and state_code - ce_mcp_planner selects prompts by scoped fallback order - PRE_AGENT_MCP and POST_AGENT_MCP can drive rule-based branching - context.mcp.lifecycle.* and context.mcp.toolExecution.* expose deterministic state for rule matching Good first MCP rollout: - one tool - one intent - exact scope, not ANY - one planner row plus one fallback row - one explicit ce_response path for success and one for failure/fallback Bad first MCP rollout: - many ANY -scoped tools - no response coverage - no rule inspection of lifecycle outcomes - no handler-level business authorization ## 9. Use ce_verbose early Modern onboarding should include ce_verbose , not just raw audit inspection. Why: - it gives clearer runtime progress for UI and QA - it exposes skipped/error/step transitions more readably - it turns invisible config mistakes into visible operator signals Even a small first rollout should seed a handful of verbose rows for: - STEP_ENTER - STEP_ERROR - INTENT_RESOLVED - SCHEMA_STATUS - RESOLVE_RESPONSE_SELECTED - MCP_TOOL_CALL / MCP_TOOL_ERROR if you use MCP ## 10. Validate with a real pre-production checklist <DbTable title=\"Minimum readiness checklist\" columns={[\"Area\", \"Must prove before rollout\", \"Common failure if skipped\"]} rows={[ [\"Single-turn deterministic path\", \"One happy-path intent works end-to-end from /message to final payload.\", \"Basic config is incomplete or inconsistent.\"], [\"Multi-turn slot collection\", \"Missing fields converge cleanly and stop asking once complete.\", \"Infinite or unstable clarification loops.\"], [\"Confirmation / correction routing\", \" AFFIRM , EDIT , and retry do what the active prompt contract says.\", \"Unexpected reclassification or incorrect in-place continuation.\"], [\"State coverage\", \"Every reachable state has a valid response strategy.\", \"Fallback or misleading output in production.\"], [\"Concurrency guard\", \"Parallel same-ID requests do not corrupt state.\", \"Last-write-wins drift.\"], [\"Trace usability\", \"Your team can read audit + trace and explain a bad turn quickly.\", \"Slow incident resolution.\"] ]} /> ## 11. Recommended onboarding sequence <FlowStep step=\"1\" title=\"Wire framework and LLM\"> Add the 2.0.9 dependency, enable ConvEngine, and provide a production-grade LlmClient . </FlowStep> <FlowStep step=\"2\" title=\"Apply schema and seed one narrow flow\"> Create the ce_* tables and seed one intent with one clean end-to-end conversation path. </FlowStep> <FlowStep step=\"3\" title=\"Enable traceability\"> Turn on audit, inspect /api/v1/conversation/audit/{conversationId} and /api/v1/conversation/audit/{conversationId}/trace , and seed a minimal ce_verbose layer. </FlowStep> <FlowStep step=\"4\" title=\"Exercise correction and failure paths\"> Test missing fields, user edits, retries, guardrail skips, and no-response edge cases. </FlowStep> <FlowStep step=\"5\" title=\"Add MCP or pending actions only after the core path is stable\"> Expand into tools or task execution after the base conversational path is deterministic and traceable. </FlowStep> ## Common onboarding mistakes in the current framework <DbTable title=\"Mistakes to avoid\" columns={[\"Mistake\", \"Why it hurts now\", \"Safer alternative\"]} rows={[ [\"Using old examples as if v2 were still 2.0.0 \", \"You miss newer behavior like CorrectionStep , ce_mcp_planner , and richer rule phases.\", \"Model your rollout on the current repo and current docs.\"], [\"Overusing ANY scope for tools\", \"The engine stays valid, but your blast radius gets too broad too early.\", \"Prefer exact intent/state scope first.\"], [\"Treating prompt rows as plain copy\", \"Modern v2 uses prompt metadata for routing semantics.\", \"Design prompt rows as both text and behavior contracts.\"], [\"Skipping trace review\", \"Most production issues are config mistakes, not Java exceptions.\", \"Make audit + trace review mandatory in QA.\"], [\"Launching without conversation-level serialization\", \"The framework still does not solve ingress concurrency for you.\", \"Enforce one active turn per conversation.\"] ]} /> <Highlight type=\"info\" title=\"Best first milestone\"> The right first milestone is not \"all features enabled.\" It is one narrow, testable, traceable business flow that your team can explain end-to-end from input to persisted state to final response. </Highlight>",
    "excerpt": "New Consumer Onboarding This is the current onboarding path for teams integrating ConvEngine on the active v2 release line. The older onboarding page was written around the original 2.0.0 launch assumptions. The framewor…"
  },
  {
    "id": "consumer/session-reset-and-continuity.mdx",
    "version": "v2",
    "title": "session reset and continuity",
    "permalink": "/docs/v2/consumer/session-reset-and-continuity",
    "content": "Session, Reset, and Continuity What is restored per turn From ce_conversation , session restores: intent_code state_code context_json input_params_json From context branch values, session also restores cross turn values such as clarification and intent lock metadata. Intent lock lifecycle Intent lock is used for incomplete schema collection to avoid drift. lock set when required schema fields are still missing intent resolver skip logic respects lock lock removed when schema is complete or schema path is absent Sticky intent lifecycle ( ce_config ) IntentResolutionStep.STICKY_INTENT applies during active incomplete schema collection to keep intent stable while required fields are still missing. when enabled, IntentResolutionStep skips re resolution only while incomplete schema collection is active skip emits audit stage: INTENT_RESOLVE_SKIPPED_STICKY_INTENT re resolution runs once schema collection is complete, and still runs for explicit switch/reset/force signals Force re resolution signals: reset commands: reset , restart , /reset , /restart switch phrases: switch to ... , switch intent , change intent/flow/mode input params: force_intent_resolution=true , resolve_intent=true , switch_intent=true , switch_flow=true , switch_mode=true active clarification flow Reset triggers request body reset=true input params reset , restart , conversation_reset text commands reset , restart , /reset , /restart intent based reset via ResetResolvedIntentStep ( ce_config ) Practical advice Keep reset intent names explicit and reserved ( RESET_SESSION style) Avoid mixing business intents with reset intents Audit CONVERSATION_RESET stages in pre production tests If reset logic is custom coded only in controller, multi turn state may still leak from existing conversation context. Use pipeline reset steps, not ad hoc request branching.",
    "rawContent": "# Session, Reset, and Continuity ## What is restored per turn From ce_conversation , session restores: - intent_code - state_code - context_json - input_params_json From context branch values, session also restores cross-turn values such as clarification and intent lock metadata. ## Intent lock lifecycle Intent lock is used for incomplete schema collection to avoid drift. - lock set when required schema fields are still missing - intent resolver skip logic respects lock - lock removed when schema is complete or schema path is absent ## Sticky intent lifecycle ( ce_config ) IntentResolutionStep.STICKY_INTENT applies during active incomplete schema collection to keep intent stable while required fields are still missing. - when enabled, IntentResolutionStep skips re-resolution only while incomplete schema collection is active - skip emits audit stage: INTENT_RESOLVE_SKIPPED_STICKY_INTENT - re-resolution runs once schema collection is complete, and still runs for explicit switch/reset/force signals <CodeBlockToggle title=\"Sticky intent config\" language=\"sql\"> { INSERT INTO ce_config (config_type, config_key, config_value, enabled) VALUES ('IntentResolutionStep', 'STICKY_INTENT', 'true', true); } </CodeBlockToggle> Force re-resolution signals: - reset commands: reset , restart , /reset , /restart - switch phrases: switch to ... , switch intent , change intent/flow/mode - input params: force_intent_resolution=true , resolve_intent=true , switch_intent=true , switch_flow=true , switch_mode=true - active clarification flow ## Reset triggers - request body reset=true - input params reset , restart , conversation_reset - text commands reset , restart , /reset , /restart - intent-based reset via ResetResolvedIntentStep ( ce_config ) <CodeBlockToggle title=\"Reset intent config\" language=\"sql\"> { INSERT INTO ce_config (config_type, config_key, config_value, enabled) VALUES ('ResetResolvedIntentStep', 'RESET_INTENT_CODES', 'RESET_SESSION,START_OVER', true); } </CodeBlockToggle> ## Practical advice - Keep reset intent names explicit and reserved ( RESET_SESSION style) - Avoid mixing business intents with reset intents - Audit CONVERSATION_RESET stages in pre-production tests <Highlight type=\"warning\" title=\"Common failure mode\"> If reset logic is custom-coded only in controller, multi-turn state may still leak from existing conversation context. Use pipeline reset steps, not ad-hoc request branching. </Highlight>",
    "excerpt": "Session, Reset, and Continuity What is restored per turn From ce_conversation , session restores: intent_code state_code context_json input_params_json From context branch values, session also restores cross turn values …"
  },
  {
    "id": "consumer/ui-integration.mdx",
    "version": "v2",
    "title": "ui integration",
    "permalink": "/docs/v2/consumer/ui-integration",
    "content": "UI Integration This page shows end to end UI wiring with: React (Vite) in JS + TS Angular (standalone) in TS SSE now + STOMP commented for later switch POST to /api/v1/conversation/message using conversationId and message . Use EventSource on /api/v1/conversation/stream/ '} . On each stream event, refresh /audit/ '} or trace endpoint. React Vite (JavaScript) , body: JSON.stringify( ), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const res = await fetch(API_BASE + \"/audit/\" + conversationId); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () = handlers.onConnected?.(); source.onerror = (error) = handlers.onError?.(error); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) = catch handlers.onEvent?.( ); }); }); return }; } // STOMP scaffold (optional) // npm install @stomp/stompjs sockjs client // import from \"@stomp/stompjs\"; // import SockJS from \"sockjs client\"; // export function subscribeConversationStomp(conversationId, handlers = ) // catch // }); // }, // onStompError: (frame) = handlers.onError?.(frame), // }); // client.activate(); // return }; // } } from \"react\"; const [conversationId] = useState(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState(0); useEffect(() = ); // STOMP alternate: // const stream = subscribeConversationStomp(conversationId, ); return () = stream.close(); }, [conversationId]); return conversationId= auditVersion= ; } } React Vite (TypeScript) onConnected?: () = void; onEvent?: (event: StreamEvent ) = void; onError?: (event: Event) = void; onClosed?: () = void; } conversationId: string, message: string, inputParams: Record = , reset = false ) , body: JSON.stringify( ), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } conversationId: string, handlers: StreamHandlers = ) catch handlers.onEvent?.( ); }); }); return }; } } from \"react\"; const [conversationId] = useState (crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState (0); useEffect(() = , }); return () = stream.close(); }, [conversationId]); return auditVersion= ; } } Angular Integration (authored sample) from '@angular/core'; stage: string; data: T | null; raw: MessageEvent; } @Injectable( ) private readonly apiBase = 'http://localhost:8080/api/v1/conversation'; constructor(private readonly http: HttpClient) sendMessage(payload: ): Observable fetchAudits(conversationId: string): Observable subscribeConversationSse( conversationId: string, handlers: = ) catch handlers.onEvent?.( ); }); }); return }; } // STOMP scaffold (optional) // npm i @stomp/stompjs sockjs client // connect ws://localhost:8080/ws convengine // subscribe /topic/convengine/audit/ } } from '@angular/core'; @Component( ) conversationId = crypto.randomUUID(); message = ''; messages: Array = []; typing = false; private streamCloser: | null = null; constructor(private readonly api: ConvengineApiService) ngOnInit(): void }); } send(): void ); this.message = ''; this.typing = true; this.api.sendMessage( ).subscribe( ); this.typing = false; }, error: () = }); } ngOnDestroy(): void } } } Agent is typing... Send } Keep one shared backend contract for conversationId , payload.type , and audit stage names. Only transport/client wrappers should differ per framework.",
    "rawContent": "# UI Integration This page shows end-to-end UI wiring with: - React (Vite) in JS + TS - Angular (standalone) in TS - SSE now + STOMP commented for later switch <FlowStep step=\"1\" title=\"Call message API\"> POST to <FileRef>/api/v1/conversation/message</FileRef> using <MethodRef>conversationId</MethodRef> and <MethodRef>message</MethodRef>. </FlowStep> <FlowStep step=\"2\" title=\"Subscribe to stream\"> Use <MethodRef>EventSource</MethodRef> on <FileRef>/api/v1/conversation/stream/{'{conversationId}'}</FileRef>. </FlowStep> <FlowStep step=\"3\" title=\"Refresh timeline\"> On each stream event, refresh <FileRef>/audit/{'{conversationId}'}</FileRef> or trace endpoint. </FlowStep> ## React Vite (JavaScript) <CodeBlockToggle title=\"convengine.api.js\" language=\"js\" packagePath=\"src/api\" filePath=\"src/api/convengine.api.js\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; const res = await fetch(API_BASE + \"/message\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ conversationId, message, reset, inputParams }), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const res = await fetch(API_BASE + \"/audit/\" + conversationId); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (error) => handlers.onError?.(error); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data = null; try { data = event.data ? JSON.parse(event.data) : null; } catch {} handlers.onEvent?.({ stage, data, raw: event }); }); }); return { close() { source.close(); handlers.onClosed?.(); } }; } // STOMP scaffold (optional) // npm install @stomp/stompjs sockjs-client // import { Client } from \"@stomp/stompjs\"; // import SockJS from \"sockjs-client\"; // export function subscribeConversationStomp(conversationId, handlers = {}) { // const client = new Client({ // webSocketFactory: () => new SockJS(\"http://localhost:8080/ws-convengine\"), // reconnectDelay: 5000, // onConnect: () => { // handlers.onConnected?.(); // client.subscribe(\"/topic/convengine/audit/\" + conversationId, (msg) => { // try { handlers.onEvent?.(JSON.parse(msg.body)); } // catch { handlers.onEvent?.(msg.body); } // }); // }, // onStompError: (frame) => handlers.onError?.(frame), // }); // client.activate(); // return { close() { client.deactivate(); handlers.onClosed?.(); } }; // } } </CodeBlockToggle> <CodeBlockToggle title=\"App.jsx\" language=\"jsx\" packagePath=\"src\" filePath=\"src/App.jsx\" > { import { useEffect, useState } from \"react\"; const [conversationId] = useState(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState(0); useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion((v) => v + 1), onEvent: () => setAuditVersion((v) => v + 1), }); // STOMP alternate: // const stream = subscribeConversationStomp(conversationId, { ... }); return () => stream.close(); }, [conversationId]); return <div>conversationId={conversationId} auditVersion={auditVersion}</div>; } } </CodeBlockToggle> ## React Vite (TypeScript) <CodeBlockToggle title=\"convengine.api.ts\" language=\"ts\" packagePath=\"src/api\" filePath=\"src/api/convengine.api.ts\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; | \"CONNECTED\" | \"USER_INPUT\" | \"STEP_ENTER\" | \"STEP_EXIT\" | \"STEP_ERROR\" | \"ASSISTANT_OUTPUT\" | \"ENGINE_RETURN\" | \"MESSAGE\"; stage: SseStage; data: T | null; raw: MessageEvent; } onConnected?: () => void; onEvent?: (event: StreamEvent<T>) => void; onError?: (event: Event) => void; onClosed?: () => void; } conversationId: string, message: string, inputParams: Record<string, unknown> = {}, reset = false ) { const res = await fetch(API_BASE + \"/message\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ conversationId, message, inputParams, reset }), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } conversationId: string, handlers: StreamHandlers<T> = {} ) { const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (event) => handlers.onError?.(event); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data: T | null = null; try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) as T : null; } catch { data = null; } handlers.onEvent?.({ stage: stage as SseStage, data, raw: event as MessageEvent }); }); }); return { close() { source.close(); handlers.onClosed?.(); } }; } } </CodeBlockToggle> <CodeBlockToggle title=\"App.tsx\" language=\"tsx\" packagePath=\"src\" filePath=\"src/App.tsx\" > { import { useEffect, useState } from \"react\"; const [conversationId] = useState<string>(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState<number>(0); useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion((v) => v + 1), onEvent: () => setAuditVersion((v) => v + 1), onError: () => {}, }); return () => stream.close(); }, [conversationId]); return <main>auditVersion={auditVersion}</main>; } } </CodeBlockToggle> ## Angular Integration (authored sample) <CodeBlockToggle title=\"convengine-api.service.ts\" language=\"ts\" packagePath=\"src/app/core\" filePath=\"src/app/core/convengine-api.service.ts\" > { import { Injectable } from '@angular/core'; stage: string; data: T | null; raw: MessageEvent; } @Injectable({ providedIn: 'root' }) private readonly apiBase = 'http://localhost:8080/api/v1/conversation'; constructor(private readonly http: HttpClient) {} sendMessage(payload: { conversationId: string; message: string; reset?: boolean; inputParams?: Record<string, unknown>; }): Observable<any> { return this.http.post(this.apiBase + '/message', payload); } fetchAudits(conversationId: string): Observable<any[]> { return this.http.get<any[]>(this.apiBase + '/audit/' + conversationId); } subscribeConversationSse( conversationId: string, handlers: { onConnected?: () => void; onEvent?: (event: ConversationEvent) => void; onError?: (event: Event) => void; onClosed?: () => void; } = {} ) { const source = new EventSource(this.apiBase + '/stream/' + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (event) => handlers.onError?.(event); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data: unknown = null; try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) : null; } catch { data = null; } handlers.onEvent?.({ stage, data, raw: event as MessageEvent }); }); }); return { close: () => { source.close(); handlers.onClosed?.(); } }; } // STOMP scaffold (optional) // npm i @stomp/stompjs sockjs-client // connect ws://localhost:8080/ws-convengine // subscribe /topic/convengine/audit/{conversationId} } } </CodeBlockToggle> <CodeBlockToggle title=\"chat.component.ts\" language=\"ts\" packagePath=\"src/app/features/chat\" filePath=\"src/app/features/chat/chat.component.ts\" > { import { Component, OnDestroy, OnInit } from '@angular/core'; @Component({ standalone: true, selector: 'app-chat', imports: [CommonModule, FormsModule], templateUrl: './chat.component.html' }) conversationId = crypto.randomUUID(); message = ''; messages: Array<{ role: 'user' | 'assistant'; text: string }> = []; typing = false; private streamCloser: { close: () => void } | null = null; constructor(private readonly api: ConvengineApiService) {} ngOnInit(): void { this.streamCloser = this.api.subscribeConversationSse(this.conversationId, { onEvent: () => { // optionally refresh audit panel } }); } send(): void { const text = this.message.trim(); if (!text || this.typing) return; this.messages.push({ role: 'user', text }); this.message = ''; this.typing = true; this.api.sendMessage({ conversationId: this.conversationId, message: text }).subscribe({ next: (res) => { const value = res?.payload?.value ?? ''; this.messages.push({ role: 'assistant', text: String(value) }); this.typing = false; }, error: () => { this.typing = false; } }); } ngOnDestroy(): void { this.streamCloser?.close(); } } } </CodeBlockToggle> <CodeBlockToggle title=\"chat.component.html\" language=\"html\" packagePath=\"src/app/features/chat\" filePath=\"src/app/features/chat/chat.component.html\" > { <section class=\"chat-shell\"> <div class=\"messages\"> <div *ngFor=\"let m of messages\" [class.user]=\"m.role === 'user'\" [class.assistant]=\"m.role === 'assistant'\"> {{ m.text }} </div> <div *ngIf=\"typing\" class=\"assistant typing\">Agent is typing...</div> </div> <div class=\"composer\"> <input [(ngModel)]=\"message\" placeholder=\"Type message\" /> <button (click)=\"send()\" [disabled]=\"typing\">Send</button> </div> </section> } </CodeBlockToggle> <Highlight type=\"tip\" title=\"React + Angular parity\"> Keep one shared backend contract for <MethodRef>conversationId</MethodRef>, <MethodRef>payload.type</MethodRef>, and audit stage names. Only transport/client wrappers should differ per framework. </Highlight>",
    "excerpt": "UI Integration This page shows end to end UI wiring with: React (Vite) in JS + TS Angular (standalone) in TS SSE now + STOMP commented for later switch POST to /api/v1/conversation/message using conversationId and messag…"
  },
  {
    "id": "deep-dive/data-model.mdx",
    "version": "v2",
    "title": "data model",
    "permalink": "/docs/v2/deep-dive/data-model",
    "content": "Data Model ConvEngine relies entirely on configuration over code. State, relationships, and execution boundaries are encoded in the schema. Control plane tables ce_config ce_container_config ce_intent ce_intent_classifier ce_output_schema ce_prompt_template ce_response ce_rule ce_policy ce_mcp_tool ce_mcp_db_tool ce_mcp_planner ce_pending_action ce_verbose Runtime tables ce_conversation ce_audit ce_conversation_history ce_llm_call_log ce_conversation_history Introduced to store chronological multi turn array states strictly decoupled from internal ce_audit tracking. Key columns: history_id conversation_id user_input assistant_output created_at modified_at ce_pending_action Introduced for confirm before run logic and unambiguous multi action resolution. Purpose: declarative catalog for executable pending actions by intent/state/action key Key columns: pending_action_id intent_code state_code action_key bean_name method_names priority enabled description created_at Lookup index: (enabled, action_key, intent_code, state_code, priority) Important: runtime status ( OPEN/IN_PROGRESS/EXECUTED/REJECTED/EXPIRED ) is not stored in this table runtime status is stored in context.pending_action_runtime ce_verbose Introduced in 2.0.8 for deterministic runtime progress/error messages emitted by the Java pipeline. In 2.0.9 , the same resolver path can also be triggered from consumer code through ConvEngineVerboseAdapter . Purpose: declarative message mapping by runtime context (intent/state/step/determinant/rule/tool) Key columns: verbose_id intent_code state_code step_match ( EXACT|REGEX|JSON_PATH ) step_value determinant rule_id (optional) tool_code (optional) message error_message priority enabled created_at Lookup index: (enabled, intent_code, state_code, determinant, step_match, step_value, rule_id, tool_code, priority) ce_prompt_template ce_prompt_template is used for both schema extraction prompts and derived response generation. Key columns: template_id intent_code state_code response_type system_prompt user_prompt temperature interaction_mode interaction_contract enabled created_at Runtime notes: prompts are rendered through the shared ThymeleafTemplateRenderer legacy } placeholders still work, but Thymeleaf expressions are the native path common runtime vars include user_input , resolved_user_input , standalone_query , intent , state , context , and inputParams see for expression examples across prompts and ce_verbose interaction_mode is the coarse semantic contract for the turn. Supported values: NORMAL IDLE COLLECT CONFIRM PROCESSING FINAL ERROR DISAMBIGUATE FOLLOW_UP PENDING_ACTION REVIEW interaction_contract is extensible JSON text for concrete capabilities and expectations. Recommended shape: json Current conventions: allows : turn capabilities such as affirm , edit , retry , reset expects : input expectations such as structured_input Design note: prefer extending interaction_contract arrays for new capabilities instead of adding new columns use interaction_mode for broad semantics and interaction_contract for fine grained runtime behavior Rule phase compatibility ce_rule.phase includes phases: POST_DIALOGUE_ACT PRE_RESPONSE_RESOLUTION POST_AGENT_INTENT POST_SCHEMA_EXTRACTION PRE_AGENT_MCP POST_AGENT_MCP POST_TOOL_EXECUTION Rule action compatibility ce_rule.action includes: SET_INTENT SET_STATE SET_DIALOGUE_ACT SET_JSON GET_CONTEXT GET_SCHEMA_JSON GET_SESSION SET_TASK SET_INPUT_PARAM SET_INPUT_PARAM is the lightweight runtime flag action. Use it for values like: awaiting_confirmation=true confirmation_key=LOAN_APPLICATION_CONFIRM skip_schema_extraction=true routing_decision=PROCEED_CONFIRMED SET_DIALOGUE_ACT is the lightweight post classification override action. Use it when a POST_DIALOGUE_ACT rule should replace the final dialogue_act with a more appropriate normalized value (for example promoting a guarded NEW_REQUEST back to EDIT ). Tool group compatibility ce_mcp_tool.tool_group normalizes to: DB HTTP_API WORKFLOW_ACTION DOCUMENT_RETRIEVAL CALCULATOR_TRANSFORM NOTIFICATION FILES MCP tool scope columns ce_mcp_tool also supports optional scope columns: intent_code (nullable) state_code (nullable) Behavior: if both are NULL , the tool is globally eligible if set, tool eligibility is constrained to matching runtime session.intent and session.state non matching scoped tools are skipped from MCP planning/execution MCP planner scope columns ce_mcp_planner supports scoped planner prompts: intent_code (nullable) state_code (nullable) system_prompt user_prompt enabled Behavior: exact intent/state row wins intent only row is next global default row ( NULL/NULL ) is fallback if not found, planner uses legacy ce_config prompts",
    "rawContent": "# Data Model ConvEngine relies entirely on configuration over code. State, relationships, and execution boundaries are encoded in the schema. ## Control-plane tables - ce_config - ce_container_config - ce_intent - ce_intent_classifier - ce_output_schema - ce_prompt_template - ce_response - ce_rule - ce_policy - ce_mcp_tool - ce_mcp_db_tool - ce_mcp_planner - ce_pending_action - ce_verbose ## Runtime tables - ce_conversation - ce_audit - ce_conversation_history - ce_llm_call_log ## ce_conversation_history Introduced to store chronological multi-turn array states strictly decoupled from internal ce_audit tracking. Key columns: - history_id - conversation_id - user_input - assistant_output - created_at - modified_at ## ce_pending_action Introduced for confirm-before-run logic and unambiguous multi-action resolution. Purpose: - declarative catalog for executable pending actions by intent/state/action key Key columns: - pending_action_id - intent_code - state_code - action_key - bean_name - method_names - priority - enabled - description - created_at Lookup index: - (enabled, action_key, intent_code, state_code, priority) Important: - runtime status ( OPEN/IN_PROGRESS/EXECUTED/REJECTED/EXPIRED ) is not stored in this table - runtime status is stored in context.pending_action_runtime ## ce_verbose Introduced in 2.0.8 for deterministic runtime progress/error messages emitted by the Java pipeline. In 2.0.9 , the same resolver path can also be triggered from consumer code through ConvEngineVerboseAdapter . Purpose: - declarative message mapping by runtime context (intent/state/step/determinant/rule/tool) Key columns: - verbose_id - intent_code - state_code - step_match ( EXACT|REGEX|JSON_PATH ) - step_value - determinant - rule_id (optional) - tool_code (optional) - message - error_message - priority - enabled - created_at Lookup index: - (enabled, intent_code, state_code, determinant, step_match, step_value, rule_id, tool_code, priority) ## ce_prompt_template ce_prompt_template is used for both schema extraction prompts and derived response generation. Key columns: - template_id - intent_code - state_code - response_type - system_prompt - user_prompt - temperature - interaction_mode - interaction_contract - enabled - created_at Runtime notes: - prompts are rendered through the shared ThymeleafTemplateRenderer - legacy {{...}} placeholders still work, but Thymeleaf expressions are the native path - common runtime vars include user_input , resolved_user_input , standalone_query , intent , state , context , and inputParams - see [Thymeleaf and SpEL](/docs/v2/deep-dive/thymeleaf-spel) for expression examples across prompts and ce_verbose interaction_mode is the coarse semantic contract for the turn. Supported values: - NORMAL - IDLE - COLLECT - CONFIRM - PROCESSING - FINAL - ERROR - DISAMBIGUATE - FOLLOW_UP - PENDING_ACTION - REVIEW interaction_contract is extensible JSON text for concrete capabilities and expectations. Recommended shape: json {\"allows\":[\"affirm\",\"edit\",\"retry\",\"reset\"],\"expects\":[\"structured_input\"]} Current conventions: - allows : turn capabilities such as affirm , edit , retry , reset - expects : input expectations such as structured_input Design note: - prefer extending interaction_contract arrays for new capabilities instead of adding new columns - use interaction_mode for broad semantics and interaction_contract for fine-grained runtime behavior ## Rule phase compatibility ce_rule.phase includes phases: - POST_DIALOGUE_ACT - PRE_RESPONSE_RESOLUTION - POST_AGENT_INTENT - POST_SCHEMA_EXTRACTION - PRE_AGENT_MCP - POST_AGENT_MCP - POST_TOOL_EXECUTION ## Rule action compatibility ce_rule.action includes: - SET_INTENT - SET_STATE - SET_DIALOGUE_ACT - SET_JSON - GET_CONTEXT - GET_SCHEMA_JSON - GET_SESSION - SET_TASK - SET_INPUT_PARAM SET_INPUT_PARAM is the lightweight runtime-flag action. Use it for values like: - awaiting_confirmation=true - confirmation_key=LOAN_APPLICATION_CONFIRM - skip_schema_extraction=true - routing_decision=PROCEED_CONFIRMED SET_DIALOGUE_ACT is the lightweight post-classification override action. Use it when a POST_DIALOGUE_ACT rule should replace the final dialogue_act with a more appropriate normalized value (for example promoting a guarded NEW_REQUEST back to EDIT ). ## Tool-group compatibility ce_mcp_tool.tool_group normalizes to: - DB - HTTP_API - WORKFLOW_ACTION - DOCUMENT_RETRIEVAL - CALCULATOR_TRANSFORM - NOTIFICATION - FILES ## MCP tool scope columns ce_mcp_tool also supports optional scope columns: - intent_code (nullable) - state_code (nullable) Behavior: - if both are NULL , the tool is globally eligible - if set, tool eligibility is constrained to matching runtime session.intent and session.state - non-matching scoped tools are skipped from MCP planning/execution ## MCP planner scope columns ce_mcp_planner supports scoped planner prompts: - intent_code (nullable) - state_code (nullable) - system_prompt - user_prompt - enabled Behavior: - exact intent/state row wins - intent-only row is next - global default row ( NULL/NULL ) is fallback - if not found, planner uses legacy ce_config prompts",
    "excerpt": "Data Model ConvEngine relies entirely on configuration over code. State, relationships, and execution boundaries are encoded in the schema. Control plane tables ce_config ce_container_config ce_intent ce_intent_classifie…"
  },
  {
    "id": "deep-dive/developer-guide.mdx",
    "version": "v2",
    "title": "developer guide",
    "permalink": "/docs/v2/deep-dive/developer-guide",
    "content": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , ]; v2x1: , v2x2: , v2x3: , v2x4: , v2x5: , v2x6: , v2x7: , v2x8: , }; Developer Guide This page is the full implementation starter for consumers building flows on top of ConvEngine. Build order for a new flow 1. Define intent/state and response rows in ce_intent and ce_response . 2. Define schema row (if slot collection needed). 3. Define rule transitions by phase ( ce_rule ). 4. Define pending actions in ce_pending_action for explicit AFFIRM/NEGATE confirmation flows. 5. Configure convengine.flow. namespaces (e.g. state graph restrictions, disambiguation limits). 6. Add tool rows and adapters to the orchestration library if external execution is needed via McpToolExecutor . 7. Replay test with expected intent/state/dialogue act assertions. Review: convengine.flow. features Use your application.yml to tune the pipeline without writing Java extension components. Extension points } } return ToolExecutionResult.skipped(); } } } } } Operational safety checklist Configure Fallbacks : Configure fallback response rows for UNKNOWN / ANY . Phase Targeting : Do not depend on one rule only; split constraints across the actual runtime phases ( POST_AGENT_INTENT , POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP , POST_AGENT_MCP , POST_TOOL_EXECUTION , PRE_RESPONSE_RESOLUTION ) so each transition happens at the correct boundary. Priority Bounds : Verify pending action catalog priorities to avoid ambiguous execution hooks during interaction policy overlaps. Guardrails : Monitor the ce_audit log for GUARDRAIL_VIOLATION to track potential malicious end user prompt injection. Strict Bounds : Enable state graph validation before promoting a new flow to production. Regression strategy Use ConversationReplayService to replay scripted turns and assert the expected variables at each turn. }",
    "rawContent": "{ id: \"v2x1\", position: { x: 20, y: 60 }, data: { label: \"DialogueActStep\" } }, { id: \"v2x2\", position: { x: 260, y: 60 }, data: { label: \"InteractionPolicyStep\" } }, { id: \"v2x3\", position: { x: 500, y: 60 }, data: { label: \"PendingActionStep\" } }, { id: \"v2x4\", position: { x: 740, y: 60 }, data: { label: \"ToolOrchestrationStep\" } }, { id: \"v2x5\", position: { x: 20, y: 230 }, data: { label: \"GuardrailStep\" } }, { id: \"v2x6\", position: { x: 260, y: 230 }, data: { label: \"StateGraphStep\" } }, { id: \"v2x7\", position: { x: 500, y: 230 }, data: { label: \"DisambiguationStep\" } }, { id: \"v2x8\", position: { x: 740, y: 230 }, data: { label: \"CeTaskExecutor\" } }, ]; { id: \"v2xe1\", source: \"v2x1\", target: \"v2x2\" }, { id: \"v2xe2\", source: \"v2x2\", target: \"v2x3\" }, { id: \"v2xe3\", source: \"v2x3\", target: \"v2x4\" }, { id: \"v2xe4\", source: \"v2x4\", target: \"v2x5\" }, { id: \"v2xe5\", source: \"v2x5\", target: \"v2x6\" }, { id: \"v2xe6\", source: \"v2x6\", target: \"v2x7\" }, { id: \"v2xe7\", source: \"v2x7\", target: \"v2x8\" }, ]; v2x1: { title: \"Dialogue Act\", file: \"engine/steps/DialogueActStep.java\", method: \"execute(...) \", stage: \"DIALOGUE_ACT_RESOLVED\", summary: \"Resolves abstract acts like AFFIRM, NEGATE, EDIT.\", session: [\"dialogueAct attached to session\"], tables: [\"none\"] }, v2x2: { title: \"Policy Engine\", file: \"engine/steps/InteractionPolicyStep.java\", method: \"execute(...) \", stage: \"POLICY_APPLIED\", summary: \"Maps dialogue acts to system functions using interaction matrix.\", session: [\"systemAction triggered (e.g. EXECUTE_PENDING_ACTION)\"], tables: [\"none\"] }, v2x3: { title: \"Pending Actions\", file: \"engine/steps/PendingActionStep.java\", method: \"execute(...) \", stage: \"ACTION_LIFECYCLE\", summary: \"Runs deferred confirmation tasks via CeTaskExecutor.\", session: [\"task result stored\"], tables: [\"ce_pending_action\"] }, v2x4: { title: \"Tool Runner\", file: \"engine/steps/ToolOrchestrationStep.java\", method: \"execute(...) \", stage: \"TOOL_EXECUTED\", summary: \"Calls external downstream logic.\", session: [\"tool_status and result merged\"], tables: [\"ce_mcp_tool, ce_mcp_db_tool\"] }, v2x5: { title: \"Guardrails\", file: \"engine/steps/GuardrailStep.java\", method: \"execute(...) \", stage: \"GUARDRAIL_VIOLATION\", summary: \"Proactively redacts or fails-closed unsafe user text.\", session: [\"redacted input / pipeline stop\"], tables: [\"none\"] }, v2x6: { title: \"State Graph\", file: \"engine/steps/StateGraphStep.java\", method: \"execute(...) \", stage: \"INVALID_STATE_TRANSITION\", summary: \"Enforces statically bounded turn transitions.\", session: [\"state transition audited\"], tables: [\"none\"] }, v2x7: { title: \"Disambiguation\", file: \"engine/steps/DisambiguationStep.java\", method: \"execute(...) \", stage: \"CLARIFICATION_REQUIRED\", summary: \"Detects intent collisions and asks user to choose.\", session: [\"clarification list prepped\"], tables: [\"none\"] }, v2x8: { title: \"Task Extension\", file: \"api/tasks/CeTaskExecutor.java\", method: \"executeTask(...) \", stage: \"TASK_RUNNING\", summary: \"Consumer-injected Java component logic.\", session: [\"consumer mutates map state\"], tables: [\"none\"] }, }; # Developer Guide This page is the full implementation starter for consumers building flows on top of ConvEngine. <EngineDebugFlow title=\"Pipeline Extension Map\" subtitle=\"Click each node to inspect the components.\" nodes={v2ExtNodes} edges={v2ExtEdges} detailsById={v2ExtDetails} defaultSelectedId=\"v2x2\" /> ## Build order for a new flow 1. Define intent/state and response rows in ce_intent and ce_response . 2. Define schema row (if slot collection needed). 3. Define rule transitions by phase ( ce_rule ). 4. Define pending actions in ce_pending_action for explicit AFFIRM/NEGATE confirmation flows. 5. Configure convengine.flow.* namespaces (e.g. state graph restrictions, disambiguation limits). 6. Add tool rows and adapters to the orchestration library if external execution is needed via McpToolExecutor . 7. Replay test with expected intent/state/dialogue-act assertions. ## Review: convengine.flow.* features Use your application.yml to tune the pipeline without writing Java extension components. <DbTable title=\"Flow Features\" columns={[\"Subsystem\", \"Purpose\", \"Example Property\"]} rows={[ [\"dialogue-act.*\", \"Detect foundational speech acts (AFFIRM, NEGATE) instead of strict intents.\", \"resolute: REGEX_THEN_LLM\"], [\"query-rewrite.*\", \"Automatically rewrite user input before intent resolution.\", \"enabled: true\"], [\"conversation-history.*\", \"Manage conversation history size and summarization.\", \"max-turns: 10\"], [\"interaction-policy.*\", \"Map dialogue acts to system actions like EXECUTE_PENDING_ACTION.\", \"execute-pending-on-affirm: true\"], [\"action-lifecycle.*\", \"Automatically expire pending actions after N turns.\", \"ttl-turns: 3\"], [\"disambiguation.*\", \"Configure thresholds for triggering user clarifications.\", \"max-options: 5\"], [\"guardrail.*\", \"Set up proactive redaction and fail-closed policies.\", \"approval-gate-fail-closed: true\"], [\"state-graph.*\", \"Enforce strict state transition rules for better predictability.\", \"soft-block-on-violation: false\"] ]} /> ## Extension points <Tabs groupId=\"extensions\"> <TabItem value=\"tasks\" label=\"CeTask\" default> <CodeBlockToggle title=\"Creating a Pending Action Task\" language=\"java\" packagePath=\"com.zapper.convengine.tasks\"> { @Component(\"shippingConfirmationTask\") public class ShippingConfirmationTask implements CeTask { @Override public TaskResult execute(EngineSession session, CePendingAction action) { String trackingId = (String) session.getInputParams().get(\"trackingId\"); // Call downstream API session.putInputParam(\"shippingStatus\", \"DISPATCHED\"); return TaskResult.success(); } } } </CodeBlockToggle> </TabItem> <TabItem value=\"tools\" label=\"McpToolExecutor\"> <CodeBlockToggle title=\"Tool execution adapter\" language=\"java\" packagePath=\"com.zapper.convengine.tools\"> { @Component(\"billingToolAdapter\") public class BillingToolAdapter implements McpToolExecutor { @Override public ToolExecutionResult invoke(ToolRequest request, EngineSession session) { if (request.getToolGroup().equals(\"BILLING\")) { return ToolExecutionResult.success(Map.of(\"balance\", 0.00)); } return ToolExecutionResult.skipped(); } } } </CodeBlockToggle> </TabItem> <TabItem value=\"memory\" label=\"Memory Store\"> <CodeBlockToggle title=\"Custom Session Snapshotting\" language=\"java\" packagePath=\"com.zapper.convengine.stores\"> { @Component public class CustomMemoryStore implements ConversationMemoryStore { @Override public String summarize(List<TurnSnapshot> turns) { // Use LLM to compress 20 turns into a 100 character context injection return llmClient.summarizeWithLimits(turns, 100); } } } </CodeBlockToggle> </TabItem> </Tabs> ## Operational safety checklist - **Configure Fallbacks**: Configure fallback response rows for UNKNOWN / ANY . - **Phase Targeting**: Do not depend on one rule only; split constraints across the actual runtime phases ( POST_AGENT_INTENT , POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP , POST_AGENT_MCP , POST_TOOL_EXECUTION , PRE_RESPONSE_RESOLUTION ) so each transition happens at the correct boundary. - **Priority Bounds**: Verify pending-action catalog priorities to avoid ambiguous execution hooks during interaction policy overlaps. - **Guardrails**: Monitor the ce_audit log for GUARDRAIL_VIOLATION to track potential malicious end-user prompt injection. - **Strict Bounds**: Enable state-graph validation before promoting a new flow to production. ## Regression strategy Use ConversationReplayService to replay scripted turns and assert the expected variables at each turn. <CodeBlockToggle title=\"ConversationReplayService assertion\" language=\"java\" filePath=\"src/test/java/com/zapper/RegressionTests.java\"> { @Test public void testShippingFlow() { ReplayResult finalTurn = replayService.runScript(\"shipping_confirmation_script.json\"); assertEquals(\"SHIPPING_CONFIRMED\", finalTurn.getFinalIntent()); assertEquals(\"EXECUTE_PENDING_ACTION\", finalTurn.getAuditStages().getLastSystemAction()); } } </CodeBlockToggle>",
    "excerpt": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , ]; v2x1: , v2x2: , v2x3: , v2x4: , v2x5: , v2x6: , v2x7: , v2x8: , }; Developer Guide This page is the full impleme…"
  },
  {
    "id": "deep-dive/examples.mdx",
    "version": "v2",
    "title": "examples",
    "permalink": "/docs/v2/deep-dive/examples",
    "content": "Real World Examples This page is intentionally dense. Each flow is shown as: 1. Chat transcript 2. Per turn step trace (what executed and why) 3. Required control plane rows ( ce_ ) 4. Audit timeline with payload level checkpoints Example 1: FAQ (informational path) How do I transfer my electricity connection? Share customerId, phone, email, source city, and target city. Then confirm to submit transfer. InteractionPolicyStep sees no pending_action signal and does not produce EXECUTE_PENDING_ACTION . The turn continues as a regular intent resolution flow. }\\\\nFAQ context: }\\\\nReturn short helpful answer.', 0.10, true); INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'DERIVED', 'Answer FAQ using available context and user question.', 10, true); } , \"userText\": \"How do I transfer my electricity connection?\", \"dialogueAct\": \"QUESTION\", \"dialogueActConfidence\": 0.70, \"dialogueActSource\": \"REGEX\" } } , \"dialogueAct\": \"QUESTION\", \"policyDecision\": \"RECLASSIFY_INTENT\", \"skipIntentResolution\": false, \"hasPendingAction\": false, \"hasPendingSlot\": false } } Example 2: CONNECTION_TRANSFER (multi turn + confirmation + pending action) Move my electricity connection from City1 to City2. Please provide customerId, phone, email, sourceCity, and targetCity. customerId 9912, phone 9988776655, email user@zapper.com, sourceCity City1, targetCity City2 Do you want to move this connection right away? yes please Connection transfer request submitted successfully. COLLECT_INPUTS\", \"Bootstrap collection state\"], [\"ResponseResolutionStep\", \"ask for required fields\", \"Prompt user for missing slots\"], ]} / AWAITING_CONFIRMATION\", \"User must confirm execution\"], [\"ResponseResolutionStep\", \"confirmation prompt\", \"\"], ]} / IN_PROGRESS\", \"Runtime status tracked in context\"], [\"4\", \"DisambiguationStep\", \"not required\", \"Single eligible action\"], [\"5\", \"GuardrailStep\", \"ALLOW\", \"No sensitive/approval block\"], [\"6\", \"PendingActionStep\", \"EXECUTED\", \"Task bean/method invoked from ce_pending_action\"], [\"7\", \"RulesStep\", \"AWAITING_CONFIRMATION COMPLETED\", \"Final state transition\"], [\"8\", \"ResponseResolutionStep\", \"success response\", \"User receives completion\"], ]} / , \"policyDecision\": \"EXECUTE_PENDING_ACTION\", \"pendingActionRef\": \"faqRuleTask:injectContainerData\", \"pendingActionResult\": \"EXECUTED\", \"intent\": \"CONNECTION_TRANSFER\", \"state\": \"AWAITING_CONFIRMATION\" } } , \"rulePhase\": \"PRE_RESPONSE_RESOLUTION\", \"intent\": \"CONNECTION_TRANSFER\", \"ruleStateCode\": \"AWAITING_CONFIRMATION\", \"action\": \"SET_STATE\", \"actionValue\": \"COMPLETED\" } } If user says \"yes\" but flow loops back to confirmation, check in order: 1) DIALOGUE_ACT_CLASSIFIED must be AFFIRM 2) INTERACTION_POLICY_DECIDED must be EXECUTE_PENDING_ACTION 3) PENDING_ACTION_EXECUTED must exist 4) RULE_APPLIED must transition state from AWAITING_CONFIRMATION to terminal state. Example 3: ORDER_CANCELLATION (multi turn with interaction policy) Cancel my shoe order. I can help you cancel your order. What is your order number? It's 48392. Are you sure you want to cancel order 48392? This action is irreversible. Yes please do that. Order 48392 has been completely cancelled. },\"required\":[\"orderNumber\"]}', true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, enabled) VALUES ('CANCEL_ORDER', 'SCHEMA_COLLECTION', 'Extract JSON schema fields.', true); INSERT INTO ce_rule (intent_code, state_code, rule_type, rule_value, action, action_value, phase, priority, enabled) VALUES ('CANCEL_ORDER', 'IDLE', 'JSON_PATH', '$[?(@.context.orderNumber != null && @.context.orderNumber != '''')]', 'SET_STATE', 'CONFIRM_CANCEL', 'PRE_RESPONSE_RESOLUTION', 10, true); INSERT INTO ce_response (intent_code, state_code, response_type, exact_text, enabled) VALUES ('CANCEL_ORDER', 'IDLE', 'EXACT', 'I can help you cancel your order. What is your order number?', true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, user_prompt, template_id, enabled) VALUES ('CANCEL_ORDER', 'DERIVED', 'Format order number cleanly.', 'Are you sure you want to cancel order }? This action is irreversible.', 'tmpl_confirm_cancel', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, enabled) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'DERIVED', 'tmpl_confirm_cancel', true); INSERT INTO ce_pending_action (intent_code, state_code, action_key, bean_name, method_names, priority, enabled, description) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'stripe_cancel', 'stripeCancelTask', 'execute', 10, true, 'Cancel the order in the provider system'); INSERT INTO ce_rule (intent_code, state_code, rule_type, rule_value, action, action_value, phase, priority, enabled) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'EXACT', 'ANY', 'SET_STATE', 'CANCELLED', 'PRE_RESPONSE_RESOLUTION', 20, true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, user_prompt, template_id, enabled) VALUES ('CANCEL_ORDER', 'DERIVED', 'Format cleanly.', 'Order } has been completely cancelled.', 'tmpl_cancelled', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, enabled) VALUES ('CANCEL_ORDER', 'CANCELLED', 'DERIVED', 'tmpl_cancelled', true); } , \"policyDecision\": \"EXECUTE_PENDING_ACTION\", \"pendingActionRef\": \"stripeCancelTask\", \"pendingActionResult\": \"EXECUTED\", \"intent\": \"CANCEL_ORDER\", \"state\": \"CONFIRM_CANCEL\" } } Example 4: INVENTORY_LOOKUP (Tool Orchestration) How many running shoes are left in warehouse B? Checking the inventory database... [System delay executing Tool] We currently have 421 units of running shoes allocated to warehouse B. }', 'tmpl_inventory_gen', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, priority, enabled) VALUES ('DATABASE_QUERY', 'IDLE', 'DERIVED', 'tmpl_inventory_gen', 10, true); } Example 5: SUPPORT_DIAGNOSTIC (Memory Summarization) My router is broken. Let's check the lights. Are they green? [12 more dialogue turns testing different cables and lights] I suggest performing a factory reset via http://router.local/admin_reset with PIN 1234. [User is quiet for minutes] [Turn 15]: Wait, what link did you tell me to use for the firmware reset again? Based on our previous troubleshooting, you should use http://router.local/admin_reset with the default PIN 1234.",
    "rawContent": "# Real World Examples This page is intentionally dense. Each flow is shown as: 1. Chat transcript 2. Per-turn step trace (what executed and why) 3. Required control-plane rows ( ce_* ) 4. Audit timeline with payload-level checkpoints ## Example 1: FAQ (informational path) <Tabs groupId=\"v2-faq-deep\"> <TabItem value=\"chat\" label=\"Chat Transcript\" default> <Conversation title=\"FAQ conversation\"> <User info={[\"Informational FAQ request.\", \"No pending action path required.\"]}>How do I transfer my electricity connection?</User> <Assistant tables={[\"ce_intent\", \"ce_intent_classifier\", \"ce_response\"]} info={[\"Intent=FAQ.\", \"FAQ response returned from configured mapping.\"]}>Share customerId, phone, email, source city, and target city. Then confirm to submit transfer.</Assistant> </Conversation> <DbTable title=\"Intent and state outcome\" columns={[\"Field\", \"Expected value\", \"Why\"]} rows={[ [\"intent\", \"FAQ\", \"Classifier matches informational query language\"], [\"state\", \"IDLE\", \"No slot collection / no pending action required\"], [\"responseType\", \"DERIVED (TEXT)\", \"FAQ answer generated from prompt/context\"], ]} /> </TabItem> <TabItem value=\"trace\" label=\"Per-turn Step Trace\"> <DbTable title=\"Turn T1 runtime trace\" columns={[\"Order\", \"Step\", \"Input facts\", \"Output facts\"]} rows={[ [\"1\", \"LoadOrCreateConversationStep\", \"conversationId present or new\", \"session opened/hydrated\"], [\"1a\", \"CacheInspectAuditStep\", \"cache-inspector enabled\", \"CACHE_INSPECTION audit row (conditional)\"], [\"2\", \"AuditUserInputStep\", \"raw user text\", \"USER_INPUT audit row\"], [\"3\", \"DialogueActStep\", \"question sentence\", \"dialogue_act=QUESTION\"], [\"4\", \"InteractionPolicyStep\", \"no pending_action, no pending_slot\", \"policy_decision=RECLASSIFY_INTENT\"], [\"5\", \"IntentResolutionStep\", \"classifiers + agent hints\", \"intent=FAQ, state=IDLE\"], [\"6\", \"SchemaExtractionStep\", \"FAQ schema (light)\", \"schema facts available\"], [\"7\", \"RulesStep\", \"no FAQ rule action\", \"RULE_NO_MATCH or no mutation\"], [\"8\", \"ResponseResolutionStep\", \"FAQ response row + prompt\", \"assistant output prepared\"], [\"9\", \"MemoryStep\", \"recent turn context\", \"memory_session_summary\"], [\"10\", \"PersistConversationStep\", \"final session\", \"conversation/audit persisted\"], ]} /> <Highlight type=\"info\" title=\"Why no pending-action path here\"> InteractionPolicyStep sees no pending_action signal and does not produce EXECUTE_PENDING_ACTION . The turn continues as a regular intent-resolution flow. </Highlight> </TabItem> <TabItem value=\"db\" label=\"Required ce_* Rows\"> <DbTable title=\"Minimum rows required for FAQ flow\" columns={[\"Table\", \"Required row shape\", \"Used by\"]} rows={[ [\"ce_intent\", \"intent_code=FAQ\", \"IntentResolutionStep\"], [\"ce_intent_classifier\", \"intent_code=FAQ, rule_type=REGEX\", \"IntentResolutionStep\"], [\"ce_prompt_template\", \"intent_code=FAQ, response_type=TEXT\", \"ResponseResolutionStep (DERIVED)\"], [\"ce_response\", \"intent_code=FAQ, state_code=IDLE\", \"ResponseResolutionStep\"], [\"ce_container_config\", \"intent_code=FAQ (optional context source)\", \"AddContainerDataStep\"], [\"ce_config\", \"AgentIntentResolver + SchemaExtractionStep prompt keys\", \"Intent/Schema steps\"], ]} /> <CodeBlockToggle title=\"FAQ seed snippet\" language=\"sql\"> { INSERT INTO ce_intent (intent_code, description, priority, enabled) VALUES ('FAQ', 'Answer informational questions from FAQ knowledge base', 10, true); INSERT INTO ce_intent_classifier (intent_code, rule_type, pattern, priority, enabled) VALUES ('FAQ', 'REGEX', '(?i)\\\\b(what|how|help|faq|information|details|explain)\\\\b', 10, true); INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, temperature, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'You are a concise FAQ assistant. Answer directly and clearly.', 'User question: {{user_input}}\\\\nFAQ context: {{container_data}}\\\\nReturn short helpful answer.', 0.10, true); INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'DERIVED', 'Answer FAQ using available context and user question.', 10, true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit + Payload Postmortem\"> <DbTable title=\"Expected audit stages (ordered)\" columns={[\"Order\", \"Stage\", \"Must contain\"]} rows={[ [\"1\", \"USER_INPUT\", \"original user message\"], [\"2\", \"DIALOGUE_ACT_CLASSIFIED\", \"dialogueAct=QUESTION\"], [\"3\", \"INTERACTION_POLICY_DECIDED\", \"policyDecision=RECLASSIFY_INTENT\"], [\"4\", \"INTENT_RESOLVED_BY_*\", \"intent=FAQ\"], [\"5\", \"RESOLVE_RESPONSE_SELECTED\", \"responseType=DERIVED\"], [\"6\", \"ASSISTANT_OUTPUT\", \"output text or json payload\"], [\"7\", \"MEMORY_UPDATED\", \"summaryChars/recalled flags\"], ]} /> <CodeBlockToggle title=\"Audit payload checkpoint: DIALOGUE_ACT_CLASSIFIED\" language=\"json\"> { { \"_meta\": { \"stage\": \"DIALOGUE_ACT_CLASSIFIED\" }, \"userText\": \"How do I transfer my electricity connection?\", \"dialogueAct\": \"QUESTION\", \"dialogueActConfidence\": 0.70, \"dialogueActSource\": \"REGEX\" } } </CodeBlockToggle> <CodeBlockToggle title=\"Audit payload checkpoint: INTERACTION_POLICY_DECIDED\" language=\"json\"> { { \"_meta\": { \"stage\": \"INTERACTION_POLICY_DECIDED\" }, \"dialogueAct\": \"QUESTION\", \"policyDecision\": \"RECLASSIFY_INTENT\", \"skipIntentResolution\": false, \"hasPendingAction\": false, \"hasPendingSlot\": false } } </CodeBlockToggle> </TabItem> </Tabs> ## Example 2: CONNECTION_TRANSFER (multi-turn + confirmation + pending action) <Tabs groupId=\"v2-transfer-deep\"> <TabItem value=\"chat\" label=\"Chat Transcript\" default> <Conversation title=\"Connection transfer conversation\"> <User info={[\"Initial transfer request.\", \"State expected to move to collection mode.\"]}>Move my electricity connection from City1 to City2.</User> <Assistant tables={[\"ce_output_schema\"]} info={[\"Required fields are missing.\", \"Assistant prompts for slots.\"]}>Please provide customerId, phone, email, sourceCity, and targetCity.</Assistant> <User info={[\"All required fields provided.\", \"Schema should become complete.\"]}>customerId 9912, phone 9988776655, email user@zapper.com, sourceCity City1, targetCity City2</User> <Assistant tables={[\"ce_rule\", \"ce_pending_action\"]} info={[\"Transition to AWAITING_CONFIRMATION.\", \"Pending action staged.\"]}>Do you want to move this connection right away?</Assistant> <User info={[\"AFFIRM dialogue act.\", \"Policy should execute pending action.\"]}>yes please</User> <Assistant tables={[\"ce_audit\", \"ce_response\"]} info={[\"Pending action executed.\", \"Final completion response emitted.\"]}>Connection transfer request submitted successfully.</Assistant> </Conversation> </TabItem> <TabItem value=\"trace\" label=\"Per-turn Step Trace\"> <DbTable title=\"Turn T1 (initial request)\" columns={[\"Step\", \"Key output\", \"Notes\"]} rows={[ [\"IntentResolutionStep\", \"intent=CONNECTION_TRANSFER\", \"Classifier picks transfer intent\"], [\"SchemaExtractionStep\", \"missing fields computed\", \"Required slots are incomplete\"], [\"RulesStep\", \"state -> COLLECT_INPUTS\", \"Bootstrap collection state\"], [\"ResponseResolutionStep\", \"ask for required fields\", \"Prompt user for missing slots\"], ]} /> <DbTable title=\"Turn T2 (slot fill)\" columns={[\"Step\", \"Key output\", \"Notes\"]} rows={[ [\"SchemaExtractionStep\", \"customerId/phone/email/sourceCity/targetCity extracted\", \"Schema complete\"], [\"RulesStep\", \"COLLECT_INPUTS -> AWAITING_CONFIRMATION\", \"User must confirm execution\"], [\"ResponseResolutionStep\", \"confirmation prompt\", \"\"], ]} /> <DbTable title=\"Turn T3 (affirm)\" columns={[\"Order\", \"Step\", \"Key output\", \"Why it matters\"]} rows={[ [\"1\", \"DialogueActStep\", \"AFFIRM\", \"Converts 'yes please' into execution signal\"], [\"2\", \"InteractionPolicyStep\", \"EXECUTE_PENDING_ACTION\", \"Policy routes to pending action\"], [\"3\", \"ActionLifecycleStep\", \"OPEN -> IN_PROGRESS\", \"Runtime status tracked in context\"], [\"4\", \"DisambiguationStep\", \"not required\", \"Single eligible action\"], [\"5\", \"GuardrailStep\", \"ALLOW\", \"No sensitive/approval block\"], [\"6\", \"PendingActionStep\", \"EXECUTED\", \"Task bean/method invoked from ce_pending_action\"], [\"7\", \"RulesStep\", \"AWAITING_CONFIRMATION -> COMPLETED\", \"Final state transition\"], [\"8\", \"ResponseResolutionStep\", \"success response\", \"User receives completion\"], ]} /> </TabItem> <TabItem value=\"db\" label=\"Required ce_* Rows\"> <DbTable title=\"Control-plane requirements\" columns={[\"Table\", \"Must have\", \"Consumed by\"]} rows={[ [\"ce_intent\", \"CONNECTION_TRANSFER\", \"IntentResolutionStep\"], [\"ce_intent_classifier\", \"transfer/move regex\", \"IntentResolutionStep\"], [\"ce_output_schema\", \"required slots for transfer\", \"SchemaExtractionStep\"], [\"ce_rule\", \"state bootstrap + completeness + completion rules\", \"RulesStep\"], [\"ce_pending_action\", \"action_key + bean_name + method_names\", \"ActionLifecycleStep/PendingActionStep\"], [\"ce_response\", \"COLLECT_INPUTS, AWAITING_CONFIRMATION, COMPLETED responses\", \"ResponseResolutionStep\"], [\"ce_config\", \"dialogue/prompt keys\", \"DialogueActStep/Schema steps\"], [\"ce_policy\", \"optional policy blocks\", \"PolicyEnforcementStep\"], ]} /> <CodeBlockToggle title=\"Seed snippet: pending action + rules\" language=\"sql\"> { INSERT INTO ce_pending_action (intent_code, state_code, action_key, bean_name, method_names, priority, enabled, description) VALUES ('CONNECTION_TRANSFER', 'AWAITING_CONFIRMATION', 'FINALIZE_CONNECTION_TRANSFER', 'faqRuleTask', 'injectContainerData', 1, true, 'Demo finalize action for connection transfer'); INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled) VALUES ('PRE_RESPONSE_RESOLUTION', 'CONNECTION_TRANSFER', 'IDLE', 'REGEX', '.*', 'SET_STATE', 'COLLECT_INPUTS', 10, true), ('PRE_RESPONSE_RESOLUTION', 'CONNECTION_TRANSFER', 'COLLECT_INPUTS', 'JSON_PATH', '$[?(@.state == ''COLLECT_INPUTS'' && @.customerId && @.phone && @.email && @.sourceCity && @.targetCity)]', 'SET_STATE', 'AWAITING_CONFIRMATION', 100, true), ('PRE_RESPONSE_RESOLUTION', 'CONNECTION_TRANSFER', 'AWAITING_CONFIRMATION', 'JSON_PATH', '$[?(@.state == ''AWAITING_CONFIRMATION'' && (@.pending_action_result == ''EXECUTED'' || @.inputParams.pending_action_result == ''EXECUTED''))]', 'SET_STATE', 'COMPLETED', 200, true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit + Payload Postmortem\"> <DbTable title=\"Confirmation turn audit chain (must appear in order)\" columns={[\"Order\", \"Stage\", \"Payload keys to verify\"]} rows={[ [\"1\", \"DIALOGUE_ACT_CLASSIFIED\", \"dialogueAct=AFFIRM, confidence, source\"], [\"2\", \"INTERACTION_POLICY_DECIDED\", \"policyDecision=EXECUTE_PENDING_ACTION\"], [\"3\", \"PENDING_ACTION_LIFECYCLE\", \"status=IN_PROGRESS\"], [\"4\", \"GUARDRAIL_ALLOW\", \"result=ALLOW\"], [\"5\", \"PENDING_ACTION_EXECUTED\", \"pendingActionResult=EXECUTED\"], [\"6\", \"RULE_APPLIED\", \"state transition to COMPLETED\"], [\"7\", \"ASSISTANT_OUTPUT\", \"final completion response\"], [\"8\", \"MEMORY_UPDATED\", \"summary updated\"], ]} /> <CodeBlockToggle title=\"Audit payload checkpoint: PENDING_ACTION_EXECUTED\" language=\"json\"> { { \"_meta\": { \"stage\": \"PENDING_ACTION_EXECUTED\" }, \"policyDecision\": \"EXECUTE_PENDING_ACTION\", \"pendingActionRef\": \"faqRuleTask:injectContainerData\", \"pendingActionResult\": \"EXECUTED\", \"intent\": \"CONNECTION_TRANSFER\", \"state\": \"AWAITING_CONFIRMATION\" } } </CodeBlockToggle> <CodeBlockToggle title=\"Audit payload checkpoint: RULE_APPLIED after execution\" language=\"json\"> { { \"_meta\": { \"stage\": \"RULE_APPLIED\" }, \"rulePhase\": \"PRE_RESPONSE_RESOLUTION\", \"intent\": \"CONNECTION_TRANSFER\", \"ruleStateCode\": \"AWAITING_CONFIRMATION\", \"action\": \"SET_STATE\", \"actionValue\": \"COMPLETED\" } } </CodeBlockToggle> <Highlight type=\"success\" title=\"Fast failure triage\"> If user says \"yes\" but flow loops back to confirmation, check in order: 1) DIALOGUE_ACT_CLASSIFIED must be AFFIRM 2) INTERACTION_POLICY_DECIDED must be EXECUTE_PENDING_ACTION 3) PENDING_ACTION_EXECUTED must exist 4) RULE_APPLIED must transition state from AWAITING_CONFIRMATION to terminal state. </Highlight> </TabItem> </Tabs> ## Example 3: ORDER_CANCELLATION (multi-turn with interaction policy) <Tabs groupId=\"v2-cancel-deep\"> <TabItem value=\"chat\" label=\"Chat Transcript\" default> <Conversation title=\"Protected Order Cancellation\"> <User info={[\"Cancellation intent request.\", \"Order number not yet present.\"]}>Cancel my shoe order.</User> <Assistant tables={[\"ce_output_schema\", \"ce_response\"]} info={[\"Missing field follow-up.\", \"Collect orderNumber before confirm step.\"]}>I can help you cancel your order. What is your order number?</Assistant> <User info={[\"Provides required orderNumber.\", \"Unlocks confirmation stage.\"]}>It's 48392.</User> <Assistant tables={[\"ce_rule\", \"ce_pending_action\"]} info={[\"Awaiting explicit confirmation.\", \"Pending action in OPEN/IN_PROGRESS path.\"]}>Are you sure you want to cancel order 48392? This action is irreversible.</Assistant> <User info={[\"AFFIRM turn.\", \"Interaction policy decides EXECUTE_PENDING_ACTION.\"]}>Yes please do that.</User> <Assistant tables={[\"ce_audit\", \"ce_response\"]} info={[\"Action executed and state transitioned.\", \"Cancellation response returned.\"]}>Order 48392 has been completely cancelled.</Assistant> </Conversation> </TabItem> <TabItem value=\"trace\" label=\"Per-turn Step Trace\"> <DbTable title=\"Action Policy Trace\" columns={[\"Turn\", \"Pipeline Step\", \"Internal Engine Action\"]} rows={[ [\"Turn 1\", \"SchemaExtractionStep\", \"Detects CANCEL_ORDER . Fails to extract orderNumber . State remains IDLE .\"], [\"Turn 1\", \"ResponseResolutionStep\", \"Outputs IDLE message asking for order number.\"], [\"Turn 2\", \"SchemaExtractionStep\", \"Engine extracts orderNumber: 48392 . Flags schemaComplete=true .\"], [\"Turn 2\", \"RulesStep\", \"Auto-advance rule fires, transitioning state to CONFIRM_CANCEL .\"], [\"Turn 2\", \"ActionLifecycleStep\", \"Stages stripeCancelTask into pending_action_runtime context with OPEN status.\"], [\"Turn 2\", \"ResponseResolutionStep\", \"Generates derived string parsing the memory context orderNumber .\"], [\"Turn 3\", \"DialogueActStep\", \"User says 'Yes'. Act classifier marks input as AFFIRM .\"], [\"Turn 3\", \"InteractionPolicyStep\", \"Matrix outputs EXECUTE_PENDING_ACTION . Locks classifier logic.\"], [\"Turn 3\", \"GuardrailStep\", \"Checks patterns for malicious prompt. Trace output: GUARDRAIL_ALLOW .\"], [\"Turn 3\", \"PendingActionStep\", \"Execution triggered. External API drops order. Status updated to EXECUTED .\"], [\"Turn 3\", \"RulesStep\", \"Rule sees EXECUTED task status and triggers state transition to CANCELLED .\"], [\"Turn 3\", \"ResponseResolutionStep\", \"Resolves final derived string using historical orderNumber .\"] ]} /> </TabItem> <TabItem value=\"db\" label=\"Required ce_* Rows\"> <CodeBlockToggle title=\"Dynamic Slot & Task DML\" language=\"sql\" defaultOpen={true}> { INSERT INTO ce_intent (intent_code, enabled) VALUES ('CANCEL_ORDER', true); INSERT INTO ce_output_schema (intent_code, format_type, schema_json, enabled) VALUES ('CANCEL_ORDER', 'JSON', '{\"type\":\"object\",\"properties\":{\"orderNumber\":{\"type\":\"string\"}},\"required\":[\"orderNumber\"]}', true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, enabled) VALUES ('CANCEL_ORDER', 'SCHEMA_COLLECTION', 'Extract JSON schema fields.', true); INSERT INTO ce_rule (intent_code, state_code, rule_type, rule_value, action, action_value, phase, priority, enabled) VALUES ('CANCEL_ORDER', 'IDLE', 'JSON_PATH', '$[?(@.context.orderNumber != null && @.context.orderNumber != '''')]', 'SET_STATE', 'CONFIRM_CANCEL', 'PRE_RESPONSE_RESOLUTION', 10, true); INSERT INTO ce_response (intent_code, state_code, response_type, exact_text, enabled) VALUES ('CANCEL_ORDER', 'IDLE', 'EXACT', 'I can help you cancel your order. What is your order number?', true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, user_prompt, template_id, enabled) VALUES ('CANCEL_ORDER', 'DERIVED', 'Format order number cleanly.', 'Are you sure you want to cancel order {{context.orderNumber}}? This action is irreversible.', 'tmpl_confirm_cancel', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, enabled) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'DERIVED', 'tmpl_confirm_cancel', true); INSERT INTO ce_pending_action (intent_code, state_code, action_key, bean_name, method_names, priority, enabled, description) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'stripe_cancel', 'stripeCancelTask', 'execute', 10, true, 'Cancel the order in the provider system'); INSERT INTO ce_rule (intent_code, state_code, rule_type, rule_value, action, action_value, phase, priority, enabled) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'EXACT', 'ANY', 'SET_STATE', 'CANCELLED', 'PRE_RESPONSE_RESOLUTION', 20, true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, user_prompt, template_id, enabled) VALUES ('CANCEL_ORDER', 'DERIVED', 'Format cleanly.', 'Order {{context.orderNumber}} has been completely cancelled.', 'tmpl_cancelled', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, enabled) VALUES ('CANCEL_ORDER', 'CANCELLED', 'DERIVED', 'tmpl_cancelled', true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit + Payload Postmortem\"> <DbTable title=\"Confirmation turn audit chain\" columns={[\"Order\", \"Stage\", \"Must contain\"]} rows={[ [\"1\", \"DIALOGUE_ACT_CLASSIFIED\", \"dialogueAct=AFFIRM\"], [\"2\", \"INTERACTION_POLICY_DECIDED\", \"policyDecision=EXECUTE_PENDING_ACTION\"], [\"3\", \"GUARDRAIL_ALLOW\", \"result=ALLOW\"], [\"4\", \"PENDING_ACTION_EXECUTED\", \"pendingActionResult=EXECUTED\"], [\"5\", \"RULE_APPLIED\", \"state transition to CANCELLED\"], [\"6\", \"ASSISTANT_OUTPUT\", \"final response\"] ]} /> <CodeBlockToggle title=\"Audit payload checkpoint: PENDING_ACTION_EXECUTED\" language=\"json\"> { { \"_meta\": { \"stage\": \"PENDING_ACTION_EXECUTED\" }, \"policyDecision\": \"EXECUTE_PENDING_ACTION\", \"pendingActionRef\": \"stripeCancelTask\", \"pendingActionResult\": \"EXECUTED\", \"intent\": \"CANCEL_ORDER\", \"state\": \"CONFIRM_CANCEL\" } } </CodeBlockToggle> </TabItem> </Tabs> ## Example 4: INVENTORY_LOOKUP (Tool Orchestration) <Tabs groupId=\"v2-inventory-deep\"> <TabItem value=\"chat\" label=\"Chat Transcript\" default> <Conversation title=\"DB Orchestration Flow\"> <User info={[\"Inventory question needing tool/data call.\", \"Intent resolves to DATABASE_QUERY flow.\"]}>How many running shoes are left in warehouse B?</User> <Assistant tables={[\"ce_mcp_tool\"]} info={[\"Tool dispatch started.\", \"Waiting for adapter/tool result.\"]}>Checking the inventory database...</Assistant> <User info={[\"Represents in-flight tool call latency.\", \"No state mutation by user here.\"]}>*[System delay executing Tool]*</User> <Assistant tables={[\"ce_audit\", \"ce_response\"]} info={[\"tool_result consumed by response derivation.\", \"Final count rendered for user.\"]}>We currently have 421 units of running shoes allocated to warehouse B.</Assistant> </Conversation> </TabItem> <TabItem value=\"trace\" label=\"Per-turn Step Trace\"> <DbTable title=\"Tool Dispatch Trace\" columns={[\"Pipeline Step\", \"Internal Engine Action\"]} rows={[ [\"IntentResolutionStep\", \"Detects DATABASE_QUERY intent. State= IDLE .\"], [\"ToolOrchestrationStep\", \"Identifies INVENTORY_DB mapping. Routes payload to connected Java component adapting McpToolExecutor .\"], [\"Tool Execution (Java Adapter)\", \"Adapter processes input, runs SELECT count FROM inventory . Returns JSON payload {'count': 421} .\"], [\"ToolOrchestrationStep\", \"Writes returned JSON into engine session variable tool_result.dbList . Traces TOOL_ORCHESTRATION_RESULT .\"], [\"RulesStep\", \"Evaluates optional POST_TOOL_EXECUTION rules.\"], [\"ResponseResolutionStep\", \"Injects the 421 count into the derived template context and calls LLM.\"] ]} /> </TabItem> <TabItem value=\"db\" label=\"Required ce_* Rows\"> <CodeBlockToggle title=\"Tool Orchestration DML\" language=\"sql\" defaultOpen={true}> { INSERT INTO ce_intent (intent_code, enabled) VALUES ('DATABASE_QUERY', true); INSERT INTO ce_mcp_tool (intent_code, tool_group, required_params_json, execution_timeout_ms, enabled) VALUES ('DATABASE_QUERY', 'INVENTORY_DB', '[\"itemType\", \"warehouseId\"]', 5000, true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, user_prompt, template_id, enabled) VALUES ('DATABASE_QUERY', 'DERIVED', 'You are an inventory assistant.', 'Answer from these database results: {{tool_result.dbList}}', 'tmpl_inventory_gen', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, priority, enabled) VALUES ('DATABASE_QUERY', 'IDLE', 'DERIVED', 'tmpl_inventory_gen', 10, true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit + Payload Postmortem\"> <DbTable title=\"Tool Orchestration Checkpoints\" columns={[\"Order\", \"Stage\", \"Payload details\"]} rows={[ [\"1\", \"TOOL_ORCHESTRATION_DISPATCH\", \"toolGroup=INVENTORY_DB, toolParams\"], [\"2\", \"TOOL_ORCHESTRATION_RESULT\", \"toolResult={'count': 421}, executionMs\"], [\"3\", \"ASSISTANT_OUTPUT\", \"final response interpolation\"] ]} /> </TabItem> </Tabs> ## Example 5: SUPPORT_DIAGNOSTIC (Memory Summarization) <Tabs groupId=\"v2-support-deep\"> <TabItem value=\"chat\" label=\"Chat Transcript\" default> <Conversation title=\"Long Context Support Thread\"> <User info={[\"Initial problem statement.\", \"Starts long troubleshooting flow.\"]}>My router is broken.</User> <Assistant info={[\"Assistant begins diagnostic questions.\", \"No tool/action execution yet.\"]}>Let's check the lights. Are they green?</Assistant> <User info={[\"Represents many intermediate turns.\", \"Conversation memory grows significantly.\"]}>*[12 more dialogue turns testing different cables and lights]*</User> <Assistant tables={[\"ce_conversation_history\"]} info={[\"Assistant gives reset URL and PIN.\", \"Critical details should be retained in memory summary.\"]}>I suggest performing a factory reset via http://router.local/admin_reset with PIN 1234.</Assistant> <User info={[\"Time gap before follow-up.\", \"Memory recall scenario.\"]}>*[User is quiet for minutes]*</User> <User info={[\"Late-turn recall question.\", \"Requires memory-assisted response.\"]}>[Turn 15]: Wait, what link did you tell me to use for the firmware reset again?</User> <Assistant tables={[\"ce_audit\", \"ce_conversation_history\"]} info={[\"Memory summary injected.\", \"Assistant recalls prior URL and PIN correctly.\"]}>Based on our previous troubleshooting, you should use http://router.local/admin_reset with the default PIN 1234.</Assistant> </Conversation> </TabItem> <TabItem value=\"trace\" label=\"Per-turn Step Trace\"> <DbTable title=\"Memory Compression Trace (Turn 15)\" columns={[\"Pipeline Step\", \"Internal Engine Action\"]} rows={[ [\"MemoryStep (Background)\", \"Fetches raw history and asks LLM to re-summarize it into a tight timeline snapshot. Persists to ce_memory .\"], [\"DialogueActStep\", \"User asks 'what link did you tell me to use?'. Abstracted act= QUESTION .\"], [\"MemoryStep (Injection)\", \"Injects the compressed memory.session_summary variable directly into current Turn 15 context.\"], [\"IntentResolutionStep\", \"Resolves exact SUPPORT_DIAGNOSTIC intent leveraging memory context.\"], [\"ResponseResolutionStep\", \"Template retrieves the exact http://router.local string generated 10 turns ago.\"] ]} /> </TabItem> <TabItem value=\"db\" label=\"Required Configuration\"> <CodeBlockToggle title=\"Memory Auto-Summarization Config\" language=\"yaml\" defaultOpen={true}> { convengine: flow: memory: enabled: true # Max token size for the compressed summary string summary-max-chars: 1200 # Number of turns to trigger a new summary compression cycle recent-turns-for-summary: 3 } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit + Payload Postmortem\"> <DbTable title=\"Memory Checkpoints\" columns={[\"Order\", \"Stage\", \"Payload details\"]} rows={[ [\"1\", \"MEMORY_EVALUATED\", \"evaluatedTurns, previousSummaryLen\"], [\"2\", \"MEMORY_UPDATED\", \"newSummary generated and injected\"], [\"3\", \"INTENT_RESOLVED\", \"context aware resolution\"] ]} /> </TabItem> </Tabs>",
    "excerpt": "Real World Examples This page is intentionally dense. Each flow is shown as: 1. Chat transcript 2. Per turn step trace (what executed and why) 3. Required control plane rows ( ce_ ) 4. Audit timeline with payload level c…"
  },
  {
    "id": "deep-dive/failure-gotchas.mdx",
    "version": "v2",
    "title": "failure gotchas",
    "permalink": "/docs/v2/deep-dive/failure-gotchas",
    "content": "Data Correctness Gotchas (Current v2 Line) This page is still relevant, but it needed a reset. The current v2 framework has added stronger guardrails, scoped MCP configuration, verbose telemetry, and better prompt/runtime metadata. Even with those upgrades, there are still ways to get semantically wrong output without crashing the engine. This page focuses on the failure modes that still matter in the current repo, what the newer v2 features already improved, and what consumers should still protect at integration time. What v2 improved already Compared to the early v2 line, the current framework now reduces several older classes of mistakes: ce_mcp_tool , ce_mcp_planner , ce_pending_action , and ce_verbose are startup validated for scope/integrity MCP scope is explicit ( ANY / UNKNOWN ), not ambiguous null wildcard behavior CorrectionStep can keep confirmation/edit/retry turns in place instead of forcing unnecessary reclassification ce_verbose and step telemetry make degraded or skipped paths easier to detect POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP phases provide cleaner rule insertion points ce_mcp_planner makes MCP prompt selection deterministic by intent/state scope instead of relying only on legacy config Those are real upgrades, but they do not eliminate correctness risk. They mostly make bad behavior easier to prevent and easier to diagnose. Highest risk correctness failures that still exist Subtle traps introduced by newer flexibility The newer v2 line is more capable, but that also creates new configuration mistakes if consumers are careless. Still important framework limitations These are not necessarily bugs. They are design constraints consumers should plan around. What to watch in current traces If a conversation looks \"wrong\" but did not crash, these are the fastest places to inspect: final persisted ce_conversation.intent_code , state_code , context_json EngineSession.stepInfos via trace output RULE_MATCH / RULE_APPLIED ordering across phases ROUTING_DECISION values set by CorrectionStep context.mcp.lifecycle. and context.mcp.toolExecution. TOOL_ORCHESTRATION_ and MCP_ verbose/audit events RESOLVE_RESPONSE_SELECTED vs the final user visible payload Current hardening checklist Relevance summary The old page was directionally useful, but parts of it were anchored to early v2 behavior. The current version of this page is still relevant because the core correctness themes remain: race conditions are still the biggest operational correctness risk rule/config drift is still the biggest semantic correctness risk stale context and incomplete response coverage still produce believable but wrong output What changed is that current v2 gives you better tools to detect and constrain those issues: explicit scope validation richer rule phases correction routing verbose runtime signals step telemetry scoped MCP planner behavior Current v2 is safer and more diagnosable than the original release line, but it is still a highly configurable engine. Most production correctness issues now come from configuration design and concurrency policy, not from missing core framework primitives.",
    "rawContent": "# Data Correctness Gotchas (Current v2 Line) This page is still relevant, but it needed a reset. The current v2 framework has added stronger guardrails, scoped MCP configuration, verbose telemetry, and better prompt/runtime metadata. Even with those upgrades, there are still ways to get semantically wrong output without crashing the engine. This page focuses on the failure modes that still matter in the current repo, what the newer v2 features already improved, and what consumers should still protect at integration time. ## What v2 improved already Compared to the early v2 line, the current framework now reduces several older classes of mistakes: - ce_mcp_tool , ce_mcp_planner , ce_pending_action , and ce_verbose are startup-validated for scope/integrity - MCP scope is explicit ( ANY / UNKNOWN ), not ambiguous null wildcard behavior - CorrectionStep can keep confirmation/edit/retry turns in-place instead of forcing unnecessary reclassification - ce_verbose and step telemetry make degraded or skipped paths easier to detect - POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP phases provide cleaner rule insertion points - ce_mcp_planner makes MCP prompt selection deterministic by intent/state scope instead of relying only on legacy config Those are real upgrades, but they do not eliminate correctness risk. They mostly make bad behavior easier to prevent and easier to diagnose. ## Highest-risk correctness failures that still exist <DbTable title=\"Current top correctness risks\" columns={[ \"Risk\", \"Trigger\", \"Bad output pattern\", \"Fast detection\", \"Practical mitigation\" ]} rows={[ [ \"Concurrent same-conversation writes\", \"Two requests hit the same conversationId at nearly the same time.\", \"Last-write-wins state/context drift even though each individual turn looks valid.\", \"Compare updated_at , audit ordering, and final persisted ce_conversation row for overlapping turns.\", \"Serialize by conversationId at ingress or add optimistic locking around ce_conversation .\" ], [ \"Rule collisions produce valid-but-wrong transitions\", \"Multiple ce_rule rows match across phases or priorities and mutate intent/state in sequence.\", \"Conversation lands in a reachable state, but not the one the business flow intended.\", \"Review RULE_MATCH , RULE_APPLIED , and final intent/state across all phases, not just PRE_RESPONSE_RESOLUTION .\", \"Keep rule ownership narrow, minimize cross-intent mutations, and regression-test critical paths.\" ], [ \"Stale context survives topic or state changes\", \"A new turn merges into existing context without evicting fields that are no longer valid for the new flow.\", \"Old facts leak into prompt rendering, schema completeness checks, or final responses.\", \"Diff context_json before and after intent/state changes and look for old keys that should have been dropped.\", \"Define explicit reset rules on transition boundaries and clear stale fields when switching flows.\" ], [ \"Consumer exposes too much prompt data\", \"Broad inputParams or ad hoc metadata is allowed to influence prompt rendering.\", \"The model produces plausible output based on accidental or sensitive prompt variables.\", \"Inspect rendered prompt inputs during INTENT_* , SCHEMA_* , MCP_PLAN_* , and RESOLVE_RESPONSE_* LLM paths.\", \"Treat prompt exposure as an allowlist contract and keep internal-only keys out of prompt vars.\" ], [ \"Missing response coverage for reachable states\", \"Rules, MCP, or pending actions move the session into a state with no usable ce_response / ce_prompt_template mapping.\", \"The turn completes but returns fallback, empty, or misleading generic text.\", \"Build trace shows state transition succeeded but response selection falls back or misses expected template/response rows.\", \"Audit every reachable state and make response coverage part of config review.\" ] ]} /> ## Subtle traps introduced by newer flexibility The newer v2 line is more capable, but that also creates new configuration mistakes if consumers are careless. <DbTable title=\"Modern v2 flexibility traps\" columns={[\"Area\", \"What can go wrong\", \"Why it matters now\", \"Recommended guardrail\"]} rows={[ [ \" CorrectionStep routing\", \"A prompt row claims to allow affirm , edit , or retry , but the actual state contract is not safe for in-place reuse.\", \"The engine may skip schema extraction or intent resolution when the consumer really needed a full recompute.\", \"Use interaction_mode / interaction_contract only when the state really supports in-place continuation.\" ], [ \" SET_INPUT_PARAM rule action\", \"Rules can now mutate request-level values mid-pipeline.\", \"Small config mistakes can alter downstream tool calls, prompt variables, or response behavior in non-obvious ways.\", \"Restrict SET_INPUT_PARAM to tightly scoped, auditable keys and keep a change log for those rules.\" ], [ \"Scoped MCP rows\", \"A tool/planner row is syntactically valid but scoped too broadly with ANY when it should be intent-specific.\", \"The engine stays deterministic, but the business blast radius of a tool becomes larger than intended.\", \"Default to exact intent/state scope first; widen to ANY only when the tool is truly global.\" ], [ \" ce_verbose messages\", \"Verbose rows tell the user or UI a misleading progress story even while the engine remains technically correct.\", \"Support teams may trust the progress text more than the actual state transition.\", \"Treat ce_verbose as a tested UI contract, not cosmetic copy.\" ], [ \"Prompt renderer power\", \"Shared Thymeleaf rendering now applies across prompts and verbose messages.\", \"Template bugs can affect multiple runtime surfaces instead of just one prompt row.\", \"Lint templates before release and test variable availability per step.\" ] ]} /> ## Still-important framework limitations These are not necessarily bugs. They are design constraints consumers should plan around. <DbTable title=\"Design limits to plan around\" columns={[\"Limitation\", \"Current behavior\", \"Consumer impact\", \"Safer operating posture\"]} rows={[ [ \"No built-in optimistic locking on ce_conversation \", \"The entity does not expose a version field for conflict detection.\", \"Concurrent same-ID turns can overwrite each other nondeterministically.\", \"Enforce one active turn per conversationId at the API boundary.\" ], [ \"Turn work spans multiple step writes\", \"A turn is not wrapped in one global ACID-style business transaction boundary.\", \"Partial artifacts can persist across failures or stop paths.\", \"Make trace review part of incident debugging and prefer compensating logic over hidden assumptions.\" ], [ \"Data-driven behavior can still be misconfigured\", \"The framework validates structure, but not every business semantic mistake in rules/prompts/responses.\", \"A startup-clean system can still behave incorrectly for specific conversations.\", \"Test seeded configurations as a product artifact, not just Java code.\" ], [ \"Conversation ordering is still a consumer concern at scale\", \"The framework does not provide distributed per-conversation queueing by itself.\", \"Horizontal scale can amplify race and ordering ambiguity if ingress is naive.\", \"Use request serialization, partitioned workers, or upstream coordination.\" ], [ \"Tool safety is only partly framework-enforced\", \"Scope checks, MCP next-tool guardrails, and handler models exist, but business authorization remains consumer-defined.\", \"A correctly scoped tool can still expose data or actions beyond policy if the consumer wires it loosely.\", \"Treat tool execution as a security boundary and add business-policy checks in handlers.\" ] ]} /> ## What to watch in current traces If a conversation looks \"wrong\" but did not crash, these are the fastest places to inspect: - final persisted ce_conversation.intent_code , state_code , context_json - EngineSession.stepInfos via trace output - RULE_MATCH / RULE_APPLIED ordering across phases - ROUTING_DECISION values set by CorrectionStep - context.mcp.lifecycle.* and context.mcp.toolExecution.* - TOOL_ORCHESTRATION_* and MCP_* verbose/audit events - RESOLVE_RESPONSE_SELECTED vs the final user-visible payload ## Current hardening checklist <DbTable title=\"What mature consumers should enforce\" columns={[\"Control\", \"Why it matters\", \"Where to implement\"]} rows={[ [ \"Single active turn per conversation\", \"Prevents the most damaging state corruption class in the current framework.\", \"API gateway, controller, queue, or distributed lock layer\" ], [ \"Config regression tests\", \"Most modern failures are configuration mistakes, not framework crashes.\", \"Fixture tests around seeded ce_* rows\" ], [ \"Explicit response coverage audit\", \"Reachable states without responses create misleading fallback behavior.\", \"Pre-release DML review and smoke tests\" ], [ \"Tool policy review\", \"Broad ANY scope or under-protected handlers can create silent data risk.\", \" ce_mcp_tool design + consumer-side handler implementation\" ], [ \"Prompt-variable hygiene\", \"The current renderer is powerful enough to amplify accidental variable exposure.\", \"Prompt seeding discipline + consumer metadata filtering\" ] ]} /> ## Relevance summary The old page was directionally useful, but parts of it were anchored to early v2 behavior. The current version of this page is still relevant because the core correctness themes remain: - race conditions are still the biggest operational correctness risk - rule/config drift is still the biggest semantic correctness risk - stale context and incomplete response coverage still produce believable but wrong output What changed is that current v2 gives you better tools to detect and constrain those issues: - explicit scope validation - richer rule phases - correction routing - verbose runtime signals - step telemetry - scoped MCP planner behavior <Highlight type=\"info\" title=\"Bottom line\"> Current v2 is safer and more diagnosable than the original release line, but it is still a highly configurable engine. Most production correctness issues now come from configuration design and concurrency policy, not from missing core framework primitives. </Highlight>",
    "excerpt": "Data Correctness Gotchas (Current v2 Line) This page is still relevant, but it needed a reset. The current v2 framework has added stronger guardrails, scoped MCP configuration, verbose telemetry, and better prompt/runtim…"
  },
  {
    "id": "deep-dive/file-map.mdx",
    "version": "v2",
    "title": "file map",
    "permalink": "/docs/v2/deep-dive/file-map",
    "content": "File Map Core runtime engine/provider/DefaultConversationalEngine.java engine/factory/EnginePipelineFactory.java engine/pipeline/EnginePipeline.java engine/session/EngineSession.java New flow config config/ConvEngineFlowConfig.java New steps engine/steps/DialogueActStep.java engine/steps/InteractionPolicyStep.java engine/steps/ActionLifecycleStep.java engine/steps/DisambiguationStep.java engine/steps/GuardrailStep.java engine/steps/PendingActionStep.java (enhanced behavior) engine/steps/ToolOrchestrationStep.java engine/steps/StateGraphStep.java engine/steps/MemoryStep.java Intent/schema/rules/response engine/steps/IntentResolutionStep.java engine/steps/SchemaExtractionStep.java engine/steps/RulesStep.java engine/steps/ResponseResolutionStep.java MCP + tool execution engine/steps/McpToolStep.java engine/mcp/McpPlanner.java engine/mcp/McpToolRegistry.java engine/mcp/executor/McpToolExecutor.java engine/mcp/executor/ (group specific executors) engine/mcp/executor/adapter/ (consumer adapter contracts) Data + repositories entity/CePendingAction.java repo/PendingActionRepository.java entity/CeRule.java repo/RuleRepository.java SQL DDL files in src/main/resources/sql/ Memory + eval engine/memory/ConversationMemoryStore.java engine/eval/ConversationReplayService.java engine/eval/model/",
    "rawContent": "# File Map ## Core runtime - engine/provider/DefaultConversationalEngine.java - engine/factory/EnginePipelineFactory.java - engine/pipeline/EnginePipeline.java - engine/session/EngineSession.java ## New flow config - config/ConvEngineFlowConfig.java ## New steps - engine/steps/DialogueActStep.java - engine/steps/InteractionPolicyStep.java - engine/steps/ActionLifecycleStep.java - engine/steps/DisambiguationStep.java - engine/steps/GuardrailStep.java - engine/steps/PendingActionStep.java (enhanced behavior) - engine/steps/ToolOrchestrationStep.java - engine/steps/StateGraphStep.java - engine/steps/MemoryStep.java ## Intent/schema/rules/response - engine/steps/IntentResolutionStep.java - engine/steps/SchemaExtractionStep.java - engine/steps/RulesStep.java - engine/steps/ResponseResolutionStep.java ## MCP + tool execution - engine/steps/McpToolStep.java - engine/mcp/McpPlanner.java - engine/mcp/McpToolRegistry.java - engine/mcp/executor/McpToolExecutor.java - engine/mcp/executor/* (group-specific executors) - engine/mcp/executor/adapter/* (consumer adapter contracts) ## Data + repositories - entity/CePendingAction.java - repo/PendingActionRepository.java - entity/CeRule.java - repo/RuleRepository.java - SQL DDL files in src/main/resources/sql/* ## Memory + eval - engine/memory/ConversationMemoryStore.java - engine/eval/ConversationReplayService.java - engine/eval/model/*",
    "excerpt": "File Map Core runtime engine/provider/DefaultConversationalEngine.java engine/factory/EnginePipelineFactory.java engine/pipeline/EnginePipeline.java engine/session/EngineSession.java New flow config config/ConvEngineFlow…"
  },
  {
    "id": "deep-dive/improvement-backlog.mdx",
    "version": "v2",
    "title": "improvement backlog",
    "permalink": "/docs/v2/deep-dive/improvement-backlog",
    "content": "Improvement Backlog This page is the forward looking backlog for ConvEngine. It is intentionally biased toward improvements that make the engine more deterministic, more auditable, and cheaper to operate at runtime. These are product and framework shape suggestions, not all committed roadmap items. The emphasis is on ideas that improve runtime clarity, reduce repeated LLM work, and make the control plane easier to manage in SQL. Current priorities Suggested roadmap Expand the confirmation first model so more flows can use DialogueActStep + CorrectionStep + phase scoped rules instead of rerunning extraction or intent classification on short follow up turns. Push more lightweight control behavior into native actions ( SET_INPUT_PARAM , better structured action payloads, clearer phase semantics) so teams need fewer custom beans for simple routing. Make replay, verbose, and audit traces easier to consume by humans: better examples, summarized traces, and stronger conventions around emitted runtime metadata. Design suggestions by theme Strong candidates for near term implementation The best docs for ConvEngine are not long paragraphs. They are compact tables, explicit examples, visible runtime flags, and clear “when to use this phase/step” guidance. Dense pages should keep leaning toward that style. What would make the framework feel more intuitive More scenario driven pages like the MCP examples, where state transitions, rule phases, and runtime flags are shown together. More visual chips for high signal fields like intent , state , phase , and routing_decision . More “bad pattern vs good pattern” guidance for prompts, rules, and follow up turns. More compact, color coded summaries at the top of deep dive pages so users can scan before reading the full detail. The framework becomes harder to use when control logic is pushed into prompt text instead of structured runtime state. The backlog should keep favoring typed flags, explicit phases, and deterministic routing over “smart prompt” behavior.",
    "rawContent": "# Improvement Backlog This page is the forward-looking backlog for ConvEngine. It is intentionally biased toward improvements that make the engine more deterministic, more auditable, and cheaper to operate at runtime. <Highlight type=\"info\" title=\"How to read this page\"> These are product and framework-shape suggestions, not all committed roadmap items. The emphasis is on ideas that improve runtime clarity, reduce repeated LLM work, and make the control plane easier to manage in SQL. </Highlight> ## Current priorities <DbTable title=\"High-value backlog areas\" columns={[\"Area\", \"Why it matters\", \"Practical outcome\"]} rows={[ [\"Confirmation-first routing\", \"Too many flows still treat every turn as a fresh extraction request.\", \"Reduce duplicate LLM calls by routing AFFIRM / EDIT / NEGATE deterministically.\"], [\"Richer runtime flags\", \"Business flows need lightweight state between turns without custom Java every time.\", \"Use SET_INPUT_PARAM and related helpers as the default control primitive.\"], [\"MCP execution guardrails\", \"Teams need clearer gates before expensive planner/tool loops start.\", \"Strengthen pre-MCP phases and skip conditions.\"], [\"Prompt/rendering ergonomics\", \"Templates are now more powerful, but easier to misuse.\", \"Provide stricter guidance and better rendering-safe patterns.\"], [\"Docs from runtime contracts\", \"Docs drift when code and SQL evolve quickly.\", \"Generate more reference docs directly from enums, constants, and DDL.\"] ]} /> ## Suggested roadmap <FlowStep step=\"1\" title=\"Turn-routing maturity\"> Expand the confirmation-first model so more flows can use DialogueActStep + CorrectionStep + phase-scoped rules instead of rerunning extraction or intent classification on short follow-up turns. </FlowStep> <FlowStep step=\"2\" title=\"Rule-control maturity\"> Push more lightweight control behavior into native actions ( SET_INPUT_PARAM , better structured action payloads, clearer phase semantics) so teams need fewer custom beans for simple routing. </FlowStep> <FlowStep step=\"3\" title=\"Observability maturity\"> Make replay, verbose, and audit traces easier to consume by humans: better examples, summarized traces, and stronger conventions around emitted runtime metadata. </FlowStep> ## Design suggestions by theme <DbTable title=\"Concrete suggestions\" columns={[\"Theme\", \"Suggestion\", \"Why it is worth doing\"]} rows={[ [\"Correction flows\", \"Add a small deterministic patch library plus optional LLM patch fallback.\", \"This is cheaper and cleaner than full schema re-extraction for every edit.\"], [\"Confirmation flows\", \"Standardize awaiting_confirmation , confirmation_key , routing_decision , and skip_schema_extraction as the canonical runtime flags.\", \"This makes yes/no/confirm turns reliable without dirty prompt-only logic.\"], [\"Rule authoring\", \"Add more docs and examples for POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP as separate control points.\", \"These are the most important new phases for practical business workflows.\"], [\"Prompt safety\", \"Ship recommended Thymeleaf/SpEL template patterns for null-safe rendering and avoid brittle nested property assumptions.\", \"This reduces prompt failures and weird UI text when values are absent.\"], [\"Verbose UX\", \"Add more consumer examples using ConvEngineVerboseAdapter for hooks, transformers, and custom tool orchestration.\", \"Teams can improve UI feedback without touching transport internals.\"], [\"Replay/testing\", \"Promote audit replay assertions into a more visible first-class workflow.\", \"This is the fastest way to stop regressions in rule-heavy systems.\"], [\"Docs discoverability\", \"Use more callouts, table summaries, and visual chips on dense reference pages.\", \"The engine is already feature-rich; docs should reduce scanning cost.\"], [\"Config hygiene\", \"Document and surface more canonical constants/keys so users stop inventing inconsistent payload fields.\", \"This improves interoperability across rules, prompts, and consumer hooks.\"] ]} /> ## Strong candidates for near-term implementation <DbTable title=\"Pragmatic next additions\" columns={[\"Candidate\", \"Complexity\", \"Value\"]} rows={[ [\"Dedicated confirmation-routing docs bundle\", \"Low\", \"High\"], [\"More SET_INPUT_PARAM examples across business flows\", \"Low\", \"High\"], [\"CorrectionStep deterministic patch cookbook\", \"Medium\", \"High\"], [\"Replay cookbook for CI validation\", \"Medium\", \"High\"], [\"Docs generation from enums/constants\", \"Medium\", \"Medium\"], [\"Stronger verbose patterns catalog\", \"Low\", \"Medium\"] ]} /> <Highlight type=\"tip\" title=\"Documentation direction\"> The best docs for ConvEngine are not long paragraphs. They are compact tables, explicit examples, visible runtime flags, and clear “when to use this phase/step” guidance. Dense pages should keep leaning toward that style. </Highlight> ## What would make the framework feel more intuitive - More scenario-driven pages like the MCP examples, where state transitions, rule phases, and runtime flags are shown together. - More visual chips for high-signal fields like intent , state , phase , and routing_decision . - More “bad pattern vs good pattern” guidance for prompts, rules, and follow-up turns. - More compact, color-coded summaries at the top of deep-dive pages so users can scan before reading the full detail. <Highlight type=\"warning\" title=\"Main risk to avoid\"> The framework becomes harder to use when control logic is pushed into prompt text instead of structured runtime state. The backlog should keep favoring typed flags, explicit phases, and deterministic routing over “smart prompt” behavior. </Highlight>",
    "excerpt": "Improvement Backlog This page is the forward looking backlog for ConvEngine. It is intentionally biased toward improvements that make the engine more deterministic, more auditable, and cheaper to operate at runtime. Thes…"
  },
  {
    "id": "deep-dive/index.mdx",
    "version": "v2",
    "title": "index",
    "permalink": "/docs/v2/deep-dive",
    "content": "Deep Dive This section documents the actual runtime behavior from code and schema, including step contracts, rule phases, audit traces, and control plane tables. Sections : End to end turn lifecycle and branch points. : Turn by turn chat, DB contracts, and audit timeline walkthroughs. : ce_ table contracts and runtime/control plane split. : ce_verbose resolution path, determinants, stream envelope, and ce_conversation runtime behavior. : Consumer implementation and extension strategy. : Source level map of key classes by responsibility. : Full step by step pipeline with exact stage purpose. : Intent resolution + schema extraction internals. : Rule phases, match/action behavior, response resolution. : MCP planner/tool orchestration and audit stages. : Detailed breakdown of newly introduced capabilities. : Common failure/correctness risks and mitigations.",
    "rawContent": "# Deep Dive This section documents the actual runtime behavior from code and schema, including step contracts, rule phases, audit traces, and control-plane tables. ## Sections - [Lifecycle](/docs/v2/deep-dive/lifecycle): End-to-end turn lifecycle and branch points. - [Real World Examples](/docs/v2/deep-dive/examples): Turn-by-turn chat, DB contracts, and audit timeline walkthroughs. - [Data Model](/docs/v2/deep-dive/data-model): ce_* table contracts and runtime/control-plane split. - [Verbose and Conversation Runtime](/docs/v2/deep-dive/verbose-and-conversation-runtime): ce_verbose resolution path, determinants, stream envelope, and ce_conversation runtime behavior. - [Developer Guide](/docs/v2/deep-dive/developer-guide): Consumer implementation and extension strategy. - [File Map](/docs/v2/deep-dive/file-map): Source-level map of key classes by responsibility. - [Pipeline Steps](/docs/v2/deep-dive/pipeline-steps): Full step-by-step pipeline with exact stage purpose. - [Intent & Schema](/docs/v2/deep-dive/intent-and-schema): Intent resolution + schema extraction internals. - [Rules & Responses](/docs/v2/deep-dive/rules-responses): Rule phases, match/action behavior, response resolution. - [MCP and Audit](/docs/v2/deep-dive/mcp-audit): MCP planner/tool orchestration and audit stages. - [v2 Features](/docs/v2/deep-dive/v2-features): Detailed breakdown of newly introduced capabilities. - [Failure Gotchas](/docs/v2/deep-dive/failure-gotchas): Common failure/correctness risks and mitigations.",
    "excerpt": "Deep Dive This section documents the actual runtime behavior from code and schema, including step contracts, rule phases, audit traces, and control plane tables. Sections : End to end turn lifecycle and branch points. : …"
  },
  {
    "id": "deep-dive/intent-and-schema.mdx",
    "version": "v2",
    "title": "intent and schema",
    "permalink": "/docs/v2/deep-dive/intent-and-schema",
    "content": "Intent and Schema Internals Dialogue act resolution DialogueActStep handles linguistic classification before intent resolution even begins. It supports three configuration modes via convengine.flow.dialogue act.resolute : REGEX_ONLY REGEX_THEN_LLM LLM_ONLY When the LLM path is engaged (confidence below llm threshold ), it must return a strict JSON payload containing the act and confidence to be parsed by the engine. It can also derive standaloneQuery , which becomes resolved_user_input when present. Interaction policy decision InteractionPolicyStep derives the routing policy for the current turn based on existing context. Confirmation routing and correction CorrectionStep runs after InteractionPolicyStep and before intent/schema rework. It handles confirmation state turns without forcing full re extraction: AFFIRM in confirmation state can set routing_decision=PROCEED_CONFIRMED EDIT in confirmation state can patch a single field in place and keep the flow in CONFIRMATION downstream rules can use POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP to route the next state deterministically Intent resolver behavior The pipeline resolves intent in order of priority via CompositeIntentResolver . The engine prevents intent drift during active schema collection automatically. You will see these audit signals in the trace when intent resolution is intentionally bypassed: INTENT_RESOLVE_SKIPPED_POLICY INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION INTENT_RESOLVE_SKIPPED_STICKY_INTENT Schema extraction SchemaExtractionStep drives missing field follow up flows and automatically formats prompt templates utilizing ce_prompt_template . , \"email\": } } } Runtime facts are evaluated and written into the EngineSession context by AutoAdvanceStep , making them available for ce_rule evaluation: missing_fields missing_field_options schema_json schema_complete Once extraction is complete, POST_SCHEMA_EXTRACTION rules can move the flow into confirmation without waiting for MCP execution. Use schema extraction for required slot collection, and use dialogue acts + interaction policies for short confirmations (like replying \"yes\" to \"Are you sure?\"). This ensures intent reclassification does not disrupt your active multi turn flows.",
    "rawContent": "# Intent and Schema Internals ## Dialogue act resolution DialogueActStep handles linguistic classification before intent resolution even begins. It supports three configuration modes via convengine.flow.dialogue-act.resolute : - REGEX_ONLY - REGEX_THEN_LLM - LLM_ONLY <DbTable title=\"Core Dialogue Acts\" columns={[\"Act\", \"Meaning\", \"Regex Sample\"]} rows={[ [\"AFFIRM\", \"User agrees or confirms\", \"(?i)^\\\\\\\\s*(yes|yep|yeah|sure)\\\\\\\\s*$\"], [\"NEGATE\", \"User disagrees or cancels\", \"(?i)^\\\\\\\\s*(no|nope|cancel)\\\\\\\\s*$\"], [\"ANSWER\", \"User answers an active clarification or slot question\", \"short direct answer in active flow\"], [\"EDIT\", \"User requests a correction\", \"(?i)^\\\\\\\\s*(edit|change|modify)\\\\\\\\s*$\"], [\"RESET\", \"User requests a fresh start\", \"(?i)^\\\\\\\\s*(reset|start over)\\\\\\\\s*$\"], [\"QUESTION\", \"User asks a clarifying question\", \"text ending in '?'\"], [\"NEW_REQUEST\", \"(Fallback) User begins a new topic\", \"default fallback\"], ]} /> When the LLM path is engaged (confidence below llm-threshold ), it must return a strict JSON payload containing the act and confidence to be parsed by the engine. It can also derive standaloneQuery , which becomes resolved_user_input when present. ## Interaction policy decision InteractionPolicyStep derives the routing policy for the current turn based on existing context. <DbTable title=\"Engine Routing Policies\" columns={[\"Policy Decision\", \"Trigger Context\", \"Pipeline Impact\"]} rows={[ [\"EXECUTE_PENDING_ACTION\", \"DialogueAct=AFFIRM + hasPendingAction\", \"Triggers PendingActionStep; Skips Intent Resolution\"], [\"REJECT_PENDING_ACTION\", \"DialogueAct=NEGATE + hasPendingAction\", \"Marks Pending task REJECTED; Skips Intent Resolution\"], [\"FILL_PENDING_SLOT\", \"DialogueAct!=NEW_REQUEST + hasPendingSlot\", \"Passes input to SchemaExtractionStep; Skips Intent Resolution\"], [\"RECLASSIFY_INTENT\", \"DialogueAct=NEW_REQUEST (or no pending state)\", \"Forces standard Intent Resolution\"], ]} /> ## Confirmation routing and correction CorrectionStep runs after InteractionPolicyStep and before intent/schema rework. It handles confirmation-state turns without forcing full re-extraction: - AFFIRM in confirmation state can set routing_decision=PROCEED_CONFIRMED - EDIT in confirmation state can patch a single field in-place and keep the flow in CONFIRMATION - downstream rules can use POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP to route the next state deterministically ## Intent resolver behavior The pipeline resolves intent in order of priority via CompositeIntentResolver . <Highlight type=\"info\" title=\"Lock and Skip Behaviors\"> The engine prevents intent drift during active schema collection automatically. You will see these audit signals in the trace when intent resolution is intentionally bypassed: - INTENT_RESOLVE_SKIPPED_POLICY - INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION - INTENT_RESOLVE_SKIPPED_STICKY_INTENT </Highlight> ## Schema extraction SchemaExtractionStep drives missing-field follow-up flows and automatically formats prompt templates utilizing ce_prompt_template . <CodeBlockToggle title=\"Schema LLM Injection Template\" language=\"json\" defaultOpen={false} > { { \"type\": \"object\", \"required\": [\"customerId\", \"email\"], \"properties\": { \"customerId\": {\"type\": \"string\"}, \"email\": {\"type\": \"string\"} } } } </CodeBlockToggle> Runtime facts are evaluated and written into the EngineSession context by AutoAdvanceStep , making them available for ce_rule evaluation: - missing_fields - missing_field_options - schema_json - schema_complete Once extraction is complete, POST_SCHEMA_EXTRACTION rules can move the flow into confirmation without waiting for MCP execution. <Highlight type=\"success\" title=\"Practical design rule\"> Use **schema extraction** for required slot collection, and use **dialogue acts + interaction policies** for short confirmations (like replying \"yes\" to \"Are you sure?\"). This ensures intent reclassification does not disrupt your active multi-turn flows. </Highlight>",
    "excerpt": "Intent and Schema Internals Dialogue act resolution DialogueActStep handles linguistic classification before intent resolution even begins. It supports three configuration modes via convengine.flow.dialogue act.resolute …"
  },
  {
    "id": "deep-dive/lifecycle.mdx",
    "version": "v2",
    "title": "lifecycle",
    "permalink": "/docs/v2/deep-dive/lifecycle",
    "content": ", , , , , , , , , , , , , , , , , , , , , , , , , , , ]; Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open /docs/v2/deep dive/request lifecycle . 1. API Entry Point The journey begins when a client sends a POST request to /api/v1/conversation/message . } 2. Engine Processing } 3. The Pipeline (Step by Step) DialogueActStep , InteractionPolicyStep , CorrectionStep , ActionLifecycleStep , DisambiguationStep , PendingActionStep , ToolOrchestrationStep , McpToolStep , StateGraphStep , and MemoryStep are route conditional and execute only when their prerequisites are met. Every step emits audit events. Use /audit/ /trace , then open /docs/v2/deep dive/request lifecycle and /docs/v2/deep dive/examples to compare turn by turn real world traces.",
    "rawContent": "{ name: \"LoadOrCreateConversationStep\", description: \"Hydrates existing conversation or creates new conversation shell.\" }, { name: \"CacheInspectAuditStep\", description: \"Conditionally audits cache snapshot when cache-inspector enabled.\" }, { name: \"ResetConversationStep\", description: \"Applies reset/start-over command handling.\" }, { name: \"PersistConversationBootstrapStep\", description: \"Persists conversation bootstrap row before persisted-required steps.\" }, { name: \"AuditUserInputStep\", description: \"Writes raw user input audit event.\" }, { name: \"PolicyEnforcementStep\", description: \"Applies pre-intent policy checks and safe short-circuit when required.\" }, { name: \"DialogueActStep\", description: \"Classifies turn as AFFIRM/NEGATE/ANSWER/EDIT/RESET/QUESTION/NEW_REQUEST and can derive standalone_query.\" }, { name: \"InteractionPolicyStep\", description: \"Decides EXECUTE_PENDING_ACTION / REJECT_PENDING_ACTION / FILL_PENDING_SLOT / RECLASSIFY_INTENT.\" }, { name: \"CorrectionStep\", description: \"Applies confirmation routing and in-place schema correction before intent/schema rework.\" }, { name: \"ActionLifecycleStep\", description: \"Maintains pending_action_runtime status with TTL semantics.\" }, { name: \"DisambiguationStep\", description: \"When multiple actions are eligible, asks targeted clarification and pauses execution.\" }, { name: \"GuardrailStep\", description: \"Sanitization + sensitive checks + approval gate hooks.\" }, { name: \"IntentResolutionStep\", description: \"Resolves intent unless policy says skip_intent_resolution.\" }, { name: \"ResetResolvedIntentStep\", description: \"Applies post-intent reset mapping.\" }, { name: \"FallbackIntentStateStep\", description: \"Assigns fallback UNKNOWN flow when intent/state unresolved.\" }, { name: \"AddContainerDataStep\", description: \"Merges configured container data into runtime context.\" }, { name: \"PendingActionStep\", description: \"Executes or rejects pending action task via CeTaskExecutor.\" }, { name: \"ToolOrchestrationStep\", description: \"Unified tool request->execute->result contract by tool_group.\" }, { name: \"McpToolStep\", description: \"Planner loop for CALL_TOOL/ANSWER with MCP observations.\" }, { name: \"SchemaExtractionStep\", description: \"Parses/extracts structured schema fields.\" }, { name: \"AutoAdvanceStep\", description: \"Advances state when schema/task facts satisfy conditions.\" }, { name: \"RulesStep\", description: \"Runs phase-scoped rules and actions with cascade passes.\" }, { name: \"StateGraphStep\", description: \"Validate-only transition check, no forced state mutation.\" }, { name: \"ResponseResolutionStep\", description: \"Resolves EXACT/DERIVED response output.\" }, { name: \"MemoryStep\", description: \"Writes session summary and optional recall memory.\" }, { name: \"PersistConversationStep\", description: \"Persists conversation/result/audit metadata.\" }, { name: \"PipelineEndGuardStep\", description: \"Final guard and timing closure.\" }, ]; # Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open <FileRef>/docs/v2/deep-dive/request-lifecycle</FileRef>. ## 1. API Entry Point The journey begins when a client sends a POST request to /api/v1/conversation/message . <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.api.controller\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\" > { @PostMapping(\"/message\") public ConversationResponse message(@RequestBody ConversationRequest request) { EngineContext engineContext = EngineContext.builder() .conversationId(request.getConversationId()) .userText(request.getMessage()) .inputParams(request.getInputParams()) .build(); EngineResult result = engine.process(engineContext); return mapToResponse(result); } } </CodeBlockToggle> ## 2. Engine Processing <CodeBlockToggle title=\"DefaultConversationalEngine.process\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" > { @Override public EngineResult process(EngineContext engineContext) { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } } </CodeBlockToggle> ## 3. The Pipeline (Step-by-Step) <PipelineStepList ariaLabel=\"Pipeline step-by-step (v2)\" steps={v2PipelineSteps} /> <Highlight type=\"info\" title=\"Core path vs conditional steps\"> DialogueActStep , InteractionPolicyStep , CorrectionStep , ActionLifecycleStep , DisambiguationStep , PendingActionStep , ToolOrchestrationStep , McpToolStep , StateGraphStep , and MemoryStep are route-conditional and execute only when their prerequisites are met. </Highlight> <Highlight type=\"success\" title=\"Audit Trail + Real-world trace\"> Every step emits audit events. Use /audit/{id}/trace , then open <FileRef>/docs/v2/deep-dive/request-lifecycle</FileRef> and <FileRef>/docs/v2/deep-dive/examples</FileRef> to compare turn-by-turn real-world traces. </Highlight>",
    "excerpt": ", , , , , , , , , , , , , , , , , , , , , , , , , , , ]; Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open /docs/v2/deep dive/request lifecycle . 1. API Entry Point The jo…"
  },
  {
    "id": "deep-dive/mcp-audit.mdx",
    "version": "v2",
    "title": "mcp audit",
    "permalink": "/docs/v2/deep-dive/mcp-audit",
    "content": "MCP, Tool Orchestration, and Audit (v2) Two tool paths 1. ToolOrchestrationStep (direct tool mode) request driven via tool_request executes one tool runs POST_TOOL_EXECUTION rules writes context.mcp.toolExecution. 2. McpToolStep (planner loop mode) planner loop ( CALL_TOOL / ANSWER ) writes context.mcp.observations[] and context.mcp.finalAnswer runs POST_AGENT_MCP rules writes context.mcp.lifecycle. Guardrail blocked branch If planner proposes a blocked next tool: mcp_status=GUARDRAIL_BLOCKED_NEXT_TOOL fallback final text is written to context.mcp.finalAnswer POST_AGENT_MCP rules still run response is still finalized by ce_response resolution Rule ready MCP metadata context.mcp.lifecycle includes: phase , status , outcome , finished blocked , error , errorMessage lastAction , lastToolCode , lastToolGroup , lastToolArgs toolExecuted context.mcp.toolExecution includes: phase , status , outcome , finished error , scopeMismatch , toolExecuted toolCode , toolGroup , meta , result , errorMessage JSON_PATH examples for ce_rule.match_pattern text $[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.outcome == 'BLOCKED')] $[?(@.context.mcp.lifecycle.error == true)] $[?(@.context.mcp.toolExecution.phase == 'POST_TOOL_EXECUTION' && @.context.mcp.toolExecution.status == 'SUCCESS')] $[?(@.context.mcp.toolExecution.scopeMismatch == true)] Audit stages to watch Tool orchestration path: TOOL_ORCHESTRATION_REQUEST TOOL_ORCHESTRATION_RESULT TOOL_ORCHESTRATION_ERROR Planner MCP path: MCP_PLAN_LLM_INPUT MCP_PLAN_LLM_OUTPUT MCP_TOOL_CALL MCP_TOOL_RESULT MCP_TOOL_ERROR MCP_FINAL_ANSWER Rule phases around these paths: RULE_MATCH (McpToolStep) / RULE_NO_MATCH (McpToolStep) RULE_MATCH (ToolOrchestrationStep PostTool) / RULE_NO_MATCH (ToolOrchestrationStep PostTool) RULE_MATCH (AgentIntentResolver) / RULE_NO_MATCH (AgentIntentResolver) RULE_MATCH (RulesStep) / RULE_NO_MATCH (RulesStep) Scope enforcement ce_mcp_tool and ce_mcp_planner are scope validated at startup: null/blank scope rows are rejected intent_code must be ANY , UNKNOWN , or defined in ce_intent state_code must be ANY , UNKNOWN , or present in ce_rule.state_code",
    "rawContent": "# MCP, Tool Orchestration, and Audit (v2) ## Two tool paths 1. ToolOrchestrationStep (direct tool mode) - request-driven via tool_request - executes one tool - runs POST_TOOL_EXECUTION rules - writes context.mcp.toolExecution.* 2. McpToolStep (planner loop mode) - planner loop ( CALL_TOOL / ANSWER ) - writes context.mcp.observations[] and context.mcp.finalAnswer - runs POST_AGENT_MCP rules - writes context.mcp.lifecycle.* ## Guardrail blocked branch If planner proposes a blocked next tool: - mcp_status=GUARDRAIL_BLOCKED_NEXT_TOOL - fallback final text is written to context.mcp.finalAnswer - POST_AGENT_MCP rules still run - response is still finalized by ce_response resolution ## Rule-ready MCP metadata context.mcp.lifecycle includes: - phase , status , outcome , finished - blocked , error , errorMessage - lastAction , lastToolCode , lastToolGroup , lastToolArgs - toolExecuted context.mcp.toolExecution includes: - phase , status , outcome , finished - error , scopeMismatch , toolExecuted - toolCode , toolGroup , meta , result , errorMessage ## JSON_PATH examples for ce_rule.match_pattern text $[?(@.context.mcp.lifecycle.finished == true && @.context.mcp.lifecycle.outcome == 'BLOCKED')] $[?(@.context.mcp.lifecycle.error == true)] $[?(@.context.mcp.toolExecution.phase == 'POST_TOOL_EXECUTION' && @.context.mcp.toolExecution.status == 'SUCCESS')] $[?(@.context.mcp.toolExecution.scopeMismatch == true)] ## Audit stages to watch Tool orchestration path: - TOOL_ORCHESTRATION_REQUEST - TOOL_ORCHESTRATION_RESULT - TOOL_ORCHESTRATION_ERROR Planner MCP path: - MCP_PLAN_LLM_INPUT - MCP_PLAN_LLM_OUTPUT - MCP_TOOL_CALL - MCP_TOOL_RESULT - MCP_TOOL_ERROR - MCP_FINAL_ANSWER Rule phases around these paths: - RULE_MATCH (McpToolStep) / RULE_NO_MATCH (McpToolStep) - RULE_MATCH (ToolOrchestrationStep PostTool) / RULE_NO_MATCH (ToolOrchestrationStep PostTool) - RULE_MATCH (AgentIntentResolver) / RULE_NO_MATCH (AgentIntentResolver) - RULE_MATCH (RulesStep) / RULE_NO_MATCH (RulesStep) ## Scope enforcement ce_mcp_tool and ce_mcp_planner are scope-validated at startup: - null/blank scope rows are rejected - intent_code must be ANY , UNKNOWN , or defined in ce_intent - state_code must be ANY , UNKNOWN , or present in ce_rule.state_code",
    "excerpt": "MCP, Tool Orchestration, and Audit (v2) Two tool paths 1. ToolOrchestrationStep (direct tool mode) request driven via tool_request executes one tool runs POST_TOOL_EXECUTION rules writes context.mcp.toolExecution. 2. Mcp…"
  },
  {
    "id": "deep-dive/pipeline-steps.mdx",
    "version": "v2",
    "title": "pipeline steps",
    "permalink": "/docs/v2/deep-dive/pipeline-steps",
    "content": "Pipeline Steps (what each step does) :::tip Hook where you need precision Before schema extraction: normalize inputs After rules: inspect intent/state transition correctness Before response resolution: inject display hints ::: Rules execute by phase. Available native phases include PRE_RESPONSE_RESOLUTION , POST_AGENT_INTENT , POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP , POST_AGENT_MCP , and POST_TOOL_EXECUTION . Prefer transitions in ce_rule unless absolutely framework level behavior is required. This keeps domain behavior data driven and testable via audit traces. ce_prompt_template.interaction_mode and ce_prompt_template.interaction_contract are the preferred turn semantics contract in v2.0.9+. SchemaExtractionStep uses the scoped SCHEMA_JSON template for extraction prompts; COLLECT plus expects:[\"structured_input\"] is the recommended shape. CorrectionStep should rely on the active prompt template semantics ( CONFIRM , PROCESSING , and interaction_contract capabilities such as affirm , edit , retry ) instead of parsing state name substrings. ResponseResolutionStep still selects by intent_code + state_code + response_type , but interaction_mode helps document what kind of user interaction that template represents. 1 LoadOrCreateConversationStep Responsibility: Fetch or bootstrap conversation row Session Mutations: conversation, intent/state/context sync Config/Table Dependencies: ce_conversation Detailed Execution Logic This is the initial bootstrap step of the runtime engine. It uses the conversationId provided in the HTTP request to lookup an existing CeConversation row in the Postgres database. If the conversation exists: The context JSON is hydrated into the runtime EngineSession . Previous intent and state codes are restored. All stored memory summaries and pending actions are fetched from the database and loaded into memory. If the conversation is new: A new CeConversation entity is instantiated. The intent and state default to UNKNOWN . This ensures that regardless of scale, the API is entirely stateless and can route requests to any pod. } When the LLM path is used, DialogueActStep now audits: DIALOGUE_ACT_LLM_INPUT DIALOGUE_ACT_LLM_OUTPUT DIALOGUE_ACT_LLM_ERROR It still emits the final classification checkpoint as DIALOGUE_ACT_CLASSIFIED . 2 CacheInspectAuditStep Responsibility: Conditionally audit cache snapshot Session Mutations: none Config/Table Dependencies: convengine.audit.cache inspector property Detailed Execution Logic Dynamically runs if convengine.audit.cache inspector is true. It takes a complete JSON snapshot of the hydrated EngineSession conversation cache tree and logs it under the CACHE_INSPECTION priority stage before explicit user input audits are finalized. } 3 ResetConversationStep Responsibility: Early explicit reset Session Mutations: intent/state/context/input params reset Config/Table Dependencies: input flags, command text Detailed Execution Logic Checks EngineSession properties to see if an explicit reset has been triggered by the invoking consumer (this is usually passed as a param like _reset=true ). When triggered, it clears: The intent and state trackers. The contextJson (wiping all extracted schema facts). The inputParamsJson . The session is marked as \\ RUNNING\\ again, but completely fresh. An audit event CONVERSATION_RESET is logged. String reason = resetReason(session); session.resetForConversationRestart(); session.getConversation().setStatus(\"RUNNING\"); session.getConversation().setIntentCode(\"UNKNOWN\"); session.getConversation().setStateCode(\"UNKNOWN\"); session.getConversation().setContextJson(\" \"); session.getConversation().setInputParamsJson(\" \"); session.getConversation().setLastAssistantJson(null); session.getConversation().setUpdatedAt(OffsetDateTime.now()); conversationRepository.save(session.getConversation()); Map payload = new LinkedHashMap< (); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, reason); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson()); audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload); return new StepResult.Continue(); } } 4 PersistConversationBootstrapStep Responsibility: Ensure conversation row persisted Session Mutations: none/metadata Config/Table Dependencies: ce_conversation Detailed Execution Logic A simple lifecycle checkpoint to ensure the conversation has a createdAt timestamp. If the user session just started in LoadOrCreateConversationStep , this step performs the initial INSERT (ce_conversation) to the database to ensure foreign key dependencies (like audit logs) don't fail later in the loop. return new StepResult.Continue(); } } 5 AuditUserInputStep Responsibility: Persist user input audit Session Mutations: none Config/Table Dependencies: ce_audit Detailed Execution Logic Records the raw text query the user typed on this turn into the ce_audit table. This is purely for debug tracing and business analytics. It binds the USER_INPUT audit stage with the conversation ID and the text payload. } 6 PolicyEnforcementStep Responsibility: Policy block and stop Session Mutations: payload + stop result on block Config/Table Dependencies: ce_policy Detailed Execution Logic Secures the pipeline against prohibited input using ce_policy . It reads all active rows from ce_policy , executing either REGEX , EXACT , or LLM rules against the user's raw text. If a match occurs: The conversation is forced to a \\ BLOCKED\\ status. A StepResult.Stop() is returned immediately, skipping all remaining NLP and intent steps. The ce_policy.response_text is loaded as the final payload shipped back to the consumer. } return new StepResult.Continue(); } } 7 DialogueActStep Responsibility: Classify user turn action type Session Mutations: dialogue_act in input params Config/Table Dependencies: ce_config (dialogue act mode), ce_audit Detailed Execution Logic This step attempts to classify the raw user text into an explicit conversational \"act\" through Regex, and optionally as fallback, a LLM request depending on the strictness of convengine.flow.dialogue act.resolute (e.g., REGEX_THEN_LLM ). Why this step exists: it turns raw free form phrases like yes , go ahead , change amount to 350000 , or start over into stable engine signals downstream steps should not branch on raw text because raw phrasing is inconsistent and expensive to reason about repeatedly it reduces unnecessary intent/schema/LLM work for short operational turns it makes ce_rule conditions deterministic by giving rules normalized fields instead of unstructured user text If convengine.flow.queryRewrite.enabled=true and the conversionHistory is present, the step morphs its LLM request into a dual Classifier & RAG Context Optimizer . It supplies the ongoing conversation to the LLM to rewrite ambiguous pronouns into an explicit standalone search query, returning it as \"standaloneQuery\" . The core parameters for these prompts are dynamically loaded from ce_config , allowing administrators to Hot Swap classifier behaviors in production without recompiling Java arrays. Supported Dialogue Acts | Enum Name | Purpose | | | | | AFFIRM | The user expressed agreement or confirmation (e.g., \"yes\", \"go ahead\"). Can override Guardrails or execute Pending Actions. | | NEGATE | The user expressed rejection or cancellation (e.g., \"no\", \"stop\"). Can cancel active Interaction Policies. | | EDIT | The user wants to change previously supplied context or entity slots. | | RESET | The user wants to clear memory and start completely fresh. | | QUESTION | The user is asking a direct conversational question (triggers fallback intent workflows). | | NEW_REQUEST | The baseline generic classification. Engine routes normally. | | GREETING | The user issued a pleasantry (\"Hi\", \"Hello\"). Typically bypassed by downstream Orchestrators to prevent expensive RAG queries. | Source Execution Profile The runtime still keeps a conservative regex guard for destructive resets. RESET can be forced back to a REGEX_GUARD result when the user text does not clearly match the reset regex. EDIT is no longer globally downgraded in Java. Instead, the engine preserves regex and LLM candidate values, and a POST_DIALOGUE_ACT rule pass can apply a DB driven override using SET_DIALOGUE_ACT when the workflow should trust the LLM candidate. Why POST_DIALOGUE_ACT exists The engine should stay conservative by default, but business workflows still need a safe override point. Examples: user says: Ohh wait, I missed one zero. Change amount to 350000. regex may still classify this as NEW_REQUEST the LLM candidate may classify it as EDIT a POST_DIALOGUE_ACT rule can inspect: inputParams.dialogue_act inputParams.dialogue_act_source inputParams.dialogue_act_llm_candidate inputParams.dialogue_act_llm_standalone_query then use SET_DIALOGUE_ACT to restore EDIT before InteractionPolicyStep This keeps: the default engine behavior safe the override behavior DB driven the state model dynamic instead of hardcoded in Java \"\"\"); // Loads the query rewrite variant QUERY_REWRITE_SYSTEM_PROMPT = configResolver.resolveString(this, \"QUERY_REWRITE_SYSTEM_PROMPT\", \"\"\" You are a dialogue act classifier and intelligent query search rewriter. Using the conversation history, rewrite the user's text into an explicit, standalone query that perfectly describes their intent without needing the conversation history context. Also classify their dialogue act. Return JSON only matching the exact schema. \"\"\"); } @Override public StepResult execute(EngineSession session) // 4. Let DB rules override the guarded result before policy routing rulesStep.applyRules(session, \"DialogueActStep\", RulePhase.POST_DIALOGUE_ACT.name()); return new StepResult.Continue(); } } } 8 InteractionPolicyStep Responsibility: Decide runtime policy before intent Session Mutations: policy_decision, skip_intent_resolution Config/Table Dependencies: ce_config, session pending state Detailed Execution Logic Uses the identified DialogueAct to decide how the engine should route the turn. This step prevents the system from confusing follow up answers (like saying \"yes\") with new intents. Before this step runs, the engine now executes a POST_DIALOGUE_ACT rule pass. That lets DB rules override guarded dialogue act outcomes using the regex result, the LLM candidate result, or the dedicated SET_DIALOGUE_ACT action without hardcoding state names in Java. The output maps to the InteractionPolicyDecision enum: EXECUTE_PENDING_ACTION : If the DialogueAct is AFFIRM and there's a background API task waiting. REJECT_PENDING_ACTION : If NEGATE and an action is waiting. FILL_PENDING_SLOT : If the user is currently answering a schema extraction question. RECLASSIFY_INTENT : If this is a NEW_REQUEST . Evaluation Matrix Flow: 1. Checks for context hints: hasPendingAction , hasPendingSlot , hasResolvedIntent , hasResolvedState . 2. First, it attempts a lookup using the resolveFromMatrix() method against any custom configurations in your YAML properties. 3. If no custom matrix decision applies, it checks boolean flags from the config. isExecutePendingOnAffirm() : If true, AFFIRM + hasPendingAction EXECUTE_PENDING_ACTION isRejectPendingOnNegate() : If true, NEGATE + hasPendingAction REJECT_PENDING_ACTION isFillPendingSlotOnNonNewRequest() : If true, != NEW_REQUEST && != GREETING + hasPendingSlot FILL_PENDING_SLOT 4. Most crucially, if any of these policy decisions trigger, it sets skipIntentResolution = true . This stops Step 11 ( IntentResolutionStep ) from overriding the sticky intent. The payload is attached with POLICY_DECISION . else if (flowConfig.getInteractionPolicy().isExecutePendingOnAffirm() && hasPendingAction && dialogueAct == DialogueAct.AFFIRM) else if (flowConfig.getInteractionPolicy().isRejectPendingOnNegate() && hasPendingAction && dialogueAct == DialogueAct.NEGATE) else if (flowConfig.getInteractionPolicy().isFillPendingSlotOnNonNewRequest() && hasPendingSlot && dialogueAct != DialogueAct.NEW_REQUEST) } session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, decision.name()); session.putInputParam(ConvEngineInputParamKey.SKIP_INTENT_RESOLUTION, skipIntentResolution); Map payload = new LinkedHashMap< (); payload.put(ConvEnginePayloadKey.DIALOGUE_ACT, dialogueAct.name()); payload.put(ConvEnginePayloadKey.POLICY_DECISION, decision.name()); payload.put(ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, skipIntentResolution); payload.put(\"hasPendingAction\", hasPendingAction); payload.put(\"hasPendingSlot\", hasPendingSlot); payload.put(ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(ConvEnginePayloadKey.STATE, session.getState()); audit.audit(ConvEngineAuditStage.INTERACTION_POLICY_DECIDED, session.getConversationId(), payload); return new StepResult.Continue(); } } 9 ActionLifecycleStep Responsibility: Maintain pending action runtime TTL/status Session Mutations: pending_action_runtime context Config/Table Dependencies: ce_pending_action, ce_audit Detailed Execution Logic Tracks time to live (TTL) for CePendingAction rows. If the user was asked \"Are you sure you want to cancel?\" 3 turns ago, but started talking about the weather instead, this step will mark the pending_action_runtime as EXPIRED . Status transitions (Enum PendingActionStatus ): OPEN : Task is created but waiting for user confirmation. IN_PROGRESS : The user affirmed, and the task is ready to execute. REJECTED : The user negated. EXPIRED : The TTL turn limit was reached before the user confirmed. ObjectNode root = contextHelper.readRoot(session); ObjectNode runtime = contextHelper.ensureObject(root, RUNTIME_NODE); int currentTurn = session.conversionHistory().size() + 1; long now = Instant.now().toEpochMilli(); PendingActionStatus currentStatus = PendingActionStatus.from(runtime.path(\"status\").asText(null), null); if (isExpired(runtime, currentTurn, now) && (currentStatus == PendingActionStatus.OPEN || currentStatus == PendingActionStatus.IN_PROGRESS)) String actionKey = resolveActionKey(session); String actionRef = resolveActionReferenceFromTable(session, actionKey); if (actionRef == null || actionRef.isBlank()) boolean isNewRuntime = isRuntimeNew(runtime, actionKey, actionRef); if (isNewRuntime) InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION)); if (decision == InteractionPolicyDecision.EXECUTE_PENDING_ACTION) else if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) contextHelper.writeRoot(session, root); return new StepResult.Continue(); } } 10 DisambiguationStep Responsibility: Ask question when multiple actions fit Session Mutations: pending_clarification question/context Config/Table Dependencies: ce_pending_action, ce_config, ce_audit Detailed Execution Logic A smart conversational router. If multiple pending actions apply to the current context (e.g., \"Cancel flight\" vs \"Cancel hotel\" both valid), it pauses the pipeline. It dynamically builds a multiple choice prompt (or LLM synthesis) asking the user to clarify which action they meant. It emits an ASSISTANT_OUTPUT step, stalling the pipeline until the user clarifies. InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION)); if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION) String explicitActionKey = session.inputParamAsString(ConvEngineInputParamKey.PENDING_ACTION_KEY); if (explicitActionKey != null && !explicitActionKey.isBlank()) List candidates = pendingActionRepository.findEligibleByIntentAndStateOrderByPriorityAsc( session.getIntent(), session.getState() ); if (candidates == null || candidates.size() top = candidates.stream() .filter(c (c.getPriority() == null ? Integer.MAX_VALUE : c.getPriority()) == bestPriority) .toList(); if (top.size() options = new LinkedHashSet< (); for (CePendingAction row : top) String option = row.getActionKey().trim(); if (row.getDescription() != null && !row.getDescription().isBlank()) options.add(option); if (options.size() = Math.max(1, flowConfig.getDisambiguation().getMaxOptions())) } if (options.isEmpty()) QuestionResult questionResult = buildQuestion(session, top, options); String question = questionResult.question(); session.setPendingClarificationQuestion(question); session.setPendingClarificationReason(\"PENDING_ACTION_DISAMBIGUATION\"); session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, InteractionPolicyDecision.RECLASSIFY_INTENT.name()); session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_DISAMBIGUATION_REQUIRED, true); Map payload = new LinkedHashMap< (); payload.put(ConvEnginePayloadKey.REASON, \"MULTIPLE_PENDING_ACTIONS\"); payload.put(ConvEnginePayloadKey.QUESTION, question); payload.put(ConvEnginePayloadKey.CANDIDATE_COUNT, top.size()); payload.put(ConvEnginePayloadKey.OPTIONS, new ArrayList< (options)); payload.put(ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(ConvEnginePayloadKey.STATE, session.getState()); payload.put(ConvEnginePayloadKey.QUESTION_SOURCE, questionResult.source()); audit.audit(ConvEngineAuditStage.DISAMBIGUATION_REQUIRED, session.getConversationId(), payload); return new StepResult.Continue(); } } 11 GuardrailStep Responsibility: Apply guardrails and approval rules Session Mutations: guardrail flags/sanitized text Config/Table Dependencies: ce_config, ce_audit Detailed Execution Logic The last line of defense before intent triggers. Reads the ce_config guardrail thresholds and sanitize instructions. If a command is flagged as \"sensitive\" (e.g., destructive actions like closing an account), it can force an explicit SENSITIVE_ACTION_APPROVAL_REQUIRED pause, blocking the pipeline from executing tasks until MFA or explicit user verification is acquired. String originalUserText = session.getUserText() == null ? \"\" : session.getUserText(); String sanitizedUserText = sanitize(originalUserText); if (flowConfig.getGuardrail().isSanitizeInput()) boolean sensitive = matchesSensitivePattern(sanitizedUserText); boolean approvalRequired = flowConfig.getGuardrail().isRequireApprovalForSensitiveActions() && sensitive; boolean approvalGranted = isApprovalGranted(session); boolean failClosed = flowConfig.getGuardrail().isApprovalGateFailClosed(); boolean denied = approvalRequired && (!approvalGranted || failClosed && !approvalGranted); if (denied) session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_BLOCKED, false); Map payload = new LinkedHashMap< (); payload.put(\"result\", \"ALLOW\"); payload.put(\"sensitive\", sensitive); payload.put(\"approvalRequired\", approvalRequired); payload.put(\"approvalGranted\", approvalGranted); payload.put(\"intent\", session.getIntent()); payload.put(\"state\", session.getState()); audit.audit(ConvEngineAuditStage.GUARDRAIL_ALLOW, session.getConversationId(), payload); return new StepResult.Continue(); } } 12 IntentResolutionStep Responsibility: Resolve intent with classifier+agent Session Mutations: intent/state/clarification fields Config/Table Dependencies: ce_intent, ce_intent_classifier, ce_config Detailed Execution Logic The primary intent matching gateway. Uses the CompositeIntentResolver (which merges Regex, Semantic Search, and LLM classifiers based off ce_intent_classifier ). If the interaction policy decided we are in FILL_PENDING_SLOT mode, this step is bypassed entirely (referred to as a \"Locked Intent\"). Otherwise: Queries ce_intent_classifier for matches. Uses INTENT_RESOLVED audit logs to map the intentCode . Sets the context state to IDLE (or whatever the initial configuration demands). session.clearClarification(); if (session.getConversation() != null) Map payload = new LinkedHashMap< (); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCKED, session.isIntentLocked()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCK_REASON, session.getIntentLockReason()); audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION, session.getConversationId(), payload); return new StepResult.Continue(); } if (shouldSkipResolutionForPolicy(session)) Map payload = new LinkedHashMap< (); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.DIALOGUE_ACT, session.inputParamAsString(ConvEngineInputParamKey.DIALOGUE_ACT)); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.POLICY_DECISION, session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION)); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, true); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, \"policy decision retained existing intent/state\"); audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_POLICY, session.getConversationId(), payload); return new StepResult.Continue(); } if (shouldSkipResolutionForStickyIntent(session)) Map payload = existingIntentRetainedAuditPayload(session); audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_STICKY_INTENT, session.getConversationId(), payload); return new StepResult.Continue(); } CompositeIntentResolver.IntentResolutionResult result = intentResolver.resolveWithTrace(session); if (result == null || result.resolvedIntent() == null) if (!result.resolvedIntent().equals(previousIntent)) session.getConversation().setIntentCode(session.getIntent()); session.getConversation().setStateCode(session.getState()); audit.audit( ConvEngineAuditStage.intentResolvedBy(result.source().name()), session.getConversationId(), result ); return new StepResult.Continue(); } } 13 ResetResolvedIntentStep Responsibility: Reset on configured reset intent Session Mutations: full reset Config/Table Dependencies: ce_config RESET_INTENT_CODES Detailed Execution Logic A quality of life check. If the resolved intent matches one of the RESET_INTENT_CODES configured in Spring configuration (e.g. START_OVER , RESET ), this step immediately executes a session wipe akin to ResetConversationStep , returning the conversation to a clean slate. session.resetForConversationRestart(); session.getConversation().setStatus(\"RUNNING\"); session.getConversation().setIntentCode(\"UNKNOWN\"); session.getConversation().setStateCode(\"UNKNOWN\"); session.getConversation().setContextJson(\" \"); session.getConversation().setInputParamsJson(\" \"); session.getConversation().setLastAssistantJson(null); session.getConversation().setUpdatedAt(OffsetDateTime.now()); conversationRepository.save(session.getConversation()); Map payload = new LinkedHashMap< (); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, \"INTENT_RESOLVED_RESET\"); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.MATCHED_RESET_INTENT_CODES, resetIntentCodes); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson()); audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload); return new StepResult.Continue(); } } 14 FallbackIntentStateStep Responsibility: Fill missing intent/state defaults Session Mutations: intent/state Config/Table Dependencies: none Detailed Execution Logic A safety net. If the classifier fails to return any confidence, or an exception occurred, this step forcibly binds the native engine defaults to UNKNOWN intent and UNKNOWN state so that ce_rule and ce_response tables can still define fallback messaging (e.g., \"I didn't understand that\"). if (session.getState() == null) session.getConversation().setIntentCode(session.getIntent()); session.getConversation().setStateCode(session.getState()); return new StepResult.Continue(); } } 15 AddContainerDataStep Responsibility: Fetch and attach container data Session Mutations: containerData/context merge Config/Table Dependencies: ce_container_config Detailed Execution Logic Bridges static tenant/consumer configurations. Evaluates ce_container_config to pull any global JSON context relevant to the intent and merges it directly into session.contextJson . This allows things like \"Store Hours\" or \"Region Policies\" to be globally attached to all LLM contexts without hardcoding. if (configs.isEmpty()) if (configs.isEmpty()) ObjectNode containerRoot = mapper.createObjectNode(); for (CeContainerConfig cfg : configs) inputParams.put(key, value); if (session.getInputParams() != null) if (session.getEngineContext().getInputParams() != null) PageInfoRequest pageInfo = PageInfoRequest.builder() .userId(\"convengine\") .loggedInUserId(\"convengine\") .pageId(cfg.getPageId()) .sectionId(cfg.getSectionId()) .containerId(cfg.getContainerId()) .inputParams(inputParams) .build(); ContainerComponentRequest req = new ContainerComponentRequest(); req.setPageInfo(List.of(pageInfo)); req.setRequestTypes(List.of(RequestType.CONTAINER)); interceptorExecutor.beforeExecute(req, session); ContainerComponentResponse resp = ccfCoreService.execute(req); resp = interceptorExecutor.afterExecute(resp, session); // find classes with @ContainerDataTransformer(state, intent) to transform resp if needed Map transformedData = transformerService.transformIfApplicable(resp, session, inputParams); JsonNode responseNode = transformedData == null ? mapper.valueToTree(resp) : mapper.valueToTree(transformedData); session.setContainerData(responseNode); containerRoot.set(cfg.getInputParamName(), responseNode); Map jsonMap = Map.of( \"containerId\", cfg.getContainerId(), \"pageId\", cfg.getPageId(), \"sectionId\", cfg.getSectionId(), \"inputParam\", cfg.getInputParamName(), \"requestInput\", inputParams, \"response\", responseNode ); audit.audit( \"CONTAINER_DATA_EXECUTED\", session.getConversationId(), jsonMap ); } catch (Exception e) } if (!containerRoot.isEmpty()) catch (Exception ignore) audit.audit( \"CONTAINER_DATA_ATTACHED\", session.getConversationId(), containerRoot.toString() ); } return new StepResult.Continue(); } } 16 PendingActionStep Responsibility: Execute/reject pending action task Session Mutations: pending_action_runtime status/result Config/Table Dependencies: ce_pending_action, CeTaskExecutor, ce_audit Detailed Execution Logic Executes Java code. If the InteractionPolicy is EXECUTE_PENDING_ACTION and the status is IN_PROGRESS , this step resolves the Spring Bean ID attached to the ce_pending_action row. It invokes CeTaskExecutor.execute() , runs the backend transaction (e.g. Stripe Refund), and captures the boolean/json result back into the engine EngineSession context for downstream rules to evaluate. String decisionRaw = session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION); InteractionPolicyDecision decision = parseDecision(decisionRaw); if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION && decision != InteractionPolicyDecision.REJECT_PENDING_ACTION) Map context = session.contextDict(); Object pendingAction = context.get(\"pending_action\"); if (pendingAction == null) String actionKey = resolveActionKey(session, context, pendingAction); String actionRef = resolveActionReference(session, pendingAction, actionKey); if (actionRef == null || actionRef.isBlank()) if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) String[] taskRef = parseTaskReference(actionRef); if (taskRef == null) Object executionResult = ceTaskExecutor.execute(taskRef[0], taskRef[1], session); if (executionResult == null) session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, \"EXECUTED\"); updateRuntimeStatus(session, PendingActionStatus.EXECUTED); Map payload = basePayload(session, decision, actionRef); payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, \"EXECUTED\"); payload.put(\"taskBean\", taskRef[0]); payload.put(\"taskMethods\", taskRef[1]); audit.audit(ConvEngineAuditStage.PENDING_ACTION_EXECUTED, session.getConversationId(), payload); return new StepResult.Continue(); } } 17 ToolOrchestrationStep Responsibility: Run tool_group based orchestration Session Mutations: tool_request/tool_result fields Config/Table Dependencies: ce_tool, ce_mcp_tool, ce_audit Detailed Execution Logic The gateway for Model Context Protocol (MCP) tooling. If ce_tool specifies that this intent requires a tool_group , this step binds the request and delegates to an external executor. It pauses the LLM, executes the backend SQL or REST fetch, and dumps the massive JSON result into tool_result dictionary in context. if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION))) ToolRequest request = resolveRequest(session); if (request == null) session.putInputParam(ConvEngineInputParamKey.TOOL_REQUEST, request.toMap()); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_REQUEST, session.getConversationId(), request.toMap()); try if (group == null || group.isBlank()) McpToolExecutor executor = resolveExecutor(group); String resultJson = executor.execute(tool, request.args(), session); Map result = new LinkedHashMap< (); result.put(\"status\", \"SUCCESS\"); result.put(\"tool_code\", request.toolCode()); result.put(\"tool_group\", group); result.put(\"result\", parseJsonOrString(resultJson)); session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result); session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, \"SUCCESS\"); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_RESULT, session.getConversationId(), result); rulesStep.applyRules(session, \"ToolOrchestrationStep PostTool\", RulePhase.POST_TOOL_EXECUTION.name()); } catch (IllegalStateException e) Map result = new LinkedHashMap< (); result.put(\"status\", \"ERROR\"); result.put(\"tool_code\", request.toolCode()); result.put(\"tool_group\", request.toolGroup()); result.put(\"error\", String.valueOf(e.getMessage())); session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result); session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, \"ERROR\"); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_ERROR, session.getConversationId(), result); } catch (Exception e) return new StepResult.Continue(); } } 18 McpToolStep Responsibility: MCP planner/tool loop Session Mutations: context_json.mcp. Config/Table Dependencies: ce_mcp_tool, ce_mcp_db_tool, ce_mcp_planner (fallback ce_config) Detailed Execution Logic Specifically iterates over ce_mcp_tool bindings. Instead of static grouped tools, this triggers an agent planner that interprets the input, selects an MCP tool, writes the payload, and executes it. This is the core of dynamic tool use in ConvEngine V2. if (session.hasPendingClarification()) List tools = registry.listEnabledTools(session.getIntent(), session.getState()); if (CollectionUtils.isEmpty(tools)) clearMcpContext(session); List observations = readObservationsFromContext(session); boolean mcpTouched = false; for (int i = 0; i args = (plan.args() == null) ? Map.of() : plan.args(); audit.audit( ConvEngineAuditStage.MCP_TOOL_CALL, session.getConversationId(), mapOf(\"tool_code\", toolCode, \"args\", args) ); CeMcpTool tool = registry.requireTool(toolCode, session.getIntent(), session.getState()); String toolGroup = registry.normalizeToolGroup(tool.getToolGroup()); session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_GROUP, toolGroup); try catch (Exception e) } if (mcpTouched) session.syncToConversation(); return new StepResult.Continue(); } } 19 SchemaExtractionStep Responsibility: Schema driven extraction and lock handling Session Mutations: schema facts/context/lock Config/Table Dependencies: ce_output_schema, ce_prompt_template Detailed Execution Logic Evaluates ce_output_schema . It injects the missing required slots into an LLM extracting prompt using ce_prompt_template . The LLM returns a structured JSON map. This step merges it with session.contextJson . Prompt template usage details: selects ce_prompt_template with response_type=SCHEMA_JSON for the same intent_code + state_code interaction_mode=COLLECT is the recommended semantic marker for these templates interaction_contract can declare expects:[\"structured_input\"] so the template contract remains explicit in configuration after merge, POST_SCHEMA_EXTRACTION rules can move the state or set runtime flags It then runs missingFieldEvaluator.evaluate() . If fields are missing, it sets session.setSchemaLocked(true) . else session.syncFromConversation(true); return new StepResult.Continue(); } } 20 AutoAdvanceStep Responsibility: Compute schema status facts Session Mutations: schemaComplete/hasAny Config/Table Dependencies: resolved schema + context Detailed Execution Logic In V1, rules had to manually check if schema extraction was done. In V2, this step computes the boolean flags schemaComplete and hasAny and binds them to the session context. This allows ce_rule to simply trigger on schemaComplete == true . String schemaJson = session.getResolvedSchema().getJsonSchema(); String contextJson = session.getContextJson(); boolean hasAnySchemaValue = JsonUtil.hasAnySchemaValue(contextJson, schemaJson); boolean schemaComplete = JsonUtil.isSchemaComplete(schemaJson, contextJson); session.setSchemaHasAnyValue(hasAnySchemaValue); session.setSchemaComplete(schemaComplete); Map payload = new LinkedHashMap< (); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_COMPLETE, schemaComplete); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.HAS_ANY_SCHEMA_VALUE, hasAnySchemaValue); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); audit.audit(ConvEngineAuditStage.AUTO_ADVANCE_FACTS, session.getConversationId(), payload); return new StepResult.Continue(); } } 21 RulesStep Responsibility: Match and apply transitions/actions Session Mutations: intent/state/input params Config/Table Dependencies: ce_rule Detailed Execution Logic The core state machine driver. It queries ce_rule for the current Intent and State. It evaluates expressions (like JSON_PATH or REGEX ) against the session.contextJson . If a rule matches, it executes the target action (e.g. SET_STATE to CONFIRMATION , or SET_TASK ). It loops until no more rules match, effectively \"auto advancing\" state machine nodes. } 22 StateGraphStep Responsibility: Validate state transition path Session Mutations: state_graph_valid/reason Config/Table Dependencies: ce_state_graph, ce_audit Detailed Execution Logic A strict validater. Checks ce_state_graph to see if the transition that just occurred in RulesStep was legally defined by the developer. If a rule jumped from IDLE to CANCELLED but there is no edge in the graph, this step logs an error and optionally reverts the state to prevent invalid transitions. String fromState = session.getConversation() == null ? null : session.getConversation().getStateCode(); String toState = session.getState(); if (fromState == null || fromState.isBlank() || toState == null || toState.isBlank() || fromState.equalsIgnoreCase(toState)) boolean allowed = isAllowedTransition(fromState, toState); Map payload = new LinkedHashMap< (); payload.put(\"fromState\", fromState); payload.put(\"toState\", toState); payload.put(\"intent\", session.getIntent()); payload.put(\"validateOnly\", true); if (allowed) payload.put(\"allowed\", false); payload.put(\"softBlock\", flowConfig.getStateGraph().isSoftBlockOnViolation()); audit.audit(ConvEngineAuditStage.STATE_GRAPH_VIOLATION, session.getConversationId(), payload); session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_VALID, false); if (flowConfig.getStateGraph().isSoftBlockOnViolation()) return new StepResult.Continue(); } } 23 ResponseResolutionStep Responsibility: Resolve and generate output payload Session Mutations: payload/last assistant json Config/Table Dependencies: ce_response, ce_prompt_template Detailed Execution Logic The final output generator. Queries ce_response for the current intent and state. If TEXT : Returns a hardcoded string. If DERIVED : Loads ce_prompt_template , injects the contextJson , tool_result , and schema , and asks the LLM to write a fluid, contextual response to the user. interaction_mode does not change template lookup, but it should describe the intended turn semantics for the selected state ( CONFIRM , PROCESSING , FINAL , etc.) interaction_contract is where consumers should declare capabilities such as retry on PROCESSING prompts or affirm/edit on CONFIRM prompts Sets session.getConversation().setLastAssistantJson() with the payload. Optional responseOptional = resolveResponse(session); if(responseOptional.isEmpty()) CeResponse resp = responseOptional.get(); if (!matches(resp.getStateCode(), session.getState()) && !matches(resp.getStateCode(), \"ANY\")) Map responsePayload = new LinkedHashMap< (); responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId()); responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); audit.audit( ConvEngineAuditStage.RESOLVE_RESPONSE, session.getConversationId(), responsePayload ); List conversationTurns = historyProvider.lastTurns(session.getConversationId(), 10); session.setConversationHistory(conversationTurns); CePromptTemplate template = null; if(ResponseType.DERIVED.name().equalsIgnoreCase(resp.getResponseType())) typeFactory .get(resp.getResponseType()) .resolve(session, PromptTemplate.initFrom(template), ResponseTemplate.initFrom(resp)); OutputPayload transformedOutput = responseTransformerService.transformIfApplicable(session.getPayload(), session, session.getInputParams()); session.setPayload(transformedOutput); Object payloadValue = switch (session.getPayload()) ; Map outputPayload = new LinkedHashMap< (); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT, payloadValue); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT_FORMAT, resp.getOutputFormat()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_TYPE, resp.getResponseType()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_JSON, session.schemaJson()); audit.audit(ConvEngineAuditStage.ASSISTANT_OUTPUT, session.getConversationId(), outputPayload); return new StepResult.Continue(); } } 24 MemoryStep Responsibility: Write memory/session summary Session Mutations: memory.session_summary in context Config/Table Dependencies: ce_memory, ce_audit Detailed Execution Logic Evaluates the rolling history. If ce_memory is configured, and recentTurns exceeds the threshold, this step fires off a summarization prompt to the LLM. It compresses the last N turns into a dense paragraph and saves it as memory.session_summary in the context JSON, enabling infinite context retention without blowing up token limits. String recalled = null; for (ConversationMemoryStore store : memoryStores) } catch (Exception ignored) } if (recalled != null) String summary = buildSummary(session); if (summary.length() flowConfig.getMemory().getSummaryMaxChars()) session.putInputParam(ConvEngineInputParamKey.MEMORY_SESSION_SUMMARY, summary); ObjectNode root = contextHelper.readRoot(session); ObjectNode memoryNode = contextHelper.ensureObject(root, \"memory\"); memoryNode.put(\"session_summary\", summary); if (recalled != null) contextHelper.writeRoot(session, root); for (ConversationMemoryStore store : memoryStores) catch (Exception ignored) } Map payload = new LinkedHashMap< (); payload.put(\"summaryChars\", summary.length()); payload.put(\"recalled\", recalled != null); payload.put(\"stores\", memoryStores.size()); payload.put(\"intent\", session.getIntent()); payload.put(\"state\", session.getState()); audit.audit(ConvEngineAuditStage.MEMORY_UPDATED, session.getConversationId(), payload); return new StepResult.Continue(); } } 25 PersistConversationStep Responsibility: Persist final conversation and result Session Mutations: finalResult Config/Table Dependencies: ce_conversation Detailed Execution Logic The database commit step. Writes the CeConversation row, saving the mutated contextJson , inputParams , new intentCode , and stateCode . The step is placed at the end so if an exception occurs mid pipeline, the corrupted context is ignored and rolled back natively. // persist conversation sanitizeConversationForPostgres(session); session.getConversation().setStatus(\"RUNNING\"); session.getConversation().setUpdatedAt(OffsetDateTime.now()); session.getConversation().setInputParamsJson(session.ejectInputParamsJson()); conversationRepo.save(session.getConversation()); // build FINAL EngineResult EngineResult result = new EngineResult( session.getIntent(), session.getState(), session.getPayload(), session.getContextJson() ); session.setFinalResult(result); Map payload = new LinkedHashMap< (); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FINAL_RESULT, result); audit.audit(ConvEngineAuditStage.ENGINE_RETURN, session.getConversationId(), payload); return new StepResult.Continue(); } } 26 PipelineEndGuardStep Responsibility: Timing audit + terminal guard Session Mutations: timings Config/Table Dependencies: ce_audit Detailed Execution Logic Timing and safety metrics. Audits the total millisecond execution time from Step 1 to 25. Fires the PIPELINE_COMPLETE audit log. Verifies that the resulting payload isn't null. total= ms [ ]\", session.getConversationId(), totalMs, timingLine); // Optional audit row (single compact record) String payload = \" \"; audit.audit(ConvEngineAuditStage.PIPELINE_TIMING, session.getConversationId(), payload); return new StepResult.Continue(); } }",
    "rawContent": "# Pipeline Steps (what each step does) <DbTable title=\"Step responsibilities\" columns={[\"Step\", \"Primary responsibility\", \"Main session mutations\", \"Config/table dependencies\"]} rows={[ [\"LoadOrCreateConversationStep\", \"Fetch or bootstrap conversation row\", \"conversation, intent/state/context sync\", \"ce_conversation\"], [\"CacheInspectAuditStep\", \"Conditionally audit cache snapshot\", \"none\", \"convengine.audit.cache-inspector property\"], [\"ResetConversationStep\", \"Early explicit reset\", \"intent/state/context/input params reset\", \"input flags, command text\"], [\"PersistConversationBootstrapStep\", \"Ensure conversation row persisted\", \"none/metadata\", \"ce_conversation\"], [\"AuditUserInputStep\", \"Persist user input audit\", \"none\", \"ce_audit\"], [\"PolicyEnforcementStep\", \"Policy block and stop\", \"payload + stop result on block\", \"ce_policy\"], [\"DialogueActStep\", \"Classify user turn action type\", \"dialogue_act, dialogue_act_confidence, standalone_query, resolved_user_input\", \"ce_config (dialogue act mode), ce_audit\"], [\"InteractionPolicyStep\", \"Decide runtime policy before intent\", \"policy_decision, skip_intent_resolution\", \"ce_config, session pending state\"], [\"CorrectionStep\", \"Route confirmation turns and apply in-place correction patches\", \"routing_decision, skip_schema_extraction, correction_applied\", \"ce_output_schema, session context, ce_audit\"], [\"ActionLifecycleStep\", \"Maintain pending action runtime TTL/status\", \"pending_action_runtime context\", \"ce_pending_action, ce_audit\"], [\"DisambiguationStep\", \"Ask question when multiple actions fit\", \"pending_clarification question/context\", \"ce_pending_action, ce_config, ce_audit\"], [\"GuardrailStep\", \"Apply guardrails and approval rules\", \"guardrail flags/sanitized text\", \"ce_config, ce_audit\"], [\"IntentResolutionStep\", \"Resolve intent with classifier+agent\", \"intent/state/clarification fields\", \"ce_intent, ce_intent_classifier, ce_config\"], [\"ResetResolvedIntentStep\", \"Reset on configured reset intent\", \"full reset\", \"ce_config RESET_INTENT_CODES\"], [\"FallbackIntentStateStep\", \"Fill missing intent/state defaults\", \"intent/state\", \"none\"], [\"AddContainerDataStep\", \"Fetch and attach container data\", \"containerData/context merge\", \"ce_container_config\"], [\"PendingActionStep\", \"Execute/reject pending action task\", \"pending_action_runtime status/result\", \"ce_pending_action, CeTaskExecutor, ce_audit\"], [\"ToolOrchestrationStep\", \"Run tool_group based orchestration\", \"tool_request/tool_result fields\", \"ce_tool, ce_mcp_tool, ce_audit\"], [\"McpToolStep\", \"MCP planner/tool loop\", \"context_json.mcp.*, mcp tool metadata\", \"ce_mcp_tool, ce_mcp_db_tool, ce_mcp_planner (fallback ce_config)\"], [\"SchemaExtractionStep\", \"Schema-driven extraction and lock handling\", \"schema facts/context/lock, POST_SCHEMA_EXTRACTION facts\", \"ce_output_schema, ce_prompt_template\"], [\"AutoAdvanceStep\", \"Compute schema status facts\", \"schemaComplete/hasAny\", \"resolved schema + context\"], [\"RulesStep\", \"Match and apply transitions/actions\", \"intent/state/input params\", \"ce_rule\"], [\"StateGraphStep\", \"Validate state transition path\", \"state_graph_valid/reason\", \"ce_state_graph, ce_audit\"], [\"ResponseResolutionStep\", \"Resolve and generate output payload\", \"payload/last assistant json\", \"ce_response, ce_prompt_template\"], [\"MemoryStep\", \"Write memory/session summary\", \"memory.session_summary in context\", \"ce_memory, ce_audit\"], [\"PersistConversationStep\", \"Persist final conversation and result\", \"finalResult\", \"ce_conversation\"], [\"PipelineEndGuardStep\", \"Timing audit + terminal guard\", \"timings\", \"ce_audit\"], ]} /> :::tip Hook where you need precision - Before schema extraction: normalize inputs - After rules: inspect intent/state transition correctness - Before response resolution: inject display hints ::: <Highlight type=\"info\" title=\"Rule phases\"> Rules execute by phase. Available native phases include PRE_RESPONSE_RESOLUTION , POST_AGENT_INTENT , POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP , POST_AGENT_MCP , and POST_TOOL_EXECUTION . </Highlight> <Highlight type=\"warning\" title=\"Don’t hardcode transitions in steps\"> Prefer transitions in ce_rule unless absolutely framework-level behavior is required. This keeps domain behavior data-driven and testable via audit traces. </Highlight> <Highlight type=\"info\" title=\"Prompt-template interaction metadata\"> ce_prompt_template.interaction_mode and ce_prompt_template.interaction_contract are the preferred turn-semantics contract in v2.0.9+. - SchemaExtractionStep uses the scoped SCHEMA_JSON template for extraction prompts; COLLECT plus expects:[\"structured_input\"] is the recommended shape. - CorrectionStep should rely on the active prompt template semantics ( CONFIRM , PROCESSING , and interaction_contract capabilities such as affirm , edit , retry ) instead of parsing state-name substrings. - ResponseResolutionStep still selects by intent_code + state_code + response_type , but interaction_mode helps document what kind of user interaction that template represents. </Highlight> <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">1</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>LoadOrCreateConversationStep</span> </div> </div> **Responsibility:** Fetch or bootstrap conversation row **Session Mutations:** conversation, intent/state/context sync **Config/Table Dependencies:** ce_conversation <details open> <summary>Detailed Execution Logic</summary> This is the **initial bootstrap step** of the runtime engine. It uses the conversationId provided in the HTTP request to lookup an existing CeConversation row in the Postgres database. If the conversation exists: - The context JSON is hydrated into the runtime EngineSession . - Previous intent and state codes are restored. - All stored memory summaries and pending actions are fetched from the database and loaded into memory. If the conversation is new: - A new CeConversation entity is instantiated. - The intent and state default to UNKNOWN . This ensures that regardless of scale, the API is entirely stateless and can route requests to any pod. <CodeBlockToggle title=\"LoadOrCreateConversationStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/LoadOrCreateConversationStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { UUID id = session.getConversationId(); CeConversation convo = conversationRepo.findById(id).orElseGet(() -> createNewConversation(id, conversationRepo)); convo.setLastUserText(session.getUserText()); convo.setUpdatedAt(OffsetDateTime.now()); session.setConversation(convo); session.syncFromConversation(); return new StepResult.Continue(); } } </CodeBlockToggle> When the LLM path is used, DialogueActStep now audits: - DIALOGUE_ACT_LLM_INPUT - DIALOGUE_ACT_LLM_OUTPUT - DIALOGUE_ACT_LLM_ERROR It still emits the final classification checkpoint as DIALOGUE_ACT_CLASSIFIED . </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">2</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>CacheInspectAuditStep</span> </div> </div> **Responsibility:** Conditionally audit cache snapshot **Session Mutations:** none **Config/Table Dependencies:** convengine.audit.cache-inspector property <details open> <summary>Detailed Execution Logic</summary> Dynamically runs if convengine.audit.cache-inspector is true. It takes a complete JSON snapshot of the hydrated EngineSession conversation cache tree and logs it under the CACHE_INSPECTION priority stage before explicit user input audits are finalized. <CodeBlockToggle title=\"CacheInspectAuditStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/CacheInspectAuditStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(\"cache_snapshot\", objectMapper.valueToTree(session.getConversation())); auditService.audit(ConvEngineAuditStage.CACHE_INSPECTION, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">3</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ResetConversationStep</span> </div> </div> **Responsibility:** Early explicit reset **Session Mutations:** intent/state/context/input params reset **Config/Table Dependencies:** input flags, command text <details open> <summary>Detailed Execution Logic</summary> Checks EngineSession properties to see if an explicit reset has been triggered by the invoking consumer (this is usually passed as a param like _reset=true ). When triggered, it clears: - The intent and state trackers. - The contextJson (wiping all extracted schema facts). - The inputParamsJson . The session is marked as \\ RUNNING\\ again, but completely fresh. An audit event CONVERSATION_RESET is logged. <CodeBlockToggle title=\"ResetConversationStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/ResetConversationStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (!shouldReset(session)) { return new StepResult.Continue(); } String reason = resetReason(session); session.resetForConversationRestart(); session.getConversation().setStatus(\"RUNNING\"); session.getConversation().setIntentCode(\"UNKNOWN\"); session.getConversation().setStateCode(\"UNKNOWN\"); session.getConversation().setContextJson(\"{}\"); session.getConversation().setInputParamsJson(\"{}\"); session.getConversation().setLastAssistantJson(null); session.getConversation().setUpdatedAt(OffsetDateTime.now()); conversationRepository.save(session.getConversation()); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, reason); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson()); audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">4</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PersistConversationBootstrapStep</span> </div> </div> **Responsibility:** Ensure conversation row persisted **Session Mutations:** none/metadata **Config/Table Dependencies:** ce_conversation <details open> <summary>Detailed Execution Logic</summary> A simple lifecycle checkpoint to ensure the conversation has a createdAt timestamp. If the user session just started in LoadOrCreateConversationStep , this step performs the initial INSERT (ce_conversation) to the database to ensure foreign-key dependencies (like audit logs) don't fail later in the loop. <CodeBlockToggle title=\"PersistConversationBootstrapStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/PersistConversationBootstrapStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (session.getConversation().getCreatedAt() == null) { session.getConversation().setCreatedAt(OffsetDateTime.now()); session.getConversation().setUpdatedAt(OffsetDateTime.now()); conversationRepo.save(session.getConversation()); } return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">5</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>AuditUserInputStep</span> </div> </div> **Responsibility:** Persist user input audit **Session Mutations:** none **Config/Table Dependencies:** ce_audit <details open> <summary>Detailed Execution Logic</summary> Records the raw text query the user typed on this turn into the ce_audit table. This is purely for debug tracing and business analytics. It binds the USER_INPUT audit stage with the conversation ID and the text payload. <CodeBlockToggle title=\"AuditUserInputStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/AuditUserInputStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.TEXT, session.getUserText()); audit.audit(ConvEngineAuditStage.USER_INPUT, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">6</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PolicyEnforcementStep</span> </div> </div> **Responsibility:** Policy block and stop **Session Mutations:** payload + stop result on block **Config/Table Dependencies:** ce_policy <details open> <summary>Detailed Execution Logic</summary> Secures the pipeline against prohibited input using ce_policy . It reads all active rows from ce_policy , executing either REGEX , EXACT , or LLM rules against the user's raw text. If a match occurs: - The conversation is forced to a \\ BLOCKED\\ status. - A StepResult.Stop() is returned immediately, skipping all remaining NLP and intent steps. - The ce_policy.response_text is loaded as the final payload shipped back to the consumer. <CodeBlockToggle title=\"PolicyEnforcementStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/PolicyEnforcementStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { String userText = session.getUserText(); for (CePolicy policy : policyRepo.findByEnabledTrueOrderByPriorityAsc()) { if (matches(policy.getRuleType(), policy.getPattern(), userText)) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.POLICY_ID, policy.getPolicyId()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RULE_TYPE, policy.getRuleType()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.PATTERN, policy.getPattern()); audit.audit(ConvEngineAuditStage.POLICY_BLOCK, session.getConversationId(), payload); session.getConversation().setStatus(\"BLOCKED\"); session.getConversation().setLastAssistantJson(jsonText(policy.getResponseText())); session.getConversation().setUpdatedAt(OffsetDateTime.now()); conversationRepo.save(session.getConversation()); EngineResult out = new EngineResult( session.getIntent(), session.getState(), new TextPayload(policy.getResponseText()), session.getContextJson() ); return new StepResult.Stop(out); } } return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">7</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>DialogueActStep</span> </div> </div> **Responsibility:** Classify user turn action type **Session Mutations:** dialogue_act in input params **Config/Table Dependencies:** ce_config (dialogue act mode), ce_audit <details open> <summary>Detailed Execution Logic</summary> This step attempts to classify the raw user text into an explicit conversational \"act\" through Regex, and optionally as fallback, a LLM request depending on the strictness of convengine.flow.dialogue-act.resolute (e.g., REGEX_THEN_LLM ). Why this step exists: - it turns raw free-form phrases like yes , go ahead , change amount to 350000 , or start over into stable engine signals - downstream steps should not branch on raw text because raw phrasing is inconsistent and expensive to reason about repeatedly - it reduces unnecessary intent/schema/LLM work for short operational turns - it makes ce_rule conditions deterministic by giving rules normalized fields instead of unstructured user text If convengine.flow.queryRewrite.enabled=true and the conversionHistory is present, the step morphs its LLM request into a dual **Classifier & RAG Context Optimizer**. It supplies the ongoing conversation to the LLM to rewrite ambiguous pronouns into an explicit standalone search query, returning it as \"standaloneQuery\" . The core parameters for these prompts are dynamically loaded from ce_config , allowing administrators to Hot-Swap classifier behaviors in production without recompiling Java arrays. ### Supported Dialogue Acts | Enum Name | Purpose | |---------------|---------| | AFFIRM | The user expressed agreement or confirmation (e.g., \"yes\", \"go ahead\"). Can override Guardrails or execute Pending Actions. | | NEGATE | The user expressed rejection or cancellation (e.g., \"no\", \"stop\"). Can cancel active Interaction Policies. | | EDIT | The user wants to change previously supplied context or entity slots. | | RESET | The user wants to clear memory and start completely fresh. | | QUESTION | The user is asking a direct conversational question (triggers fallback intent workflows). | | NEW_REQUEST | The baseline generic classification. Engine routes normally. | | GREETING | The user issued a pleasantry (\"Hi\", \"Hello\"). Typically bypassed by downstream Orchestrators to prevent expensive RAG queries. | ### Source Execution Profile <Highlight type=\"tip\" title=\"Regex Guardrails\"> The runtime still keeps a conservative regex guard for destructive resets. RESET can be forced back to a REGEX_GUARD result when the user text does not clearly match the reset regex. EDIT is no longer globally downgraded in Java. Instead, the engine preserves regex and LLM candidate values, and a POST_DIALOGUE_ACT rule pass can apply a DB-driven override using SET_DIALOGUE_ACT when the workflow should trust the LLM candidate. </Highlight> ### Why POST_DIALOGUE_ACT exists The engine should stay conservative by default, but business workflows still need a safe override point. Examples: - user says: Ohh wait, I missed one zero. Change amount to 350000. - regex may still classify this as NEW_REQUEST - the LLM candidate may classify it as EDIT - a POST_DIALOGUE_ACT rule can inspect: - inputParams.dialogue_act - inputParams.dialogue_act_source - inputParams.dialogue_act_llm_candidate - inputParams.dialogue_act_llm_standalone_query - then use SET_DIALOGUE_ACT to restore EDIT before InteractionPolicyStep This keeps: - the default engine behavior safe - the override behavior DB-driven - the state model dynamic instead of hardcoded in Java <CodeBlockToggle title=\"DialogueActStep.java (Simplified)\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/DialogueActStep.java\" defaultOpen={true}> { @MustRunAfter(AuditUserInputStep.class) @MustRunBefore(IntentResolutionStep.class) public class DialogueActStep implements EngineStep { private final ConvEngineFlowConfig flowConfig; private final CeConfigResolver configResolver; // Extracted from ce_config during Application Initialization private Pattern REGEX_GREETING; private Pattern REGEX_AFFIRM; private Pattern REGEX_NEGATE; private String SYSTEM_PROMPT; private String QUERY_REWRITE_SYSTEM_PROMPT; // ... @PostConstruct public void init() { // Core Regex Evaluation Patterns mapped securely in ce_config REGEX_GREETING = Pattern.compile( configResolver.resolveString(this, \"REGEX_GREETING\", \"^(\\\\s)*(hi|hello|hey|greetings|good morning|...)$\"), Pattern.CASE_INSENSITIVE ); // Loads from ce_config where config_type=\"DialogueActStep\" and config_key=\"SYSTEM_PROMPT\". SYSTEM_PROMPT = configResolver.resolveString(this, \"SYSTEM_PROMPT\", \"\"\" You are a dialogue-act classifier. Return JSON only with: {\"dialogueAct\":\"AFFIRM|NEGATE|EDIT|RESET|QUESTION|NEW_REQUEST|GREETING\",\"confidence\":0.0} \"\"\"); // Loads the query-rewrite variant QUERY_REWRITE_SYSTEM_PROMPT = configResolver.resolveString(this, \"QUERY_REWRITE_SYSTEM_PROMPT\", \"\"\" You are a dialogue-act classifier and intelligent query search rewriter. Using the conversation history, rewrite the user's text into an explicit, standalone query that perfectly describes their intent without needing the conversation history context. Also classify their dialogue act. Return JSON only matching the exact schema. \"\"\"); } @Override public StepResult execute(EngineSession session) { String userText = session.getUserText(); // 1. Regex Classification First DialogueActResult regexResult = classifyByRegex(userText); // 2. Resolve final intention while preserving regex + LLM candidates DialogueActResolution resolution = resolveByMode(session, userText, regexResult); DialogueActResult resolved = resolution.resolved(); // 3. Persist regex, LLM candidate, guard metadata, and final decision session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_REGEX, regexResult.act().name()); session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_LLM_CANDIDATE, ...); session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT, resolved.act().name()); session.putInputParam(ConvEngineInputParamKey.DIALOGUE_ACT_CONFIDENCE, resolved.confidence()); if (resolved.standaloneQuery() != null) { session.putInputParam(ConvEngineInputParamKey.STANDALONE_QUERY, resolved.standaloneQuery()); session.setStandaloneQuery(resolved.standaloneQuery()); } // 4. Let DB rules override the guarded result before policy routing rulesStep.applyRules(session, \"DialogueActStep\", RulePhase.POST_DIALOGUE_ACT.name()); return new StepResult.Continue(); } } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">8</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>InteractionPolicyStep</span> </div> </div> **Responsibility:** Decide runtime policy before intent **Session Mutations:** policy_decision, skip_intent_resolution **Config/Table Dependencies:** ce_config, session pending state <details open> <summary>Detailed Execution Logic</summary> Uses the identified DialogueAct to decide how the engine should route the turn. This step prevents the system from confusing follow-up answers (like saying \"yes\") with new intents. Before this step runs, the engine now executes a POST_DIALOGUE_ACT rule pass. That lets DB rules override guarded dialogue-act outcomes using the regex result, the LLM candidate result, or the dedicated SET_DIALOGUE_ACT action without hardcoding state names in Java. The output maps to the InteractionPolicyDecision enum: - ** EXECUTE_PENDING_ACTION **: If the DialogueAct is AFFIRM and there's a background API task waiting. - ** REJECT_PENDING_ACTION **: If NEGATE and an action is waiting. - ** FILL_PENDING_SLOT **: If the user is currently answering a schema extraction question. - ** RECLASSIFY_INTENT **: If this is a NEW_REQUEST . **Evaluation Matrix Flow:** 1. Checks for context hints: hasPendingAction , hasPendingSlot , hasResolvedIntent , hasResolvedState . 2. First, it attempts a lookup using the resolveFromMatrix() method against any custom configurations in your YAML properties. 3. If no custom matrix decision applies, it checks boolean flags from the config. - isExecutePendingOnAffirm() : If true, AFFIRM + hasPendingAction -> EXECUTE_PENDING_ACTION - isRejectPendingOnNegate() : If true, NEGATE + hasPendingAction -> REJECT_PENDING_ACTION - isFillPendingSlotOnNonNewRequest() : If true, != NEW_REQUEST && != GREETING + hasPendingSlot -> FILL_PENDING_SLOT 4. Most crucially, if any of these policy decisions trigger, it sets skipIntentResolution = true . This stops Step 11 ( IntentResolutionStep ) from overriding the sticky intent. The payload is attached with POLICY_DECISION . <CodeBlockToggle title=\"InteractionPolicyStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/InteractionPolicyStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { String dialogueActRaw = session.inputParamAsString(ConvEngineInputParamKey.DIALOGUE_ACT); DialogueAct dialogueAct = parseDialogueAct(dialogueActRaw); Map<String, Object> context = session.contextDict(); Map<String, Object> inputParams = session.getInputParams(); boolean hasPendingAction = hasValue(context.get(\"pending_action\")) || hasValue(context.get(\"pendingAction\")) || hasValue(inputParams.get(\"pending_action\")) || hasValue(inputParams.get(\"pendingAction\")) || hasValue(inputParams.get(ConvEngineInputParamKey.PENDING_ACTION_KEY)) || hasValue(inputParams.get(\"pending_action_task\")) || hasPendingActionFromRegistry(session); boolean hasPendingSlot = hasValue(context.get(\"pending_slot\")) || hasValue(context.get(\"pendingSlot\")); boolean hasResolvedIntent = session.getIntent() != null && !session.getIntent().isBlank() && !\"UNKNOWN\".equalsIgnoreCase(session.getIntent()); boolean hasResolvedState = session.getState() != null && !session.getState().isBlank() && !\"UNKNOWN\".equalsIgnoreCase(session.getState()); boolean requireResolvedIntentAndState = flowConfig.getInteractionPolicy().isRequireResolvedIntentAndState(); boolean hasResolvedContext = !requireResolvedIntentAndState || (hasResolvedIntent && hasResolvedState); InteractionPolicyDecision decision = InteractionPolicyDecision.RECLASSIFY_INTENT; boolean skipIntentResolution = false; if (hasResolvedContext) { InteractionPolicyDecision matrixDecision = resolveFromMatrix(hasPendingAction, hasPendingSlot, dialogueAct); if (matrixDecision != null) { decision = matrixDecision; skipIntentResolution = true; } else if (flowConfig.getInteractionPolicy().isExecutePendingOnAffirm() && hasPendingAction && dialogueAct == DialogueAct.AFFIRM) { decision = InteractionPolicyDecision.EXECUTE_PENDING_ACTION; skipIntentResolution = true; } else if (flowConfig.getInteractionPolicy().isRejectPendingOnNegate() && hasPendingAction && dialogueAct == DialogueAct.NEGATE) { decision = InteractionPolicyDecision.REJECT_PENDING_ACTION; skipIntentResolution = true; } else if (flowConfig.getInteractionPolicy().isFillPendingSlotOnNonNewRequest() && hasPendingSlot && dialogueAct != DialogueAct.NEW_REQUEST) { decision = InteractionPolicyDecision.FILL_PENDING_SLOT; skipIntentResolution = true; } } session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, decision.name()); session.putInputParam(ConvEngineInputParamKey.SKIP_INTENT_RESOLUTION, skipIntentResolution); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(ConvEnginePayloadKey.DIALOGUE_ACT, dialogueAct.name()); payload.put(ConvEnginePayloadKey.POLICY_DECISION, decision.name()); payload.put(ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, skipIntentResolution); payload.put(\"hasPendingAction\", hasPendingAction); payload.put(\"hasPendingSlot\", hasPendingSlot); payload.put(ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(ConvEnginePayloadKey.STATE, session.getState()); audit.audit(ConvEngineAuditStage.INTERACTION_POLICY_DECIDED, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">9</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ActionLifecycleStep</span> </div> </div> **Responsibility:** Maintain pending action runtime TTL/status **Session Mutations:** pending_action_runtime context **Config/Table Dependencies:** ce_pending_action, ce_audit <details open> <summary>Detailed Execution Logic</summary> Tracks time-to-live (TTL) for CePendingAction rows. If the user was asked \"Are you sure you want to cancel?\" 3 turns ago, but started talking about the weather instead, this step will mark the pending_action_runtime as EXPIRED . Status transitions (Enum PendingActionStatus ): - OPEN : Task is created but waiting for user confirmation. - IN_PROGRESS : The user affirmed, and the task is ready to execute. - REJECTED : The user negated. - EXPIRED : The TTL turn limit was reached before the user confirmed. <CodeBlockToggle title=\"ActionLifecycleStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/ActionLifecycleStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (!flowConfig.getActionLifecycle().isEnabled()) { return new StepResult.Continue(); } ObjectNode root = contextHelper.readRoot(session); ObjectNode runtime = contextHelper.ensureObject(root, RUNTIME_NODE); int currentTurn = session.conversionHistory().size() + 1; long now = Instant.now().toEpochMilli(); PendingActionStatus currentStatus = PendingActionStatus.from(runtime.path(\"status\").asText(null), null); if (isExpired(runtime, currentTurn, now) && (currentStatus == PendingActionStatus.OPEN || currentStatus == PendingActionStatus.IN_PROGRESS)) { runtime.put(\"status\", PendingActionStatus.EXPIRED.name()); runtime.put(\"expired_turn\", currentTurn); runtime.put(\"expired_at_epoch_ms\", now); session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.EXPIRED.name()); audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf( \"event\", \"EXPIRED\", \"status\", PendingActionStatus.EXPIRED.name(), \"turn\", currentTurn )); } String actionKey = resolveActionKey(session); String actionRef = resolveActionReferenceFromTable(session, actionKey); if (actionRef == null || actionRef.isBlank()) { contextHelper.writeRoot(session, root); return new StepResult.Continue(); } boolean isNewRuntime = isRuntimeNew(runtime, actionKey, actionRef); if (isNewRuntime) { runtime.put(\"action_key\", actionKey == null ? \"\" : actionKey); runtime.put(\"action_ref\", actionRef); runtime.put(\"status\", PendingActionStatus.OPEN.name()); runtime.put(\"created_turn\", currentTurn); runtime.put(\"created_at_epoch_ms\", now); runtime.put(\"expires_turn\", flowConfig.getActionLifecycle().getTtlTurns() > 0 ? currentTurn + flowConfig.getActionLifecycle().getTtlTurns() : -1); runtime.put(\"expires_at_epoch_ms\", flowConfig.getActionLifecycle().getTtlMinutes() > 0 ? now + (flowConfig.getActionLifecycle().getTtlMinutes() * 60_000L) : -1); session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.OPEN.name()); audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf( \"event\", \"OPEN\", \"status\", PendingActionStatus.OPEN.name(), \"actionKey\", actionKey, \"actionRef\", actionRef )); } InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION)); if (decision == InteractionPolicyDecision.EXECUTE_PENDING_ACTION) { runtime.put(\"status\", PendingActionStatus.IN_PROGRESS.name()); runtime.put(\"in_progress_turn\", currentTurn); runtime.put(\"in_progress_at_epoch_ms\", now); session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.IN_PROGRESS.name()); audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf( \"event\", \"IN_PROGRESS\", \"status\", PendingActionStatus.IN_PROGRESS.name(), \"actionKey\", actionKey, \"actionRef\", actionRef )); } else if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) { runtime.put(\"status\", PendingActionStatus.REJECTED.name()); runtime.put(\"rejected_turn\", currentTurn); runtime.put(\"rejected_at_epoch_ms\", now); session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RUNTIME_STATUS, PendingActionStatus.REJECTED.name()); audit.audit(ConvEngineAuditStage.PENDING_ACTION_LIFECYCLE, session.getConversationId(), mapOf( \"event\", \"REJECTED\", \"status\", PendingActionStatus.REJECTED.name(), \"actionKey\", actionKey, \"actionRef\", actionRef )); } contextHelper.writeRoot(session, root); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">10</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>DisambiguationStep</span> </div> </div> **Responsibility:** Ask question when multiple actions fit **Session Mutations:** pending_clarification question/context **Config/Table Dependencies:** ce_pending_action, ce_config, ce_audit <details open> <summary>Detailed Execution Logic</summary> A smart conversational router. If multiple pending actions apply to the current context (e.g., \"Cancel flight\" vs \"Cancel hotel\" both valid), it pauses the pipeline. It dynamically builds a multiple-choice prompt (or LLM synthesis) asking the user to clarify which action they meant. It emits an ASSISTANT_OUTPUT step, stalling the pipeline until the user clarifies. <CodeBlockToggle title=\"DisambiguationStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/DisambiguationStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (!flowConfig.getDisambiguation().isEnabled()) { return new StepResult.Continue(); } InteractionPolicyDecision decision = parseDecision(session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION)); if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION) { return new StepResult.Continue(); } String explicitActionKey = session.inputParamAsString(ConvEngineInputParamKey.PENDING_ACTION_KEY); if (explicitActionKey != null && !explicitActionKey.isBlank()) { return new StepResult.Continue(); } List<CePendingAction> candidates = pendingActionRepository.findEligibleByIntentAndStateOrderByPriorityAsc( session.getIntent(), session.getState() ); if (candidates == null || candidates.size() <= 1) { return new StepResult.Continue(); } int bestPriority = candidates.getFirst().getPriority() == null ? Integer.MAX_VALUE : candidates.getFirst().getPriority(); List<CePendingAction> top = candidates.stream() .filter(c -> (c.getPriority() == null ? Integer.MAX_VALUE : c.getPriority()) == bestPriority) .toList(); if (top.size() <= 1) { return new StepResult.Continue(); } Set<String> options = new LinkedHashSet<>(); for (CePendingAction row : top) { if (row.getActionKey() == null || row.getActionKey().isBlank()) { continue; } String option = row.getActionKey().trim(); if (row.getDescription() != null && !row.getDescription().isBlank()) { option = option + \" (\" + row.getDescription().trim() + \")\"; } options.add(option); if (options.size() >= Math.max(1, flowConfig.getDisambiguation().getMaxOptions())) { break; } } if (options.isEmpty()) { return new StepResult.Continue(); } QuestionResult questionResult = buildQuestion(session, top, options); String question = questionResult.question(); session.setPendingClarificationQuestion(question); session.setPendingClarificationReason(\"PENDING_ACTION_DISAMBIGUATION\"); session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, InteractionPolicyDecision.RECLASSIFY_INTENT.name()); session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_DISAMBIGUATION_REQUIRED, true); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(ConvEnginePayloadKey.REASON, \"MULTIPLE_PENDING_ACTIONS\"); payload.put(ConvEnginePayloadKey.QUESTION, question); payload.put(ConvEnginePayloadKey.CANDIDATE_COUNT, top.size()); payload.put(ConvEnginePayloadKey.OPTIONS, new ArrayList<>(options)); payload.put(ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(ConvEnginePayloadKey.STATE, session.getState()); payload.put(ConvEnginePayloadKey.QUESTION_SOURCE, questionResult.source()); audit.audit(ConvEngineAuditStage.DISAMBIGUATION_REQUIRED, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">11</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>GuardrailStep</span> </div> </div> **Responsibility:** Apply guardrails and approval rules **Session Mutations:** guardrail flags/sanitized text **Config/Table Dependencies:** ce_config, ce_audit <details open> <summary>Detailed Execution Logic</summary> The last line of defense before intent triggers. Reads the ce_config guardrail thresholds and sanitize instructions. If a command is flagged as \"sensitive\" (e.g., destructive actions like closing an account), it can force an explicit SENSITIVE_ACTION_APPROVAL_REQUIRED pause, blocking the pipeline from executing tasks until MFA or explicit user verification is acquired. <CodeBlockToggle title=\"GuardrailStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/GuardrailStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (!flowConfig.getGuardrail().isEnabled()) { return new StepResult.Continue(); } String originalUserText = session.getUserText() == null ? \"\" : session.getUserText(); String sanitizedUserText = sanitize(originalUserText); if (flowConfig.getGuardrail().isSanitizeInput()) { session.putInputParam(ConvEngineInputParamKey.SANITIZED_USER_TEXT, sanitizedUserText); } boolean sensitive = matchesSensitivePattern(sanitizedUserText); boolean approvalRequired = flowConfig.getGuardrail().isRequireApprovalForSensitiveActions() && sensitive; boolean approvalGranted = isApprovalGranted(session); boolean failClosed = flowConfig.getGuardrail().isApprovalGateFailClosed(); boolean denied = approvalRequired && (!approvalGranted || failClosed && !approvalGranted); if (denied) { session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_BLOCKED, true); session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_REASON, \"SENSITIVE_ACTION_APPROVAL_REQUIRED\"); session.putInputParam(ConvEngineInputParamKey.POLICY_DECISION, InteractionPolicyDecision.RECLASSIFY_INTENT.name()); session.putInputParam(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION, true); session.putInputParam(ConvEngineInputParamKey.SKIP_PENDING_ACTION_EXECUTION, true); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(\"result\", \"DENY\"); payload.put(\"reason\", \"SENSITIVE_ACTION_APPROVAL_REQUIRED\"); payload.put(\"sensitive\", true); payload.put(\"approvalGranted\", approvalGranted); payload.put(\"userText\", sanitizedUserText); payload.put(\"intent\", session.getIntent()); payload.put(\"state\", session.getState()); audit.audit(ConvEngineAuditStage.GUARDRAIL_DENY, session.getConversationId(), payload); return new StepResult.Continue(); } session.putInputParam(ConvEngineInputParamKey.GUARDRAIL_BLOCKED, false); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(\"result\", \"ALLOW\"); payload.put(\"sensitive\", sensitive); payload.put(\"approvalRequired\", approvalRequired); payload.put(\"approvalGranted\", approvalGranted); payload.put(\"intent\", session.getIntent()); payload.put(\"state\", session.getState()); audit.audit(ConvEngineAuditStage.GUARDRAIL_ALLOW, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">12</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>IntentResolutionStep</span> </div> </div> **Responsibility:** Resolve intent with classifier+agent **Session Mutations:** intent/state/clarification fields **Config/Table Dependencies:** ce_intent, ce_intent_classifier, ce_config <details open> <summary>Detailed Execution Logic</summary> The primary intent matching gateway. Uses the CompositeIntentResolver (which merges Regex, Semantic Search, and LLM classifiers based off ce_intent_classifier ). If the interaction policy decided we are in FILL_PENDING_SLOT mode, this step is bypassed entirely (referred to as a \"Locked Intent\"). Otherwise: - Queries ce_intent_classifier for matches. - Uses INTENT_RESOLVED audit logs to map the intentCode . - Sets the context state to IDLE (or whatever the initial configuration demands). <CodeBlockToggle title=\"IntentResolutionStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/IntentResolutionStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { String previousIntent = session.getIntent(); Map<String, Object> startPayload = new LinkedHashMap<>(); startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.PREVIOUS_INTENT, previousIntent); startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCKED, session.isIntentLocked()); startPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCK_REASON, session.getIntentLockReason()); audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_START, session.getConversationId(), startPayload); if (session.isIntentLocked() || isActiveSchemaCollection(session)) { if (!session.isIntentLocked()) { session.lockIntent(\"SCHEMA_INCOMPLETE\"); } session.clearClarification(); if (session.getConversation() != null) { session.getConversation().setIntentCode(session.getIntent()); session.getConversation().setStateCode(session.getState()); } Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCKED, session.isIntentLocked()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT_LOCK_REASON, session.getIntentLockReason()); audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION, session.getConversationId(), payload); return new StepResult.Continue(); } if (shouldSkipResolutionForPolicy(session)) { if (session.getConversation() != null) { session.getConversation().setIntentCode(session.getIntent()); session.getConversation().setStateCode(session.getState()); } Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.DIALOGUE_ACT, session.inputParamAsString(ConvEngineInputParamKey.DIALOGUE_ACT)); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.POLICY_DECISION, session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION)); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SKIP_INTENT_RESOLUTION, true); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, \"policy decision retained existing intent/state\"); audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_POLICY, session.getConversationId(), payload); return new StepResult.Continue(); } if (shouldSkipResolutionForStickyIntent(session)) { if (session.getConversation() != null) { session.getConversation().setIntentCode(session.getIntent()); session.getConversation().setStateCode(session.getState()); } Map<String, Object> payload = existingIntentRetainedAuditPayload(session); audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_SKIPPED_STICKY_INTENT, session.getConversationId(), payload); return new StepResult.Continue(); } CompositeIntentResolver.IntentResolutionResult result = intentResolver.resolveWithTrace(session); if (result == null || result.resolvedIntent() == null) { audit.audit(ConvEngineAuditStage.INTENT_RESOLVE_NO_CHANGE, session.getConversationId(), Map.of()); return new StepResult.Continue(); } if (!result.resolvedIntent().equals(previousIntent)) { session.setIntent(result.resolvedIntent()); } session.getConversation().setIntentCode(session.getIntent()); session.getConversation().setStateCode(session.getState()); audit.audit( ConvEngineAuditStage.intentResolvedBy(result.source().name()), session.getConversationId(), result ); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">13</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ResetResolvedIntentStep</span> </div> </div> **Responsibility:** Reset on configured reset intent **Session Mutations:** full reset **Config/Table Dependencies:** ce_config RESET_INTENT_CODES <details open> <summary>Detailed Execution Logic</summary> A quality of life check. If the resolved intent matches one of the RESET_INTENT_CODES configured in Spring configuration (e.g. START_OVER , RESET ), this step immediately executes a session wipe akin to ResetConversationStep , returning the conversation to a clean slate. <CodeBlockToggle title=\"ResetResolvedIntentStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/ResetResolvedIntentStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { String intent = session.getIntent(); if (intent == null || !resetIntentCodes.contains(intent.trim().toUpperCase())) { return new StepResult.Continue(); } session.resetForConversationRestart(); session.getConversation().setStatus(\"RUNNING\"); session.getConversation().setIntentCode(\"UNKNOWN\"); session.getConversation().setStateCode(\"UNKNOWN\"); session.getConversation().setContextJson(\"{}\"); session.getConversation().setInputParamsJson(\"{}\"); session.getConversation().setLastAssistantJson(null); session.getConversation().setUpdatedAt(OffsetDateTime.now()); conversationRepository.save(session.getConversation()); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, \"INTENT_RESOLVED_RESET\"); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.MATCHED_RESET_INTENT_CODES, resetIntentCodes); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.getContextJson()); audit.audit(ConvEngineAuditStage.CONVERSATION_RESET, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">14</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>FallbackIntentStateStep</span> </div> </div> **Responsibility:** Fill missing intent/state defaults **Session Mutations:** intent/state **Config/Table Dependencies:** none <details open> <summary>Detailed Execution Logic</summary> A safety net. If the classifier fails to return any confidence, or an exception occurred, this step forcibly binds the native engine defaults to UNKNOWN intent and UNKNOWN state so that ce_rule and ce_response tables can still define fallback messaging (e.g., \"I didn't understand that\"). <CodeBlockToggle title=\"FallbackIntentStateStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/FallbackIntentStateStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (session.getIntent() == null) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.USER_TEXT, session.getUserText()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FALLBACK_INTENT, fallbackIntent); audit.audit(ConvEngineAuditStage.INTENT_MISSING, session.getConversationId(), payload); session.setIntent(fallbackIntent); } if (session.getState() == null) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.USER_TEXT, session.getUserText()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FALLBACK_STATE, fallbackState); audit.audit(ConvEngineAuditStage.STATE_MISSING, session.getConversationId(), payload); session.setState(fallbackState); } session.getConversation().setIntentCode(session.getIntent()); session.getConversation().setStateCode(session.getState()); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">15</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>AddContainerDataStep</span> </div> </div> **Responsibility:** Fetch and attach container data **Session Mutations:** containerData/context merge **Config/Table Dependencies:** ce_container_config <details open> <summary>Detailed Execution Logic</summary> Bridges static tenant/consumer configurations. Evaluates ce_container_config to pull any global JSON context relevant to the intent and merges it directly into session.contextJson . This allows things like \"Store Hours\" or \"Region Policies\" to be globally attached to all LLM contexts without hardcoding. <CodeBlockToggle title=\"AddContainerDataStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/AddContainerDataStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { List<CeContainerConfig> configs = containerConfigRepo.findByIntentAndState( session.getIntent(), session.getState() ); if (configs.isEmpty()) { configs = containerConfigRepo.findFallbackByState(session.getState()); } if (configs.isEmpty()) { configs = containerConfigRepo.findGlobalFallback(); } if (configs.isEmpty()) { Map<String, Object> reasonMap = new HashMap<>(); reasonMap.put(\"reason\", \"no container configs for intent/state\"); reasonMap.put(\"intent\", session.getIntent()); reasonMap.put(\"state\", session.getState()); audit.audit( \"CONTAINER_DATA_SKIPPED\", session.getConversationId(), reasonMap ); return new StepResult.Continue(); } ObjectNode containerRoot = mapper.createObjectNode(); for (CeContainerConfig cfg : configs) { try { Map<String, Object> inputParams = new HashMap<>(); String key = cfg.getInputParamName(); Object value = session.extractValueFromContext(key); if(value == null) { value = session.getUserText(); } inputParams.put(key, value); if (session.getInputParams() != null) { inputParams.putAll(session.getInputParams()); } if (session.getEngineContext().getInputParams() != null) { inputParams.putAll(session.getEngineContext().getInputParams()); } PageInfoRequest pageInfo = PageInfoRequest.builder() .userId(\"convengine\") .loggedInUserId(\"convengine\") .pageId(cfg.getPageId()) .sectionId(cfg.getSectionId()) .containerId(cfg.getContainerId()) .inputParams(inputParams) .build(); ContainerComponentRequest req = new ContainerComponentRequest(); req.setPageInfo(List.of(pageInfo)); req.setRequestTypes(List.of(RequestType.CONTAINER)); interceptorExecutor.beforeExecute(req, session); ContainerComponentResponse resp = ccfCoreService.execute(req); resp = interceptorExecutor.afterExecute(resp, session); // find classes with @ContainerDataTransformer(state, intent) to transform resp if needed Map<String, Object> transformedData = transformerService.transformIfApplicable(resp, session, inputParams); JsonNode responseNode = transformedData == null ? mapper.valueToTree(resp) : mapper.valueToTree(transformedData); session.setContainerData(responseNode); containerRoot.set(cfg.getInputParamName(), responseNode); Map<String, Object> jsonMap = Map.of( \"containerId\", cfg.getContainerId(), \"pageId\", cfg.getPageId(), \"sectionId\", cfg.getSectionId(), \"inputParam\", cfg.getInputParamName(), \"requestInput\", inputParams, \"response\", responseNode ); audit.audit( \"CONTAINER_DATA_EXECUTED\", session.getConversationId(), jsonMap ); } catch (Exception e) { Map<String, Object> errorJsonMap = new HashMap<>(); errorJsonMap.put(\"containerId\", cfg.getContainerId()); errorJsonMap.put(\"error\", e.getMessage()); audit.audit( \"CONTAINER_DATA_FAILED\", session.getConversationId(), errorJsonMap ); } } if (!containerRoot.isEmpty()) { // attach to session session.setContainerDataJson(containerRoot.toString()); session.setHasContainerData(true); // merge into conversation context try { ObjectNode ctx = (ObjectNode) mapper.readTree(session.getContextJson()); ctx.set(\"container_data\", containerRoot); session.setContextJson(mapper.writeValueAsString(ctx)); session.getConversation().setContextJson(session.getContextJson()); } catch (Exception ignore) { // context merge failure should not break pipeline } audit.audit( \"CONTAINER_DATA_ATTACHED\", session.getConversationId(), containerRoot.toString() ); } return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">16</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PendingActionStep</span> </div> </div> **Responsibility:** Execute/reject pending action task **Session Mutations:** pending_action_runtime status/result **Config/Table Dependencies:** ce_pending_action, CeTaskExecutor, ce_audit <details open> <summary>Detailed Execution Logic</summary> Executes Java code. If the InteractionPolicy is EXECUTE_PENDING_ACTION and the status is IN_PROGRESS , this step resolves the Spring Bean ID attached to the ce_pending_action row. It invokes CeTaskExecutor.execute() , runs the backend transaction (e.g. Stripe Refund), and captures the boolean/json result back into the engine EngineSession context for downstream rules to evaluate. <CodeBlockToggle title=\"PendingActionStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/PendingActionStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_PENDING_ACTION_EXECUTION)) || Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.GUARDRAIL_BLOCKED))) { Map<String, Object> payload = basePayload(session, InteractionPolicyDecision.RECLASSIFY_INTENT, null); payload.put(ConvEnginePayloadKey.REASON, \"pending action skipped by guardrail\"); audit.audit(ConvEngineAuditStage.PENDING_ACTION_SKIPPED, session.getConversationId(), payload); return new StepResult.Continue(); } String decisionRaw = session.inputParamAsString(ConvEngineInputParamKey.POLICY_DECISION); InteractionPolicyDecision decision = parseDecision(decisionRaw); if (decision != InteractionPolicyDecision.EXECUTE_PENDING_ACTION && decision != InteractionPolicyDecision.REJECT_PENDING_ACTION) { return new StepResult.Continue(); } Map<String, Object> context = session.contextDict(); Object pendingAction = context.get(\"pending_action\"); if (pendingAction == null) { pendingAction = context.get(\"pendingAction\"); } String actionKey = resolveActionKey(session, context, pendingAction); String actionRef = resolveActionReference(session, pendingAction, actionKey); if (actionRef == null || actionRef.isBlank()) { Map<String, Object> payload = basePayload(session, decision, null); payload.put(\"actionKey\", actionKey); payload.put(ConvEnginePayloadKey.REASON, actionKey == null || actionKey.isBlank() ? \"pending action reference not found or ambiguous registry mapping\" : \"pending action reference not found\"); audit.audit(ConvEngineAuditStage.PENDING_ACTION_SKIPPED, session.getConversationId(), payload); return new StepResult.Continue(); } if (decision == InteractionPolicyDecision.REJECT_PENDING_ACTION) { session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, \"REJECTED\"); updateRuntimeStatus(session, PendingActionStatus.REJECTED); Map<String, Object> payload = basePayload(session, decision, actionRef); payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, \"REJECTED\"); audit.audit(ConvEngineAuditStage.PENDING_ACTION_REJECTED, session.getConversationId(), payload); return new StepResult.Continue(); } String[] taskRef = parseTaskReference(actionRef); if (taskRef == null) { session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, \"FAILED\"); Map<String, Object> payload = basePayload(session, decision, actionRef); payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, \"FAILED\"); payload.put(ConvEnginePayloadKey.REASON, \"invalid pending action reference\"); audit.audit(ConvEngineAuditStage.PENDING_ACTION_FAILED, session.getConversationId(), payload); return new StepResult.Continue(); } Object executionResult = ceTaskExecutor.execute(taskRef[0], taskRef[1], session); if (executionResult == null) { session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, \"FAILED\"); Map<String, Object> payload = basePayload(session, decision, actionRef); payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, \"FAILED\"); payload.put(ConvEnginePayloadKey.REASON, \"task execution returned null\"); audit.audit(ConvEngineAuditStage.PENDING_ACTION_FAILED, session.getConversationId(), payload); return new StepResult.Continue(); } session.putInputParam(ConvEngineInputParamKey.PENDING_ACTION_RESULT, \"EXECUTED\"); updateRuntimeStatus(session, PendingActionStatus.EXECUTED); Map<String, Object> payload = basePayload(session, decision, actionRef); payload.put(ConvEnginePayloadKey.PENDING_ACTION_RESULT, \"EXECUTED\"); payload.put(\"taskBean\", taskRef[0]); payload.put(\"taskMethods\", taskRef[1]); audit.audit(ConvEngineAuditStage.PENDING_ACTION_EXECUTED, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">17</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ToolOrchestrationStep</span> </div> </div> **Responsibility:** Run tool_group based orchestration **Session Mutations:** tool_request/tool_result fields **Config/Table Dependencies:** ce_tool, ce_mcp_tool, ce_audit <details open> <summary>Detailed Execution Logic</summary> The gateway for Model Context Protocol (MCP) tooling. If ce_tool specifies that this intent requires a tool_group , this step binds the request and delegates to an external executor. It pauses the LLM, executes the backend SQL or REST fetch, and dumps the massive JSON result into tool_result dictionary in context. <CodeBlockToggle title=\"ToolOrchestrationStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/ToolOrchestrationStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (!flowConfig.getToolOrchestration().isEnabled()) { return new StepResult.Continue(); } if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION))) { return new StepResult.Continue(); } ToolRequest request = resolveRequest(session); if (request == null) { return new StepResult.Continue(); } session.putInputParam(ConvEngineInputParamKey.TOOL_REQUEST, request.toMap()); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_REQUEST, session.getConversationId(), request.toMap()); try { CeMcpTool tool = request.toolCode() == null || request.toolCode().isBlank() ? null : registry.requireTool(request.toolCode(), session.getIntent(), session.getState()); String group = request.toolGroup(); if ((group == null || group.isBlank()) && tool != null) { group = registry.normalizeToolGroup(tool.getToolGroup()); } if (group == null || group.isBlank()) { throw new IllegalStateException(\"tool_group is required when tool_code is not resolvable\"); } McpToolExecutor executor = resolveExecutor(group); String resultJson = executor.execute(tool, request.args(), session); Map<String, Object> result = new LinkedHashMap<>(); result.put(\"status\", \"SUCCESS\"); result.put(\"tool_code\", request.toolCode()); result.put(\"tool_group\", group); result.put(\"result\", parseJsonOrString(resultJson)); session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result); session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, \"SUCCESS\"); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_RESULT, session.getConversationId(), result); rulesStep.applyRules(session, \"ToolOrchestrationStep PostTool\", RulePhase.POST_TOOL_EXECUTION.name()); } catch (IllegalStateException e) { if (e.getMessage() != null && e.getMessage().contains(\"Missing enabled MCP tool for current intent/state\")) { Map<String, Object> result = new LinkedHashMap<>(); result.put(\"status\", \"SKIPPED_SCOPE_MISMATCH\"); result.put(\"tool_code\", request.toolCode()); result.put(\"tool_group\", request.toolGroup()); result.put(\"intent\", session.getIntent()); result.put(\"state\", session.getState()); session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result); session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, \"SKIPPED_SCOPE_MISMATCH\"); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_RESULT, session.getConversationId(), result); return new StepResult.Continue(); } Map<String, Object> result = new LinkedHashMap<>(); result.put(\"status\", \"ERROR\"); result.put(\"tool_code\", request.toolCode()); result.put(\"tool_group\", request.toolGroup()); result.put(\"error\", String.valueOf(e.getMessage())); session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result); session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, \"ERROR\"); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_ERROR, session.getConversationId(), result); } catch (Exception e) { Map<String, Object> result = new LinkedHashMap<>(); result.put(\"status\", \"ERROR\"); result.put(\"tool_code\", request.toolCode()); result.put(\"tool_group\", request.toolGroup()); result.put(\"error\", String.valueOf(e.getMessage())); session.putInputParam(ConvEngineInputParamKey.TOOL_RESULT, result); session.putInputParam(ConvEngineInputParamKey.TOOL_STATUS, \"ERROR\"); audit.audit(ConvEngineAuditStage.TOOL_ORCHESTRATION_ERROR, session.getConversationId(), result); } return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">18</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>McpToolStep</span> </div> </div> **Responsibility:** MCP planner/tool loop **Session Mutations:** context_json.mcp.* **Config/Table Dependencies:** ce_mcp_tool, ce_mcp_db_tool, ce_mcp_planner (fallback ce_config) <details open> <summary>Detailed Execution Logic</summary> Specifically iterates over ce_mcp_tool bindings. Instead of static grouped tools, this triggers an agent planner that interprets the input, selects an MCP tool, writes the payload, and executes it. This is the core of dynamic tool use in ConvEngine V2. <CodeBlockToggle title=\"McpToolStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/McpToolStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.SKIP_TOOL_EXECUTION)) || Boolean.TRUE.equals(session.getInputParams().get(ConvEngineInputParamKey.GUARDRAIL_BLOCKED))) { session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, \"SKIPPED_BY_GUARDRAIL\"); return new StepResult.Continue(); } if (session.hasPendingClarification()) { audit.audit( ConvEngineAuditStage.MCP_SKIPPED_PENDING_CLARIFICATION, session.getConversationId(), mapOf( \"intent\", session.getIntent(), \"state\", session.getState() ) ); return new StepResult.Continue(); } List<CeMcpTool> tools = registry.listEnabledTools(session.getIntent(), session.getState()); if (CollectionUtils.isEmpty(tools)) { session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, \"NO_TOOLS_FOR_SCOPE\"); audit.audit(ConvEngineAuditStage.MCP_NO_TOOLS_AVAILABLE, session.getConversationId(), mapOf(\"intent\", session.getIntent(), \"state\", session.getState())); return new StepResult.Continue(); } clearMcpContext(session); List<McpObservation> observations = readObservationsFromContext(session); boolean mcpTouched = false; for (int i = 0; i < MAX_LOOPS; i++) { McpPlan plan = planner.plan(session, tools, observations); mcpTouched = true; session.putInputParam(ConvEngineInputParamKey.MCP_ACTION, plan.action()); session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_CODE, plan.tool_code()); session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_ARGS, plan.args() == null ? Map.of() : plan.args()); if (\"ANSWER\".equalsIgnoreCase(plan.action())) { // store final answer in contextJson; your ResponseResolutionStep can use it via derivation_hint writeFinalAnswerToContext(session, plan.answer()); session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, plan.answer() == null ? \"\" : plan.answer()); session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, \"ANSWER\"); audit.audit( ConvEngineAuditStage.MCP_FINAL_ANSWER, session.getConversationId(), mapOf(\"answer\", plan.answer()) ); break; } if (!\"CALL_TOOL\".equalsIgnoreCase(plan.action())) { writeFinalAnswerToContext(session, \"I couldn't decide the next tool step safely.\"); session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, \"I couldn't decide the next tool step safely.\"); session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, \"FALLBACK\"); break; } String toolCode = plan.tool_code(); Map<String, Object> args = (plan.args() == null) ? Map.of() : plan.args(); audit.audit( ConvEngineAuditStage.MCP_TOOL_CALL, session.getConversationId(), mapOf(\"tool_code\", toolCode, \"args\", args) ); CeMcpTool tool = registry.requireTool(toolCode, session.getIntent(), session.getState()); String toolGroup = registry.normalizeToolGroup(tool.getToolGroup()); session.putInputParam(ConvEngineInputParamKey.MCP_TOOL_GROUP, toolGroup); try { McpToolExecutor executor = resolveExecutor(toolGroup); String rowsJson = executor.execute(tool, args, session); observations.add(new McpObservation(toolCode, rowsJson)); writeObservationsToContext(session, observations); session.putInputParam(ConvEngineInputParamKey.MCP_OBSERVATIONS, observations); session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, \"TOOL_RESULT\"); audit.audit( ConvEngineAuditStage.MCP_TOOL_RESULT, session.getConversationId(), mapOf(\"tool_code\", toolCode, \"tool_group\", toolGroup, \"rows\", rowsJson) ); } catch (Exception e) { audit.audit( ConvEngineAuditStage.MCP_TOOL_ERROR, session.getConversationId(), mapOf(\"tool_code\", toolCode, \"tool_group\", toolGroup, \"error\", String.valueOf(e.getMessage())) ); writeFinalAnswerToContext(session, \"Tool execution failed safely. Can you narrow the request?\"); session.putInputParam(ConvEngineInputParamKey.MCP_FINAL_ANSWER, \"Tool execution failed safely. Can you narrow the request?\"); session.putInputParam(ConvEngineInputParamKey.MCP_STATUS, \"TOOL_ERROR\"); break; } } if (mcpTouched) { rulesStep.applyRules(session, \"McpToolStep\", RulePhase.POST_AGENT_MCP.name()); } session.syncToConversation(); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">19</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>SchemaExtractionStep</span> </div> </div> **Responsibility:** Schema-driven extraction and lock handling **Session Mutations:** schema facts/context/lock **Config/Table Dependencies:** ce_output_schema, ce_prompt_template <details open> <summary>Detailed Execution Logic</summary> Evaluates ce_output_schema . It injects the missing required slots into an LLM extracting prompt using ce_prompt_template . The LLM returns a structured JSON map. This step merges it with session.contextJson . Prompt-template usage details: - selects ce_prompt_template with response_type=SCHEMA_JSON for the same intent_code + state_code - interaction_mode=COLLECT is the recommended semantic marker for these templates - interaction_contract can declare expects:[\"structured_input\"] so the template contract remains explicit in configuration - after merge, POST_SCHEMA_EXTRACTION rules can move the state or set runtime flags It then runs missingFieldEvaluator.evaluate() . If fields are missing, it sets session.setSchemaLocked(true) . <CodeBlockToggle title=\"SchemaExtractionStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/SchemaExtractionStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { String intent = session.getIntent(); String state = session.getState(); CeOutputSchema schema = outputSchemaRepo.findAll().stream() .filter(s -> Boolean.TRUE.equals(s.getEnabled())) .filter(s -> equalsIgnoreCase(s.getIntentCode(), intent)) .filter(s -> equalsIgnoreCase(s.getStateCode(), state) || equalsIgnoreCase(s.getStateCode(), \"ANY\")) .min((a, b) -> Integer.compare(priorityOf(a), priorityOf(b))) .orElse(null); if (schema != null) { runExtraction(session, schema); } else { session.unlockIntent(); session.setResolvedSchema(null); session.setSchemaComplete(false); session.setSchemaHasAnyValue(false); session.setMissingRequiredFields(new ArrayList<>()); session.setMissingFieldOptions(new LinkedHashMap<>()); session.addPromptTemplateVars(); } session.syncFromConversation(true); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">20</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>AutoAdvanceStep</span> </div> </div> **Responsibility:** Compute schema status facts **Session Mutations:** schemaComplete/hasAny **Config/Table Dependencies:** resolved schema + context <details open> <summary>Detailed Execution Logic</summary> In V1, rules had to manually check if schema extraction was done. In V2, this step computes the boolean flags schemaComplete and hasAny and binds them to the session context. This allows ce_rule to simply trigger on schemaComplete == true . <CodeBlockToggle title=\"AutoAdvanceStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/AutoAdvanceStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (session.getResolvedSchema() == null) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.REASON, \"no schema resolved\"); audit.audit(ConvEngineAuditStage.AUTO_ADVANCE_SKIPPED_NO_SCHEMA, session.getConversationId(), payload); return new StepResult.Continue(); } String schemaJson = session.getResolvedSchema().getJsonSchema(); String contextJson = session.getContextJson(); boolean hasAnySchemaValue = JsonUtil.hasAnySchemaValue(contextJson, schemaJson); boolean schemaComplete = JsonUtil.isSchemaComplete(schemaJson, contextJson); session.setSchemaHasAnyValue(hasAnySchemaValue); session.setSchemaComplete(schemaComplete); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_COMPLETE, schemaComplete); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.HAS_ANY_SCHEMA_VALUE, hasAnySchemaValue); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); audit.audit(ConvEngineAuditStage.AUTO_ADVANCE_FACTS, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">21</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>RulesStep</span> </div> </div> **Responsibility:** Match and apply transitions/actions **Session Mutations:** intent/state/input params **Config/Table Dependencies:** ce_rule <details open> <summary>Detailed Execution Logic</summary> The core state-machine driver. It queries ce_rule for the current Intent and State. It evaluates expressions (like JSON_PATH or REGEX ) against the session.contextJson . If a rule matches, it executes the target action (e.g. SET_STATE to CONFIRMATION , or SET_TASK ). It loops until no more rules match, effectively \"auto-advancing\" state machine nodes. <CodeBlockToggle title=\"RulesStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/RulesStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { applyRules(session, \"RulesStep\", RulePhase.PRE_RESPONSE_RESOLUTION.name()); session.syncToConversation(); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">22</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>StateGraphStep</span> </div> </div> **Responsibility:** Validate state transition path **Session Mutations:** state_graph_valid/reason **Config/Table Dependencies:** ce_state_graph, ce_audit <details open> <summary>Detailed Execution Logic</summary> A strict validater. Checks ce_state_graph to see if the transition that just occurred in RulesStep was legally defined by the developer. If a rule jumped from IDLE to CANCELLED but there is no edge in the graph, this step logs an error and optionally reverts the state to prevent invalid transitions. <CodeBlockToggle title=\"StateGraphStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/StateGraphStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (!flowConfig.getStateGraph().isEnabled()) { return new StepResult.Continue(); } String fromState = session.getConversation() == null ? null : session.getConversation().getStateCode(); String toState = session.getState(); if (fromState == null || fromState.isBlank() || toState == null || toState.isBlank() || fromState.equalsIgnoreCase(toState)) { return new StepResult.Continue(); } boolean allowed = isAllowedTransition(fromState, toState); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(\"fromState\", fromState); payload.put(\"toState\", toState); payload.put(\"intent\", session.getIntent()); payload.put(\"validateOnly\", true); if (allowed) { session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_VALID, true); payload.put(\"allowed\", true); audit.audit(ConvEngineAuditStage.STATE_GRAPH_VALID, session.getConversationId(), payload); return new StepResult.Continue(); } payload.put(\"allowed\", false); payload.put(\"softBlock\", flowConfig.getStateGraph().isSoftBlockOnViolation()); audit.audit(ConvEngineAuditStage.STATE_GRAPH_VIOLATION, session.getConversationId(), payload); session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_VALID, false); if (flowConfig.getStateGraph().isSoftBlockOnViolation()) { session.putInputParam(ConvEngineInputParamKey.STATE_GRAPH_SOFT_BLOCK, true); } return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">23</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>ResponseResolutionStep</span> </div> </div> **Responsibility:** Resolve and generate output payload **Session Mutations:** payload/last assistant json **Config/Table Dependencies:** ce_response, ce_prompt_template <details open> <summary>Detailed Execution Logic</summary> The final output generator. Queries ce_response for the current intent and state. - If TEXT : Returns a hardcoded string. - If DERIVED : Loads ce_prompt_template , injects the contextJson , tool_result , and schema , and asks the LLM to write a fluid, contextual response to the user. - interaction_mode does not change template lookup, but it should describe the intended turn semantics for the selected state ( CONFIRM , PROCESSING , FINAL , etc.) - interaction_contract is where consumers should declare capabilities such as retry on PROCESSING prompts or affirm/edit on CONFIRM prompts Sets session.getConversation().setLastAssistantJson() with the payload. <CodeBlockToggle title=\"ResponseResolutionStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/ResponseResolutionStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if(AgentIntentResolver.INTENT_COLLISION_STATE.equals(session.getState())) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); audit.audit( ConvEngineAuditStage.INTENT_COLLISION_DETECTED, session.getConversationId(), payload ); agentIntentCollisionResolver.resolve(session); return new StepResult.Continue(); } Optional<CeResponse> responseOptional = resolveResponse(session); if(responseOptional.isEmpty()) { Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); audit.audit( ConvEngineAuditStage.RESPONSE_MAPPING_NOT_FOUND, session.getConversationId(), payload ); throw new ConversationEngineException( ConversationEngineErrorCode.RESPONSE_MAPPING_NOT_FOUND, \"No response found for intent=\" + session.getIntent() + \", state=\" + session.getState() ); } CeResponse resp = responseOptional.get(); if (!matches(resp.getStateCode(), session.getState()) && !matches(resp.getStateCode(), \"ANY\")) { session.setState(resp.getStateCode()); session.getConversation().setStateCode(resp.getStateCode()); } Map<String, Object> responsePayload = new LinkedHashMap<>(); responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId()); responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); responsePayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); audit.audit( ConvEngineAuditStage.RESOLVE_RESPONSE, session.getConversationId(), responsePayload ); List<ConversationTurn> conversationTurns = historyProvider.lastTurns(session.getConversationId(), 10); session.setConversationHistory(conversationTurns); CePromptTemplate template = null; if(ResponseType.DERIVED.name().equalsIgnoreCase(resp.getResponseType())) { template = promptRepo.findAll().stream() .filter(t -> Boolean.TRUE.equals(t.getEnabled())) .filter(t -> resp.getOutputFormat().equalsIgnoreCase(t.getResponseType())) .filter(t -> matchesOrNull(t.getIntentCode(), session.getIntent())) .filter(t -> matchesOrNull(t.getStateCode(), session.getState()) || matches(t.getStateCode(), \"ANY\")) .max(Comparator.comparingInt(t -> score(t, session))) .orElseThrow(() -> new IllegalStateException( \"No ce_prompt_template found for response_type=\" + resp.getOutputFormat() + \", intent=\" + session.getIntent() + \", state=\" + session.getState() ) ); } typeFactory .get(resp.getResponseType()) .resolve(session, PromptTemplate.initFrom(template), ResponseTemplate.initFrom(resp)); OutputPayload transformedOutput = responseTransformerService.transformIfApplicable(session.getPayload(), session, session.getInputParams()); session.setPayload(transformedOutput); Object payloadValue = switch (session.getPayload()) { case TextPayload(String text) -> text; case JsonPayload(String json) -> json; case null -> null; }; Map<String, Object> outputPayload = new LinkedHashMap<>(); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT, payloadValue); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.OUTPUT_FORMAT, resp.getOutputFormat()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_TYPE, resp.getResponseType()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.RESPONSE_ID, resp.getResponseId()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.CONTEXT, session.contextDict()); outputPayload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.SCHEMA_JSON, session.schemaJson()); audit.audit(ConvEngineAuditStage.ASSISTANT_OUTPUT, session.getConversationId(), outputPayload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">24</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>MemoryStep</span> </div> </div> **Responsibility:** Write memory/session summary **Session Mutations:** memory.session_summary in context **Config/Table Dependencies:** ce_memory, ce_audit <details open> <summary>Detailed Execution Logic</summary> Evaluates the rolling history. If ce_memory is configured, and recentTurns exceeds the threshold, this step fires off a summarization prompt to the LLM. It compresses the last N turns into a dense paragraph and saves it as memory.session_summary in the context JSON, enabling infinite-context retention without blowing up token limits. <CodeBlockToggle title=\"MemoryStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/MemoryStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { if (!flowConfig.getMemory().isEnabled()) { return new StepResult.Continue(); } String recalled = null; for (ConversationMemoryStore store : memoryStores) { try { String value = store.read(session); if (value != null && !value.isBlank()) { recalled = value; break; } } catch (Exception ignored) { } } if (recalled != null) { session.putInputParam(ConvEngineInputParamKey.MEMORY_RECALL, recalled); } String summary = buildSummary(session); if (summary.length() > flowConfig.getMemory().getSummaryMaxChars()) { summary = summary.substring(0, flowConfig.getMemory().getSummaryMaxChars()); } session.putInputParam(ConvEngineInputParamKey.MEMORY_SESSION_SUMMARY, summary); ObjectNode root = contextHelper.readRoot(session); ObjectNode memoryNode = contextHelper.ensureObject(root, \"memory\"); memoryNode.put(\"session_summary\", summary); if (recalled != null) { memoryNode.put(\"recalled_summary\", recalled); } contextHelper.writeRoot(session, root); for (ConversationMemoryStore store : memoryStores) { try { store.write(session, summary); } catch (Exception ignored) { } } Map<String, Object> payload = new LinkedHashMap<>(); payload.put(\"summaryChars\", summary.length()); payload.put(\"recalled\", recalled != null); payload.put(\"stores\", memoryStores.size()); payload.put(\"intent\", session.getIntent()); payload.put(\"state\", session.getState()); audit.audit(ConvEngineAuditStage.MEMORY_UPDATED, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">25</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PersistConversationStep</span> </div> </div> **Responsibility:** Persist final conversation and result **Session Mutations:** finalResult **Config/Table Dependencies:** ce_conversation <details open> <summary>Detailed Execution Logic</summary> The database commit step. Writes the CeConversation row, saving the mutated contextJson , inputParams , new intentCode , and stateCode . The step is placed at the end so if an exception occurs mid-pipeline, the corrupted context is ignored and rolled back natively. <CodeBlockToggle title=\"PersistConversationStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/PersistConversationStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { // --- sanity check --- if (session.getPayload() == null) { throw new ConversationEngineException( ConversationEngineErrorCode.PIPELINE_NO_RESPONSE_PAYLOAD, \"Engine pipeline ended without payload. ResponseResolutionStep did not run.\" ); } // --- persist conversation --- sanitizeConversationForPostgres(session); session.getConversation().setStatus(\"RUNNING\"); session.getConversation().setUpdatedAt(OffsetDateTime.now()); session.getConversation().setInputParamsJson(session.ejectInputParamsJson()); conversationRepo.save(session.getConversation()); // --- build FINAL EngineResult --- EngineResult result = new EngineResult( session.getIntent(), session.getState(), session.getPayload(), session.getContextJson() ); session.setFinalResult(result); Map<String, Object> payload = new LinkedHashMap<>(); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.INTENT, session.getIntent()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.STATE, session.getState()); payload.put(com.github.salilvnair.convengine.engine.constants.ConvEnginePayloadKey.FINAL_RESULT, result); audit.audit(ConvEngineAuditStage.ENGINE_RETURN, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> --- <div className=\"ce-step-badge-list\" role=\"list\" style={{ marginBottom: '1rem' }}> <div className=\"ce-step-badge-item\"> <span className=\"ce-step-badge-index\">26</span> <span className=\"ce-step-badge-label\" style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>PipelineEndGuardStep</span> </div> </div> **Responsibility:** Timing audit + terminal guard **Session Mutations:** timings **Config/Table Dependencies:** ce_audit <details open> <summary>Detailed Execution Logic</summary> Timing and safety metrics. Audits the total millisecond execution time from Step 1 to 25. Fires the PIPELINE_COMPLETE audit log. Verifies that the resulting payload isn't null. <CodeBlockToggle title=\"PipelineEndGuardStep.execute()\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/PipelineEndGuardStep.java\" defaultOpen={true}> { public StepResult execute(EngineSession session) { // Sort by start time just in case session.getStepTimings().sort(Comparator.comparingLong(StepTiming::getStartedAtNs)); long totalMs = session.getStepTimings().stream().mapToLong(StepTiming::getDurationMs).sum(); // Log in app logs String timingLine = session.getStepTimings().stream() .map(t -> t.getStepName() + \"=\" + t.getDurationMs() + \"ms\" + (t.isSuccess() ? \"\" : \"(ERR)\")) .reduce((a, b) -> a + \", \" + b) .orElse(\"\"); log.info(\"ConvEngine timings convId={} total={}ms [{}]\", session.getConversationId(), totalMs, timingLine); // Optional audit row (single compact record) String payload = \"{\\\"totalMs\\\":\" + totalMs + \",\\\"steps\\\":\\\"\" + JsonUtil.escape(timingLine) + \"\\\"}\"; audit.audit(ConvEngineAuditStage.PIPELINE_TIMING, session.getConversationId(), payload); return new StepResult.Continue(); } } </CodeBlockToggle> </details> ---",
    "excerpt": "Pipeline Steps (what each step does) :::tip Hook where you need precision Before schema extraction: normalize inputs After rules: inspect intent/state transition correctness Before response resolution: inject display hin…"
  },
  {
    "id": "deep-dive/request-lifecycle.mdx",
    "version": "v2",
    "title": "request lifecycle",
    "permalink": "/docs/v2/deep-dive/request-lifecycle",
    "content": ", , , , , , , , , , , , , , , , , , , , , , , , , , , ]; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , , , , , , , , , ]; api: , engine: , session: , pipeline: , s1: , s2: , s3: , s4: , s5: , s6: , s7: , s8: , s9: , s10: , out: , }; Request Lifecycle (IDE Debug Mode) This page is the runtime control flow view for one turn. Think of it as stepping through breakpoints from API entry to final persistence. Canonical step inventory (latest) The visual flow highlights the common deterministic runtime path. Conditional/system steps from the list above still execute when their prerequisites are met. Engine\" default // orderByDag uses @MustRunAfter, @MustRunBefore, @RequiresConversationPersisted // wrapWithTiming adds STEP_ENTER / STEP_EXIT / STEP_ERROR audits + hook callbacks } } return session.getFinalResult(); } default void beforeStep(EngineStep.Name stepName, EngineSession session) default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) } } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } Table Touch Matrix Start at IntentResolutionStep , then click SchemaExtractionStep and RulesStep in the tree. That path explains most multi turn behavior differences.",
    "rawContent": "{ name: \"LoadOrCreateConversationStep\", description: \"Hydrates existing conversation or creates new conversation shell.\" }, { name: \"CacheInspectAuditStep\", description: \"Conditionally audits cache snapshot when cache-inspector enabled.\" }, { name: \"ResetConversationStep\", description: \"Applies reset/start-over command handling.\" }, { name: \"PersistConversationBootstrapStep\", description: \"Persists conversation bootstrap row before persisted-required steps.\" }, { name: \"AuditUserInputStep\", description: \"Writes raw user input audit event.\" }, { name: \"PolicyEnforcementStep\", description: \"Applies pre-intent policy checks and safe short-circuit when required.\" }, { name: \"DialogueActStep\", description: \"Classifies turn as AFFIRM/NEGATE/ANSWER/EDIT/RESET/QUESTION/NEW_REQUEST and can derive standalone_query.\" }, { name: \"InteractionPolicyStep\", description: \"Decides EXECUTE_PENDING_ACTION / REJECT_PENDING_ACTION / FILL_PENDING_SLOT / RECLASSIFY_INTENT.\" }, { name: \"CorrectionStep\", description: \"Applies confirmation routing and in-place schema correction before intent/schema rework.\" }, { name: \"ActionLifecycleStep\", description: \"Maintains pending_action_runtime status with TTL semantics.\" }, { name: \"DisambiguationStep\", description: \"When multiple actions are eligible, asks targeted clarification and pauses execution.\" }, { name: \"GuardrailStep\", description: \"Sanitization + sensitive checks + approval gate hooks.\" }, { name: \"IntentResolutionStep\", description: \"Resolves intent unless policy says skip_intent_resolution.\" }, { name: \"ResetResolvedIntentStep\", description: \"Applies post-intent reset mapping.\" }, { name: \"FallbackIntentStateStep\", description: \"Assigns fallback UNKNOWN flow when intent/state unresolved.\" }, { name: \"AddContainerDataStep\", description: \"Merges configured container data into runtime context.\" }, { name: \"PendingActionStep\", description: \"Executes or rejects pending action task via CeTaskExecutor.\" }, { name: \"ToolOrchestrationStep\", description: \"Unified tool request->execute->result contract by tool_group.\" }, { name: \"McpToolStep\", description: \"Planner loop for CALL_TOOL/ANSWER with MCP observations.\" }, { name: \"SchemaExtractionStep\", description: \"Parses/extracts structured schema fields.\" }, { name: \"AutoAdvanceStep\", description: \"Advances state when schema/task facts satisfy conditions.\" }, { name: \"RulesStep\", description: \"Runs phase-scoped rules and actions with cascade passes.\" }, { name: \"StateGraphStep\", description: \"Validate-only transition check, no forced state mutation.\" }, { name: \"ResponseResolutionStep\", description: \"Resolves EXACT/DERIVED response output.\" }, { name: \"MemoryStep\", description: \"Writes session summary and optional recall memory.\" }, { name: \"PersistConversationStep\", description: \"Persists conversation/result/audit metadata.\" }, { name: \"PipelineEndGuardStep\", description: \"Final guard and timing closure.\" }, ]; { id: \"api\", position: { x: 20, y: 40 }, data: { label: \"API: ConversationController.message\" } }, { id: \"engine\", position: { x: 300, y: 40 }, data: { label: \"DefaultConversationalEngine.process\" } }, { id: \"session\", position: { x: 580, y: 40 }, data: { label: \"EngineSessionFactory.open\" } }, { id: \"pipeline\", position: { x: 860, y: 40 }, data: { label: \"EnginePipelineFactory.create\" } }, { id: \"s1\", position: { x: 20, y: 190 }, data: { label: \"LoadOrCreateConversationStep\" } }, { id: \"s1a\", position: { x: 140, y: 190 }, data: { label: \"CacheInspectAuditStep\" } }, { id: \"s2\", position: { x: 260, y: 190 }, data: { label: \"ResetConversationStep\" } }, { id: \"s3\", position: { x: 500, y: 190 }, data: { label: \"AuditUserInputStep\" } }, { id: \"s4\", position: { x: 740, y: 190 }, data: { label: \"IntentResolutionStep\" } }, { id: \"s5\", position: { x: 980, y: 190 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"s6\", position: { x: 20, y: 340 }, data: { label: \"AutoAdvanceStep\" } }, { id: \"s7\", position: { x: 260, y: 340 }, data: { label: \"RulesStep\" } }, { id: \"s8\", position: { x: 500, y: 340 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"s9\", position: { x: 740, y: 340 }, data: { label: \"PersistConversationStep\" } }, { id: \"s10\", position: { x: 980, y: 340 }, data: { label: \"PipelineEndGuardStep\" } }, { id: \"out\", position: { x: 500, y: 500 }, data: { label: \"EngineResult -> HTTP Response\" } }, ]; { id: \"e1\", source: \"api\", target: \"engine\" }, { id: \"e2\", source: \"engine\", target: \"session\" }, { id: \"e3\", source: \"session\", target: \"pipeline\" }, { id: \"e4\", source: \"pipeline\", target: \"s1\" }, { id: \"e4a\", source: \"s1\", target: \"s1a\" }, { id: \"e4b\", source: \"s1a\", target: \"s2\" }, { id: \"e5\", source: \"s2\", target: \"s3\" }, { id: \"e7\", source: \"s3\", target: \"s4\" }, { id: \"e8\", source: \"s4\", target: \"s5\" }, { id: \"e9\", source: \"s5\", target: \"s6\" }, { id: \"e10\", source: \"s6\", target: \"s7\" }, { id: \"e11\", source: \"s7\", target: \"s8\" }, { id: \"e12\", source: \"s8\", target: \"s9\" }, { id: \"e13\", source: \"s9\", target: \"s10\" }, { id: \"e14\", source: \"s10\", target: \"out\" }, ]; api: { title: \"ConversationController.message\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Reads request body, normalizes inputParams, injects reset flag when needed, builds EngineContext and delegates to engine.process.\", session: [\"conversationId maybe provided or generated\", \"userText from request.message\", \"inputParams merged\"], tables: [\"none\"], }, engine: { title: \"DefaultConversationalEngine.process\", file: \"engine/provider/DefaultConversationalEngine.java\", method: \"process(EngineContext)\", stage: \"ENGINE_ENTRY\", summary: \"Opens EngineSession, loads conversation history provider data, executes pipeline, returns EngineResult.\", session: [\"session created\", \"conversationHistory injected\"], tables: [\"ce_audit (indirect via steps)\", \"ce_conversation (indirect via steps)\"], }, session: { title: \"EngineSessionFactory.open\", file: \"engine/factory/EngineSessionFactory.java\", method: \"open(EngineContext)\", stage: \"SESSION_BOOTSTRAP\", summary: \"Ensures conversation bootstrap row exists, attaches it into session, syncs state/intent/context/input params.\", session: [\"conversation object attached\", \"intent/state/context synced from DB\"], tables: [\"ce_conversation (R/W bootstrap)\"], }, pipeline: { title: \"EnginePipelineFactory.create\", file: \"engine/factory/EnginePipelineFactory.java\", method: \"orderByDag(...) + wrapWithTiming(...)\", stage: \"PIPELINE_BUILD\", summary: \"Resolves step DAG by annotations, wraps each step in timing/audit/hook-aware wrapper.\", session: [\"none (topology build)\"], tables: [\"none\"], }, s1: { title: \"LoadOrCreateConversationStep.execute\", file: \"engine/steps/LoadOrCreateConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Loads/syncs conversation row into session and keeps runtime state consistent.\", session: [\"conversation synchronized\", \"state available for next steps\"], tables: [\"ce_conversation (R/W)\"], }, s2: { title: \"ResetConversationStep.execute\", file: \"engine/steps/ResetConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Checks reset controls ( reset , restart , conversation_reset , command text). If triggered, wipes conversation runtime state.\", session: [\"intent/state/context reset conditionally\", \"input controls filtered\"], tables: [\"ce_conversation (W)\", \"ce_audit (CONVERSATION_RESET)\"], }, s3: { title: \"AuditUserInputStep.execute\", file: \"engine/steps/AuditUserInputStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Writes compact user input audit record with session meta intent/state.\", session: [\"user input captured\"], tables: [\"ce_audit (W)\"], }, s4: { title: \"IntentResolutionStep.execute\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Resolves intent using classifier + agent flow, with schema lock checks and collision handling.\", session: [\"intent maybe changed\", \"state may become INTENT_COLLISION\"], tables: [\"ce_intent (R)\", \"ce_intent_classifier (R)\", \"ce_config (R)\", \"ce_audit (W)\"], }, s5: { title: \"SchemaExtractionStep.execute\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Finds schema by intent/state, renders prompt template, calls LLM JSON extraction, merges context, computes missing fields, locks/unlocks intent.\", session: [\"contextJson merged\", \"schemaComplete/schemaHasAnyValue flags\", \"missing fields/options\"], tables: [\"ce_output_schema (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\", \"ce_config (R optional)\"], }, s6: { title: \"AutoAdvanceStep.execute\", file: \"engine/steps/AutoAdvanceStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Applies deterministic state changes from schema facts before rules run.\", session: [\"state may auto-transition\"], tables: [\"ce_audit (W)\"], }, s7: { title: \"RulesStep.execute\", file: \"engine/steps/RulesStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Runs enabled rules in priority order with multi-pass cascading when intent/state changes.\", session: [\"intent/state/context/inputParams may mutate via actions\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"], }, s8: { title: \"ResponseResolutionStep.execute\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Selects response mapping, executes EXACT/DERIVED strategy, resolves templates for derived output, applies transformers, audits output.\", session: [\"payload set\", \"finalResult staged\"], tables: [\"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"], }, s9: { title: \"PersistConversationStep.execute\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Persists final conversation state and last assistant payload to durable row.\", session: [\"conversation row synchronized with runtime\"], tables: [\"ce_conversation (W)\", \"ce_audit (W optional)\"], }, s10: { title: \"PipelineEndGuardStep.execute\", file: \"engine/steps/PipelineEndGuardStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Final guard/timing stage, emits pipeline timing audit and closes execution envelope.\", session: [\"step timings finalized\"], tables: [\"ce_audit (W)\"], }, out: { title: \"EngineResult return\", file: \"api/controller/ConversationController.java\", method: \"message(...) return\", stage: \"HTTP_RESPONSE\", summary: \"Controller maps EngineResult to API response payload type (TEXT/JSON) and returns to client.\", session: [\"final result exposed\"], tables: [\"none\"], }, }; # Request Lifecycle (IDE Debug Mode) This page is the runtime control-flow view for one turn. Think of it as stepping through breakpoints from API entry to final persistence. ## Canonical step inventory (latest) <PipelineStepList ariaLabel=\"Canonical step inventory\" steps={v2PipelineSteps} /> <Highlight type=\"tip\" title=\"Graph below is the common path\"> The visual flow highlights the common deterministic runtime path. Conditional/system steps from the list above still execute when their prerequisites are met. </Highlight> <EngineDebugFlow title=\"Request Turn Execution Graph\" subtitle=\"Click any node in tree or graph to inspect method-level detail, session snapshots, and table touch points.\" nodes={lifecycleNodes} edges={lifecycleEdges} detailsById={lifecycleDetails} defaultSelectedId=\"s4\" /> <Tabs groupId=\"lifecycle-code\"> <TabItem value=\"entry\" label=\"Controller -> Engine\" default> <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.api.controller\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\" > { EngineContext engineContext = EngineContext.builder() .conversationId(conversationId.toString()) .userText(request.getMessage()) .inputParams(inputParams) .build(); EngineResult result = engine.process(engineContext); } </CodeBlockToggle> <CodeBlockToggle title=\"DefaultConversationalEngine.process\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" > { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } </CodeBlockToggle> </TabItem> <TabItem value=\"pipeline\" label=\"DAG + Step Wrapper\"> <CodeBlockToggle title=\"EnginePipelineFactory.orderByDag + wrapWithTiming\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.factory\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/factory/EnginePipelineFactory.java\" > { @PostConstruct public void init() { List<EngineStep> ordered = orderByDag(discoveredSteps); this.pipeline = new EnginePipeline(wrapWithTiming(ordered)); } // orderByDag uses @MustRunAfter, @MustRunBefore, @RequiresConversationPersisted // wrapWithTiming adds STEP_ENTER / STEP_EXIT / STEP_ERROR audits + hook callbacks } </CodeBlockToggle> <CodeBlockToggle title=\"EnginePipeline.execute\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java\" > { for (EngineStep step : steps) { StepResult r = step.execute(session); if (r instanceof StepResult.Stop(EngineResult result)) { return result; } } return session.getFinalResult(); } </CodeBlockToggle> </TabItem> <TabItem value=\"hooks\" label=\"Step Hook Interception\"> <CodeBlockToggle title=\"EngineStepHook typed step matching\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.hook\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/hook/EngineStepHook.java\" > { public interface EngineStepHook { default boolean supports(EngineStep.Name stepName, EngineSession session) { return true; } default void beforeStep(EngineStep.Name stepName, EngineSession session) {} default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) {} default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) {} } } </CodeBlockToggle> <CodeBlockToggle title=\"Consumer hook example\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\" > { @Component public class MyHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName; } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"consumer_hint\", \"compact\"); } } } </CodeBlockToggle> </TabItem> </Tabs> ## Table Touch Matrix <DbTable title=\"Per-turn table access\" columns={[\"Table\", \"Read Path\", \"Write Path\"]} rows={[ [\"ce_conversation\", \"LoadOrCreateConversationStep\", \"PersistConversationStep / reset steps\"], [\"ce_intent\", \"IntentResolutionStep\", \"-\"], [\"ce_intent_classifier\", \"IntentResolutionStep\", \"-\"], [\"ce_output_schema\", \"SchemaExtractionStep\", \"-\"], [\"ce_prompt_template\", \"SchemaExtractionStep / ResponseResolutionStep\", \"-\"], [\"ce_rule\", \"RulesStep\", \"-\"], [\"ce_response\", \"ResponseResolutionStep\", \"-\"], [\"ce_config\", \"intent/reset/sql-agent config lookup\", \"-\"], [\"ce_mcp_planner\", \"McpToolStep planner prompt lookup (with ce_config fallback)\", \"-\"], [\"ce_audit\", \"-\", \"all stage audits via DbAuditService\"], ]} /> <Highlight type=\"info\" title=\"How to read this page\"> Start at IntentResolutionStep , then click SchemaExtractionStep and RulesStep in the tree. That path explains most multi-turn behavior differences. </Highlight>",
    "excerpt": ", , , , , , , , , , , , , , , , , , , , , , , , , , , ]; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }…"
  },
  {
    "id": "deep-dive/rules-responses.mdx",
    "version": "v2",
    "title": "rules responses",
    "permalink": "/docs/v2/deep-dive/rules-responses",
    "content": "Rules and Response Resolution Rule phases ce_rule.phase supports: POST_DIALOGUE_ACT PRE_RESPONSE_RESOLUTION POST_AGENT_INTENT POST_SCHEMA_EXTRACTION PRE_AGENT_MCP POST_AGENT_MCP POST_TOOL_EXECUTION RulesStep writes phase/source/origin metadata into input params and audit payload for every pass. ce_rule.action supports: SET_INTENT SET_STATE SET_DIALOGUE_ACT SET_JSON GET_CONTEXT GET_SCHEMA_JSON GET_SESSION SET_TASK SET_INPUT_PARAM Why POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP both matter Use the two phases for different boundaries: POST_SCHEMA_EXTRACTION : immediate shaping right after schema merge and schema completeness recompute PRE_AGENT_MCP : last deterministic gate before planner/tool execution starts Typical confirmation first flow: 1. POST_SCHEMA_EXTRACTION sees schemaComplete=true 2. rule sets state=CONFIRMATION 3. optional SET_INPUT_PARAM writes awaiting_confirmation=true and confirmation_key=... 4. user responds with AFFIRM / EDIT 5. POST_DIALOGUE_ACT can use SET_DIALOGUE_ACT if the final guarded act should be overridden before policy routing 6. CorrectionStep sets runtime flags such as routing_decision or correction_applied 7. PRE_AGENT_MCP checks those flags and decides whether MCP should start Rule matching behavior For each pass: 1. fetch by phase + session state 2. check intent ( ANY /blank/null supported) 3. check state ( ANY /blank/null supported) 4. evaluate type resolver ( EXACT , REGEX , JSON_PATH ) 5. execute action resolver 6. rerun pass if intent/state changed (max pass cap) Audit emitted for both outcomes: RULE_MATCH (AgentIntentResolver) RULE_NO_MATCH (AgentIntentResolver) RULE_MATCH (RulesStep) RULE_NO_MATCH (RulesStep) RULE_MATCH (McpToolStep) RULE_NO_MATCH (McpToolStep) RULE_APPLIED (...) is additionally emitted when action execution mutates/executes the matched rule. Response resolution behavior ResponseResolutionStep : 1. selects response template by intent/state/priority 2. resolves output format 3. emits RESOLVE_RESPONSE audit stages 4. writes final payload ( EXACT or DERIVED ) SET_INPUT_PARAM patterns Use SET_INPUT_PARAM when you need lightweight runtime variables persisted in inputParams instead of writing custom Java. Do not write ce_rule against raw “yes”, “go ahead”, or “confirm” text. Use DialogueActStep ( AFFIRM / NEGATE ) plus a scoped runtime flag such as awaiting_confirmation or confirmation_key . Operational guidance Keep fallback state responses ( ANY / UNKNOWN ) for safety paths. Keep at least one response for each terminal state. Use phase scoped rules instead of overloading one monolithic PRE_RESPONSE_RESOLUTION pass. Use SET_INPUT_PARAM when you need deterministic runtime flags without hardcoding more Java branching. For confirmation flows, combine DialogueActStep + CorrectionStep + SET_INPUT_PARAM rather than rerunning full schema extraction on every turn. When guarded dialogue act output needs a DB driven override, use POST_DIALOGUE_ACT + SET_DIALOGUE_ACT instead of hardcoding workflow state names in Java.",
    "rawContent": "# Rules and Response Resolution ## Rule phases ce_rule.phase supports: - POST_DIALOGUE_ACT - PRE_RESPONSE_RESOLUTION - POST_AGENT_INTENT - POST_SCHEMA_EXTRACTION - PRE_AGENT_MCP - POST_AGENT_MCP - POST_TOOL_EXECUTION RulesStep writes phase/source/origin metadata into input params and audit payload for every pass. ce_rule.action supports: - SET_INTENT - SET_STATE - SET_DIALOGUE_ACT - SET_JSON - GET_CONTEXT - GET_SCHEMA_JSON - GET_SESSION - SET_TASK - SET_INPUT_PARAM ## Why POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP both matter Use the two phases for different boundaries: - POST_SCHEMA_EXTRACTION : immediate shaping right after schema merge and schema-completeness recompute - PRE_AGENT_MCP : last deterministic gate before planner/tool execution starts Typical confirmation-first flow: 1. POST_SCHEMA_EXTRACTION sees schemaComplete=true 2. rule sets state=CONFIRMATION 3. optional SET_INPUT_PARAM writes awaiting_confirmation=true and confirmation_key=... 4. user responds with AFFIRM / EDIT 5. POST_DIALOGUE_ACT can use SET_DIALOGUE_ACT if the final guarded act should be overridden before policy routing 6. CorrectionStep sets runtime flags such as routing_decision or correction_applied 7. PRE_AGENT_MCP checks those flags and decides whether MCP should start ## Rule matching behavior For each pass: 1. fetch by phase + session state 2. check intent ( ANY /blank/null supported) 3. check state ( ANY /blank/null supported) 4. evaluate type resolver ( EXACT , REGEX , JSON_PATH ) 5. execute action resolver 6. rerun pass if intent/state changed (max pass cap) Audit emitted for both outcomes: - RULE_MATCH (AgentIntentResolver) - RULE_NO_MATCH (AgentIntentResolver) - RULE_MATCH (RulesStep) - RULE_NO_MATCH (RulesStep) - RULE_MATCH (McpToolStep) - RULE_NO_MATCH (McpToolStep) RULE_APPLIED (...) is additionally emitted when action execution mutates/executes the matched rule. ## Response resolution behavior ResponseResolutionStep : 1. selects response template by intent/state/priority 2. resolves output format 3. emits RESOLVE_RESPONSE* audit stages 4. writes final payload ( EXACT or DERIVED ) ## SET_INPUT_PARAM patterns Use SET_INPUT_PARAM when you need lightweight runtime variables persisted in inputParams instead of writing custom Java. <DbTable title=\"Common runtime-flag patterns\" columns={[\"Scenario\", \"Example action_value\", \"Why it helps\"]} rows={[ [\"Confirmation required\", \"{\\\"awaiting_confirmation\\\":true,\\\"confirmation_key\\\":\\\"LOAN_APPLICATION_CONFIRM\\\"}\", \"Marks the next turn as a confirmation-bound reply.\"], [\"Skip re-extraction\", \"{\\\"skip_schema_extraction\\\":true}\", \"Avoids another schema LLM call on confirm-accept or deterministic patch.\"], [\"Route after AFFIRM\", \"{\\\"routing_decision\\\":\\\"PROCEED_CONFIRMED\\\"}\", \"Lets PRE_AGENT_MCP or PRE_RESPONSE_RESOLUTION rules branch without parsing raw user text.\"], [\"Patch feedback\", \"{\\\"correction_applied\\\":true}\", \"Allows confirmation responses to mention that a value was updated.\"] ]} /> <Highlight type=\"tip\" title=\"Best practice for yes/no turns\"> Do not write ce_rule against raw “yes”, “go ahead”, or “confirm” text. Use DialogueActStep ( AFFIRM / NEGATE ) plus a scoped runtime flag such as awaiting_confirmation or confirmation_key . </Highlight> ## Operational guidance - Keep fallback state responses ( ANY / UNKNOWN ) for safety paths. - Keep at least one response for each terminal state. - Use phase-scoped rules instead of overloading one monolithic PRE_RESPONSE_RESOLUTION pass. - Use SET_INPUT_PARAM when you need deterministic runtime flags without hardcoding more Java branching. - For confirmation flows, combine DialogueActStep + CorrectionStep + SET_INPUT_PARAM rather than rerunning full schema extraction on every turn. - When guarded dialogue-act output needs a DB-driven override, use POST_DIALOGUE_ACT + SET_DIALOGUE_ACT instead of hardcoding workflow state names in Java.",
    "excerpt": "Rules and Response Resolution Rule phases ce_rule.phase supports: POST_DIALOGUE_ACT PRE_RESPONSE_RESOLUTION POST_AGENT_INTENT POST_SCHEMA_EXTRACTION PRE_AGENT_MCP POST_AGENT_MCP POST_TOOL_EXECUTION RulesStep writes phase…"
  },
  {
    "id": "deep-dive/thymeleaf-spel.mdx",
    "version": "v2",
    "title": "thymeleaf spel",
    "permalink": "/docs/v2/deep-dive/thymeleaf-spel",
    "content": "Thymeleaf and SpEL in Prompts and Verbose Messages ConvEngine 2.0.9 routes prompt rendering and verbose text rendering through the shared ThymeleafTemplateRenderer . This applies to: ce_prompt_template.system_prompt ce_prompt_template.user_prompt ce_verbose.message ce_verbose.error_message It means you can use Thymeleaf text expressions backed by Spring Expression Language (SpEL) against live session/runtime data. Where it is used ThymeleafTemplateRenderer\", \"LLM behavior instructions\"], [\"ce_prompt_template.user_prompt\", \"PromptTemplateRenderer ThymeleafTemplateRenderer\", \"Current request/context assembly\"], [\"ce_verbose.message\", \"DbVerboseMessageResolver ThymeleafTemplateRenderer\", \"Progress text shown to UI\"], [\"ce_verbose.error_message\", \"DbVerboseMessageResolver ThymeleafTemplateRenderer\", \"Error text shown to UI\"], [\"ConvEngineVerboseAdapter.publishText(...)\", \"VerboseMessagePublisher ThymeleafTemplateRenderer\", \"Direct consumer emitted UI verbose text\"] ]} / Available runtime variables Common variables available during rendering: user_input resolved_user_input standalone_query intent state context inputParams schema session resolved_user_input is the preferred current turn input when query rewrite / standalone query is present. What Spring Expression Language (SpEL) means here Thymeleaf is the text templating layer. SpEL is the expression language inside the $ part. In other words: [[$ ]] [[...]] is Thymeleaf text rendering $ is a SpEL expression ConvEngine uses this so templates can read values, branch on conditions, and apply simple defaults without writing Java. Common SpEL patterns Supported practical operators you will use most: equality: == , != logical: && , || , ! comparisons: , = , Use SpEL for lightweight reads, conditionals, and defaults. Keep business routing in ce_rule and pipeline steps, not in large prompt expressions. Recommended syntax Use Thymeleaf text expressions for new templates: [[$ ]] [[$ ]] [[$ ]] [[$ ]] Legacy placeholders still work: } } But Thymeleaf expressions are the native path now. Use [[...]] for rendered text output. Use $ inside conditions and default expressions. Prompt examples ]] Current intent/state: intent: [[\\$ ]] state: [[\\$ ]] Loan draft: customerId: [[\\$ ]] requestedAmount: [[\\$ ]] tenureMonths: [[\\$ ]] If awaiting confirmation is true, ask for confirmation only. Awaiting confirmation: [[\\$ ]] } Conditional/default examples You can use SpEL backed Thymeleaf expressions for simple branching and fallbacks: ]] [[\\$ ]] [[\\$ ]] } SpEL examples for confirmation first flows These are the kinds of checks that pair well with SET_INPUT_PARAM , DialogueActStep , and CorrectionStep : ]] [[\\$ ]] [[\\$ ]] } Verbose message examples ]]. Please confirm customer [[\\$ ]] again.', 'Could not apply the requested correction for [[\\$ ]].', 10, true); } Direct adapter example ]] in state [[\\$ ]].\" ); } } } What happens when variables are missing Legacy } placeholders are validated. If a required legacy variable cannot be resolved, prompt rendering can fail with unresolved prompt metadata. For Thymeleaf expressions, prefer explicit fallbacks when a value may be absent. Do not assume every nested node exists. For optional values, use fallback expressions instead of hard failing on deep property chains. Best practices Use resolved_user_input instead of user_input when current turn rewrites matter. Keep business control in ce_rule ; use templates for wording, not state transitions. Use ce_verbose / ConvEngineVerboseAdapter for UI progress text, not to mutate runtime state. Prefer compact expressions; large branching logic belongs in rules or Java, not prompt text.",
    "rawContent": "# Thymeleaf and SpEL in Prompts and Verbose Messages ConvEngine 2.0.9 routes prompt rendering and verbose text rendering through the shared ThymeleafTemplateRenderer . This applies to: - ce_prompt_template.system_prompt - ce_prompt_template.user_prompt - ce_verbose.message - ce_verbose.error_message It means you can use Thymeleaf text expressions backed by Spring Expression Language (SpEL) against live session/runtime data. ## Where it is used <DbTable title=\"Rendering surfaces\" columns={[\"Surface\", \"Rendered by\", \"Typical use\"]} rows={[ [\"ce_prompt_template.system_prompt\", \"PromptTemplateRenderer -> ThymeleafTemplateRenderer\", \"LLM behavior instructions\"], [\"ce_prompt_template.user_prompt\", \"PromptTemplateRenderer -> ThymeleafTemplateRenderer\", \"Current request/context assembly\"], [\"ce_verbose.message\", \"DbVerboseMessageResolver -> ThymeleafTemplateRenderer\", \"Progress text shown to UI\"], [\"ce_verbose.error_message\", \"DbVerboseMessageResolver -> ThymeleafTemplateRenderer\", \"Error text shown to UI\"], [\"ConvEngineVerboseAdapter.publishText(...)\", \"VerboseMessagePublisher -> ThymeleafTemplateRenderer\", \"Direct consumer-emitted UI verbose text\"] ]} /> ## Available runtime variables Common variables available during rendering: - user_input - resolved_user_input - standalone_query - intent - state - context - inputParams - schema - session resolved_user_input is the preferred current-turn input when query rewrite / standalone query is present. ## What Spring Expression Language (SpEL) means here Thymeleaf is the text templating layer. SpEL is the expression language inside the ${...} part. In other words: - [[${intent}]] - [[...]] is Thymeleaf text rendering - ${intent} is a SpEL expression ConvEngine uses this so templates can read values, branch on conditions, and apply simple defaults without writing Java. ## Common SpEL patterns <DbTable title=\"SpEL patterns you can use\" columns={[\"Pattern\", \"Example\", \"What it does\"]} rows={[ [\"Property access\", \"[[${context.customerId}]]\", \"Reads a nested value from runtime context.\"], [\"Boolean check\", \"[[${inputParams.awaiting_confirmation == true}]]\", \"Evaluates a true/false condition.\"], [\"Ternary\", \"[[${state == 'CONFIRMATION' ? 'Please confirm.' : 'Continuing.'}]]\", \"Chooses one of two strings based on a condition.\"], [\"Null/default fallback\", \"[[${context.customerId != null ? context.customerId : 'UNKNOWN_CUSTOMER'}]]\", \"Supplies a fallback value when the real value is absent.\"], [\"Logical operators\", \"[[${context.mcp != null && context.mcp.finalAnswer != null ? context.mcp.finalAnswer : 'Pending'}]]\", \"Combines multiple checks before rendering.\"] ]} /> Supported practical operators you will use most: - equality: == , != - logical: && , || , ! - comparisons: > , < , >= , <= - ternary: condition ? a : b <Highlight type=\"info\" title=\"Recommended scope for SpEL\"> Use SpEL for lightweight reads, conditionals, and defaults. Keep business routing in ce_rule and pipeline steps, not in large prompt expressions. </Highlight> ## Recommended syntax Use Thymeleaf text expressions for new templates: - [[${intent}]] - [[${state}]] - [[${context.customerId}]] - [[${inputParams.confirmation_key}]] Legacy placeholders still work: - {{user_input}} - {{context}} But Thymeleaf expressions are the native path now. <Highlight type=\"tip\" title=\"Practical rule\"> Use [[...]] for rendered text output. Use ${...} inside conditions and default expressions. </Highlight> ## Prompt examples <CodeBlockToggle title=\"ce_prompt_template.user_prompt example\" language=\"text\"> { User input: [[\\${resolved_user_input}]] Current intent/state: - intent: [[\\${intent}]] - state: [[\\${state}]] Loan draft: - customerId: [[\\${context.customerId}]] - requestedAmount: [[\\${context.requestedAmount}]] - tenureMonths: [[\\${context.tenureMonths}]] If awaiting confirmation is true, ask for confirmation only. Awaiting confirmation: [[\\${inputParams.awaiting_confirmation}]] } </CodeBlockToggle> ## Conditional/default examples You can use SpEL-backed Thymeleaf expressions for simple branching and fallbacks: <CodeBlockToggle title=\"Conditional and fallback examples\" language=\"text\"> { [[\\${context.customerId != null ? context.customerId : 'UNKNOWN_CUSTOMER'}]] [[\\${inputParams.correction_applied == true ? 'Updated value captured.' : 'No correction applied.'}]] [[\\${context.mcp != null && context.mcp.finalAnswer != null ? context.mcp.finalAnswer : 'Processing is still in progress.'}]] } </CodeBlockToggle> ## SpEL examples for confirmation-first flows These are the kinds of checks that pair well with SET_INPUT_PARAM , DialogueActStep , and CorrectionStep : <CodeBlockToggle title=\"Confirmation-focused SpEL examples\" language=\"text\"> { [[\\${inputParams.awaiting_confirmation == true ? 'Awaiting user confirmation.' : 'No confirmation gate active.'}]] [[\\${inputParams.routing_decision == 'PROCEED_CONFIRMED' ? 'User confirmed. Start processing.' : 'Still waiting for confirmation.'}]] [[\\${inputParams.correction_applied == true ? 'Updated ' + inputParams.correction_target_field + '.' : 'No correction applied.'}]] } </CodeBlockToggle> ## Verbose message examples <CodeBlockToggle title=\"ce_verbose.message example\" language=\"sql\"> { INSERT INTO ce_verbose (intent_code, state_code, step_match, step_value, determinant, message, error_message, priority, enabled) VALUES ('LOAN_APPLICATION', 'CONFIRMATION', 'EXACT', 'CorrectionStep', 'CORRECTION_PATCH_APPLIED', 'Updated [[\\${correction_target_field}]]. Please confirm customer [[\\${context.customerId}]] again.', 'Could not apply the requested correction for [[\\${context.customerId}]].', 10, true); } </CodeBlockToggle> ## Direct adapter example <CodeBlockToggle title=\"ConvEngineVerboseAdapter with Thymeleaf text\" language=\"java\"> { @Component @RequiredArgsConstructor public class LoanHook implements EngineStepHook { private final ConvEngineVerboseAdapter verboseAdapter; @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { verboseAdapter.publishText( session, this, \"PRECHECK_STARTED\", \"Starting review for [[\\${context.customerId}]] in state [[\\${state}]].\" ); } } } </CodeBlockToggle> ## What happens when variables are missing - Legacy {{...}} placeholders are validated. - If a required legacy variable cannot be resolved, prompt rendering can fail with unresolved prompt metadata. - For Thymeleaf expressions, prefer explicit fallbacks when a value may be absent. <Highlight type=\"warning\" title=\"Avoid brittle templates\"> Do not assume every nested node exists. For optional values, use fallback expressions instead of hard-failing on deep property chains. </Highlight> ## Best practices - Use resolved_user_input instead of user_input when current-turn rewrites matter. - Keep business control in ce_rule ; use templates for wording, not state transitions. - Use ce_verbose / ConvEngineVerboseAdapter for UI progress text, not to mutate runtime state. - Prefer compact expressions; large branching logic belongs in rules or Java, not prompt text.",
    "excerpt": "Thymeleaf and SpEL in Prompts and Verbose Messages ConvEngine 2.0.9 routes prompt rendering and verbose text rendering through the shared ThymeleafTemplateRenderer . This applies to: ce_prompt_template.system_prompt ce_p…"
  },
  {
    "id": "deep-dive/v2-features.mdx",
    "version": "v2",
    "title": "v2 features",
    "permalink": "/docs/v2/deep-dive/v2-features",
    "content": "ConvEngine Detailed Features (Current v2 Line) This page reflects the current v2 codebase, not just the original 2.0.0 launch set. It consolidates the active runtime behavior across the v2 release line through the current repo state (including later additions such as CorrectionStep , ce_mcp_planner , ce_verbose , extra rule phases, and Thymeleaf backed prompt rendering). If you need exact internals for one subsystem, use the linked deep dive pages. This page is the high level, top to bottom feature inventory. 1. Runtime Pipeline Is Now a Full Multi Step DAG v2 is no longer a simple intent response flow. The engine now runs a richer directed pipeline with explicit step ordering and lifecycle hooks. Core runtime stages include: Conversation bootstrap and persistence: LoadOrCreateConversationStep PersistConversationBootstrapStep PersistConversationStep Early governance: CacheInspectAuditStep ResetConversationStep PolicyEnforcementStep AuditUserInputStep Turn interpretation and routing: DialogueActStep InteractionPolicyStep CorrectionStep Multi turn task handling: ActionLifecycleStep DisambiguationStep PendingActionStep Main conversational processing: IntentResolutionStep ResetResolvedIntentStep FallbackIntentStateStep AddContainerDataStep SchemaExtractionStep AutoAdvanceStep Tooling and orchestration: GuardrailStep ToolOrchestrationStep McpToolStep RulesStep StateGraphStep Output and closeout: ResponseResolutionStep MemoryStep PipelineEndGuardStep This matters operationally because most v2 behavior is step driven and data driven. Consumer apps should configure tables and properties, not hardcode domain branching in controller logic. 2. Dialogue Handling Is More Than Intent Classification DialogueActStep The engine resolves turn semantics before intent resolution: resolve modes: REGEX_ONLY REGEX_THEN_LLM LLM_ONLY default config comes from convengine.flow.dialogue act. regex remains the fast path for low cost turns LLM fallback is used when configured mode and confidence thresholds require it Current runtime outputs include: dialogue_act dialogue_act_confidence standalone_query resolved_user_input Current v2 dialogue acts now include: AFFIRM NEGATE EDIT RESET QUESTION NEW_REQUEST ANSWER Current verbose/audit coverage includes: DIALOGUE_ACT_LLM_INPUT DIALOGUE_ACT_LLM_OUTPUT DIALOGUE_ACT_LLM_ERROR DIALOGUE_ACT_CLASSIFIED InteractionPolicyStep This step is still the deterministic routing layer, but it is now part of a broader routing chain instead of being the only \"policy\" feature. Config comes from convengine.flow.interaction policy. , including: boolean shortcuts such as executePendingOnAffirm requireResolvedIntentAndState a configurable matrix The main deterministic outcomes remain: EXECUTE_PENDING_ACTION REJECT_PENDING_ACTION FILL_PENDING_SLOT RECLASSIFY_INTENT CorrectionStep (newer v2 addition) This is one of the biggest changes missing from the old page. CorrectionStep now handles confirmation/correction turns before intent/schema are re run: resets per turn routing_decision supports in place retry handling supports confirmation accept ( AFFIRM ) when current schema is already complete supports single field correction patching for EDIT turns can skip intent resolution and schema extraction for safe in place corrections It uses: active ce_output_schema current context JSON ce_prompt_template interaction semantics Important current routing decisions: CONTINUE_STANDARD_FLOW HANDLE_AS_ANSWER RETRY_IN_PLACE PROCEED_CONFIRMED APPLY_CORRECTION This means v2 can now continue, retry, confirm, or patch an existing turn without forcing a full reclassification loop. 3. Pending Actions Are Runtime Controlled, Not Just Static Rows ce_pending_action ce_pending_action remains the control plane catalog for pending actions, but in the current repo it is stricter than the original docs implied: intent_code is required state_code is required static scope validation runs at startup rows are resolved from static cache, not ad hoc table scans on every turn The actual runtime lifecycle is stored in session/context ( pending_action_runtime ), not in the table itself. ActionLifecycleStep Current behavior: manages TTL by turns and time tracks lifecycle states such as: OPEN IN_PROGRESS EXECUTED REJECTED EXPIRED uses convengine.flow.action lifecycle.ttl turns uses convengine.flow.action lifecycle.ttl minutes DisambiguationStep This step now explicitly pauses execution when multiple pending actions remain eligible at the winning priority: asks a targeted clarification question writes pending clarification state into session/context prevents accidental execution when multiple actions look valid PendingActionStep This is the execution/rejection stage: executes or rejects the selected pending action delegates to CeTaskExecutor updates runtime pending action status/result 4. Tool Execution Is Split Into Two Distinct Paths Current v2 supports both direct one shot tool execution and planner driven MCP loops. Direct tool path: ToolOrchestrationStep This step executes exactly one tool when the request contains tool_request . Current contract: request input: tool_request.tool_code tool_request.tool_group tool_request.args runtime outputs: tool_result tool_status context.mcp.toolExecution. Current behavior: honors convengine.flow.tool orchestration.enabled resolves tool by tool_code within current scope falls back to tool_group when code resolution is not possible writes rich _meta data into the result payload runs rules in POST_TOOL_EXECUTION Current status/outcome coverage includes: SUCCESS ERROR SCOPE_MISMATCH Supported tool group model The unified v2 tool contract supports these normalized groups: DB HTTP_API WORKFLOW_ACTION DOCUMENT_RETRIEVAL CALCULATOR_TRANSFORM NOTIFICATION FILES On the MCP side, HTTP execution now supports multiple handler models: HttpApiProcessorToolHandler HttpApiRequestingToolHandler classic HttpApiToolHandler Framework managed HTTP policy support includes: connect/read timeouts retry and backoff in memory circuit breaker auth/provider hooks response mapping Those defaults come from convengine.mcp.http api.defaults. . 5. MCP Is Now Planner Scoped, Guarded, and Explicitly Scoped ce_mcp_tool scope rules (correct current behavior) The old statement about optional intent_code / state_code with NULL wildcard is no longer true. Current behavior: ce_mcp_tool.intent_code is mandatory ce_mcp_tool.state_code is mandatory null/blank scope is not allowed valid scope values are: exact configured intent_code / state_code ANY UNKNOWN Startup integrity validation now fails fast on invalid scope rows to prevent cross intent tool leakage. ce_mcp_planner (newer v2 addition) MCP prompt selection is now data driven via ce_mcp_planner . Current planner prompt resolution order: 1. exact intent_code + state_code 2. exact intent_code + ANY 3. ANY + ANY 4. legacy fallback from ce_config McpPlanner keys when planner rows are unavailable Like ce_mcp_tool , ce_mcp_planner.intent_code and state_code are mandatory and validated at startup. McpToolStep This step is now much more feature rich than the old page described. Current behavior includes: runs PRE_AGENT_MCP rules before planning skips MCP when: SKIP_TOOL_EXECUTION is set guardrails already blocked the turn required schema is incomplete dialogue act indicates the turn should not enter MCP the user turn is just a greeting pending clarification exists resolves scoped tools from McpToolRegistry runs a bounded planner/tool loop ( MAX_LOOPS = 5 ) stores observations in context.mcp.observations stores final planner answer in context.mcp.finalAnswer runs POST_AGENT_MCP rules after MCP completion/block/fallback MCP runtime metadata (important for ce_rule JSON_PATH) Current rule branching can inspect: context.mcp.lifecycle. context.mcp.toolExecution. This exposes deterministic rule conditions such as: blocked vs skipped vs answered last action/tool tool status and outcome scope mismatch error flags and messages MCP next tool guardrails In addition to general turn guardrails, MCP has a post planner next tool guard: enabled with convengine.mcp.guardrail.enabled failClosed can block when no allowed next rule exists allowedNextByCurrentTool whitelists legal tool transitions If the planner proposes a blocked next tool: the engine writes the fallback blocked answer lifecycle metadata is updated deterministically POST_AGENT_MCP rules still run 6. Rules Are Broader Than the Original v2 Rule Model Current rule phases The runtime rule surface is larger now: POST_DIALOGUE_ACT POST_SCHEMA_EXTRACTION PRE_AGENT_MCP PRE_RESPONSE_RESOLUTION POST_AGENT_INTENT POST_AGENT_MCP POST_TOOL_EXECUTION Legacy names are still normalized at runtime: PIPELINE_RULES PRE_RESPONSE_RESOLUTION AGENT_POST_INTENT POST_AGENT_INTENT AGENT_POST_MCP POST_AGENT_MCP TOOL_POST_EXECUTION POST_TOOL_EXECUTION Current rule actions The rule engine now supports both retrieval style and mutation style actions: GET_CONTEXT GET_SCHEMA_JSON GET_SESSION SET_DIALOGUE_ACT SET_INPUT_PARAM SET_INTENT SET_JSON SET_STATE SET_TASK That means ce_rule is not just for state transitions anymore. It can mutate input params, inject task directives, and branch across more pipeline phases. 7. Schema, Prompt, and Response Handling Are Richer in Current v2 SchemaExtractionStep Current behavior includes: schema driven extraction from ce_output_schema schema completeness tracking missing required field detection post extraction rule execution in POST_SCHEMA_EXTRACTION AutoAdvanceStep This step computes schema facts used later in the flow: schema complete vs incomplete whether any values were captured ResponseResolutionStep The response layer still uses ce_response and ce_prompt_template , but current v2 has tighter runtime metadata and better prompt handling. Prompt template interaction semantics In 2.0.9+ , ce_prompt_template is also part of turn routing semantics: interaction_mode interaction_contract This is what CorrectionStep should use for confirm/edit/retry semantics instead of inferring behavior from state naming conventions. Shared prompt renderer (current v2) Prompt rendering now goes through a shared Thymeleaf backed path. Supported template styles: legacy } [$ ] Current prompt/session variables now include: session inputParams rawInputParams context schema schemaJson promptVars standalone_query resolved_user_input This same rendering path is used by: prompt templates ce_verbose.message ce_verbose.error_message 8. Verbose Runtime and Step Telemetry Are First Class Features ce_verbose (newer v2 addition) The old page did not cover the current verbose runtime model. ce_verbose is now a core control plane table for runtime progress/error messaging: statically cached startup validated scoped by intent_code and state_code matched by determinant + step matcher + optional rule/tool filters Current matching inputs include: intent_code state_code determinant step_match step_value optional rule_id optional tool_code priority Step match types are validated ( EXACT , REGEX , JSON_PATH ). Determinant coverage Current runtime emits determinants across: step enter/exit/error dialogue act LLM lifecycle intent resolution lifecycle schema extraction lifecycle MCP planning/tool lifecycle direct tool orchestration lifecycle rule matching/application response generation lifecycle Stream transport Both SSE and STOMP now publish: AUDIT events VERBOSE events The stream envelope includes a VerboseStreamPayload so clients can render progress updates without scraping audit rows. Step telemetry in session Current v2 also records per step execution details in EngineSession.stepInfos : status timing outcome error metadata This supports deterministic diagnostics and replay friendly inspection. 9. Memory, Continuity, and Reset Handling Expanded MemoryStep Memory remains optional and config driven through convengine.flow.memory. . Current behavior: writes memory.session_summary into context can use pluggable ConversationMemoryStore compresses recent conversation context instead of endlessly replaying full history Query rewrite and resolved input Current v2 also supports query rewriting: convengine.flow.query rewrite.enabled standalone_query can be generated for follow up turns resolved_user_input gives downstream steps a stable \"effective user text\" This is important for MCP, schema extraction, and prompt rendering because the framework now distinguishes raw user text from resolved conversational intent. Reset and fallback handling The v2 line also includes: explicit conversation reset reset by configured intent via ResetResolvedIntentStep fallback filling of missing intent/state through FallbackIntentStateStep 10. Cache, Startup Validation, and Operational Safety Are Core v2 Features The current v2 line is much stricter operationally than the original feature list suggested. Static cache model Control plane tables are preloaded and cached, including: ce_intent ce_intent_classifier ce_rule ce_response ce_output_schema ce_prompt_template ce_pending_action ce_mcp_tool ce_mcp_planner ce_verbose Startup integrity validation Startup validation now checks scope correctness and row integrity for critical tables such as: ce_pending_action ce_mcp_tool ce_mcp_planner ce_verbose This means invalid scope rows or malformed verbose matchers can fail startup instead of producing unpredictable runtime behavior. Cache analysis and refresh Operational tooling now includes: cache refresh endpoint cache analyzer endpoint for visibility into cache wiring and warm state These were added specifically to reduce config debugging friction in real deployments. 11. Consumer Integration and Extension Points Are Broader Current v2 supports several framework level integration hooks beyond the original basic engine enablement. Key annotations and extension surfaces include: @EnableConvEngine @EnableConvEngineCaching @EnableConvEngineAsyncConversation @EnableConvEngineAsyncAuditDispatch optional streaming enablement for SSE/STOMP paths Consumer side custom code can also extend behavior through: tool handlers/executors container transformers response transformers verbose adapter publishing ( ConvEngineVerboseAdapter ) This lets consumers add UI progress messaging, custom transport shaping, and domain logic without forking core engine flow. 12. What Changed From the Old Page The old version of this document was incomplete and partially outdated. The main gaps were: it treated MCP tool scope as nullable/wildcard, but current v2 requires explicit scope with ANY / UNKNOWN it missed CorrectionStep it missed PendingActionStep , AutoAdvanceStep , PolicyEnforcementStep , reset/fallback steps, and the broader DAG it missed ce_mcp_planner it missed newer rule phases ( POST_DIALOGUE_ACT , POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP ) it missed SET_INPUT_PARAM it missed ce_verbose , stream verbose events, and step telemetry it missed Thymeleaf backed prompt rendering and the newer prompt variable model it did not reflect the stricter startup validation and static cache architecture now present in the repo Related Deep Dives",
    "rawContent": "# ConvEngine Detailed Features (Current v2 Line) This page reflects the current v2 codebase, not just the original 2.0.0 launch set. It consolidates the active runtime behavior across the v2 release line through the current repo state (including later additions such as CorrectionStep , ce_mcp_planner , ce_verbose , extra rule phases, and Thymeleaf-backed prompt rendering). If you need exact internals for one subsystem, use the linked deep-dive pages. This page is the high-level, top-to-bottom feature inventory. ## 1. Runtime Pipeline Is Now a Full Multi-Step DAG v2 is no longer a simple intent -> response flow. The engine now runs a richer directed pipeline with explicit step ordering and lifecycle hooks. Core runtime stages include: - Conversation bootstrap and persistence: - LoadOrCreateConversationStep - PersistConversationBootstrapStep - PersistConversationStep - Early governance: - CacheInspectAuditStep - ResetConversationStep - PolicyEnforcementStep - AuditUserInputStep - Turn interpretation and routing: - DialogueActStep - InteractionPolicyStep - CorrectionStep - Multi-turn task handling: - ActionLifecycleStep - DisambiguationStep - PendingActionStep - Main conversational processing: - IntentResolutionStep - ResetResolvedIntentStep - FallbackIntentStateStep - AddContainerDataStep - SchemaExtractionStep - AutoAdvanceStep - Tooling and orchestration: - GuardrailStep - ToolOrchestrationStep - McpToolStep - RulesStep - StateGraphStep - Output and closeout: - ResponseResolutionStep - MemoryStep - PipelineEndGuardStep This matters operationally because most v2 behavior is step-driven and data-driven. Consumer apps should configure tables and properties, not hardcode domain branching in controller logic. ## 2. Dialogue Handling Is More Than Intent Classification ### DialogueActStep The engine resolves turn semantics before intent resolution: - resolve modes: - REGEX_ONLY - REGEX_THEN_LLM - LLM_ONLY - default config comes from convengine.flow.dialogue-act.* - regex remains the fast path for low-cost turns - LLM fallback is used when configured mode and confidence thresholds require it Current runtime outputs include: - dialogue_act - dialogue_act_confidence - standalone_query - resolved_user_input Current v2 dialogue acts now include: - AFFIRM - NEGATE - EDIT - RESET - QUESTION - NEW_REQUEST - ANSWER Current verbose/audit coverage includes: - DIALOGUE_ACT_LLM_INPUT - DIALOGUE_ACT_LLM_OUTPUT - DIALOGUE_ACT_LLM_ERROR - DIALOGUE_ACT_CLASSIFIED ### InteractionPolicyStep This step is still the deterministic routing layer, but it is now part of a broader routing chain instead of being the only \"policy\" feature. Config comes from convengine.flow.interaction-policy.* , including: - boolean shortcuts such as executePendingOnAffirm - requireResolvedIntentAndState - a configurable matrix The main deterministic outcomes remain: - EXECUTE_PENDING_ACTION - REJECT_PENDING_ACTION - FILL_PENDING_SLOT - RECLASSIFY_INTENT ### CorrectionStep (newer v2 addition) This is one of the biggest changes missing from the old page. CorrectionStep now handles confirmation/correction turns before intent/schema are re-run: - resets per-turn routing_decision - supports in-place retry handling - supports confirmation accept ( AFFIRM ) when current schema is already complete - supports single-field correction patching for EDIT turns - can skip intent resolution and schema extraction for safe in-place corrections It uses: - active ce_output_schema - current context JSON - ce_prompt_template interaction semantics Important current routing decisions: - CONTINUE_STANDARD_FLOW - HANDLE_AS_ANSWER - RETRY_IN_PLACE - PROCEED_CONFIRMED - APPLY_CORRECTION This means v2 can now continue, retry, confirm, or patch an existing turn without forcing a full reclassification loop. ## 3. Pending Actions Are Runtime-Controlled, Not Just Static Rows ### ce_pending_action ce_pending_action remains the control-plane catalog for pending actions, but in the current repo it is stricter than the original docs implied: - intent_code is required - state_code is required - static scope validation runs at startup - rows are resolved from static cache, not ad hoc table scans on every turn The actual runtime lifecycle is stored in session/context ( pending_action_runtime ), not in the table itself. ### ActionLifecycleStep Current behavior: - manages TTL by turns and time - tracks lifecycle states such as: - OPEN - IN_PROGRESS - EXECUTED - REJECTED - EXPIRED - uses convengine.flow.action-lifecycle.ttl-turns - uses convengine.flow.action-lifecycle.ttl-minutes ### DisambiguationStep This step now explicitly pauses execution when multiple pending actions remain eligible at the winning priority: - asks a targeted clarification question - writes pending clarification state into session/context - prevents accidental execution when multiple actions look valid ### PendingActionStep This is the execution/rejection stage: - executes or rejects the selected pending action - delegates to CeTaskExecutor - updates runtime pending action status/result ## 4. Tool Execution Is Split Into Two Distinct Paths Current v2 supports both direct one-shot tool execution and planner-driven MCP loops. ### Direct tool path: ToolOrchestrationStep This step executes exactly one tool when the request contains tool_request . Current contract: - request input: - tool_request.tool_code - tool_request.tool_group - tool_request.args - runtime outputs: - tool_result - tool_status - context.mcp.toolExecution.* Current behavior: - honors convengine.flow.tool-orchestration.enabled - resolves tool by tool_code within current scope - falls back to tool_group when code resolution is not possible - writes rich _meta data into the result payload - runs rules in POST_TOOL_EXECUTION Current status/outcome coverage includes: - SUCCESS - ERROR - SCOPE_MISMATCH ### Supported tool group model The unified v2 tool contract supports these normalized groups: - DB - HTTP_API - WORKFLOW_ACTION - DOCUMENT_RETRIEVAL - CALCULATOR_TRANSFORM - NOTIFICATION - FILES On the MCP side, HTTP execution now supports multiple handler models: - HttpApiProcessorToolHandler - HttpApiRequestingToolHandler - classic HttpApiToolHandler Framework-managed HTTP policy support includes: - connect/read timeouts - retry and backoff - in-memory circuit breaker - auth/provider hooks - response mapping Those defaults come from convengine.mcp.http-api.defaults.* . ## 5. MCP Is Now Planner-Scoped, Guarded, and Explicitly Scoped ### ce_mcp_tool scope rules (correct current behavior) The old statement about optional intent_code / state_code with NULL wildcard is no longer true. Current behavior: - ce_mcp_tool.intent_code is mandatory - ce_mcp_tool.state_code is mandatory - null/blank scope is not allowed - valid scope values are: - exact configured intent_code / state_code - ANY - UNKNOWN Startup integrity validation now fails fast on invalid scope rows to prevent cross-intent tool leakage. ### ce_mcp_planner (newer v2 addition) MCP prompt selection is now data-driven via ce_mcp_planner . Current planner prompt resolution order: 1. exact intent_code + state_code 2. exact intent_code + ANY 3. ANY + ANY 4. legacy fallback from ce_config McpPlanner keys when planner rows are unavailable Like ce_mcp_tool , ce_mcp_planner.intent_code and state_code are mandatory and validated at startup. ### McpToolStep This step is now much more feature-rich than the old page described. Current behavior includes: - runs PRE_AGENT_MCP rules before planning - skips MCP when: - SKIP_TOOL_EXECUTION is set - guardrails already blocked the turn - required schema is incomplete - dialogue act indicates the turn should not enter MCP - the user turn is just a greeting - pending clarification exists - resolves scoped tools from McpToolRegistry - runs a bounded planner/tool loop ( MAX_LOOPS = 5 ) - stores observations in context.mcp.observations - stores final planner answer in context.mcp.finalAnswer - runs POST_AGENT_MCP rules after MCP completion/block/fallback ### MCP runtime metadata (important for ce_rule JSON_PATH) Current rule branching can inspect: - context.mcp.lifecycle.* - context.mcp.toolExecution.* This exposes deterministic rule conditions such as: - blocked vs skipped vs answered - last action/tool - tool status and outcome - scope mismatch - error flags and messages ### MCP next-tool guardrails In addition to general turn guardrails, MCP has a post-planner next-tool guard: - enabled with convengine.mcp.guardrail.enabled - failClosed can block when no allowed-next rule exists - allowedNextByCurrentTool whitelists legal tool transitions If the planner proposes a blocked next tool: - the engine writes the fallback blocked answer - lifecycle metadata is updated deterministically - POST_AGENT_MCP rules still run ## 6. Rules Are Broader Than the Original v2 Rule Model ### Current rule phases The runtime rule surface is larger now: - POST_DIALOGUE_ACT - POST_SCHEMA_EXTRACTION - PRE_AGENT_MCP - PRE_RESPONSE_RESOLUTION - POST_AGENT_INTENT - POST_AGENT_MCP - POST_TOOL_EXECUTION Legacy names are still normalized at runtime: - PIPELINE_RULES -> PRE_RESPONSE_RESOLUTION - AGENT_POST_INTENT -> POST_AGENT_INTENT - AGENT_POST_MCP -> POST_AGENT_MCP - TOOL_POST_EXECUTION -> POST_TOOL_EXECUTION ### Current rule actions The rule engine now supports both retrieval-style and mutation-style actions: - GET_CONTEXT - GET_SCHEMA_JSON - GET_SESSION - SET_DIALOGUE_ACT - SET_INPUT_PARAM - SET_INTENT - SET_JSON - SET_STATE - SET_TASK That means ce_rule is not just for state transitions anymore. It can mutate input params, inject task directives, and branch across more pipeline phases. ## 7. Schema, Prompt, and Response Handling Are Richer in Current v2 ### SchemaExtractionStep Current behavior includes: - schema-driven extraction from ce_output_schema - schema completeness tracking - missing-required-field detection - post-extraction rule execution in POST_SCHEMA_EXTRACTION ### AutoAdvanceStep This step computes schema facts used later in the flow: - schema complete vs incomplete - whether any values were captured ### ResponseResolutionStep The response layer still uses ce_response and ce_prompt_template , but current v2 has tighter runtime metadata and better prompt handling. ### Prompt template interaction semantics In 2.0.9+ , ce_prompt_template is also part of turn-routing semantics: - interaction_mode - interaction_contract This is what CorrectionStep should use for confirm/edit/retry semantics instead of inferring behavior from state naming conventions. ### Shared prompt renderer (current v2) Prompt rendering now goes through a shared Thymeleaf-backed path. Supported template styles: - legacy {{var}} - #{...} - [${...}] Current prompt/session variables now include: - session - inputParams - rawInputParams - context - schema - schemaJson - promptVars - standalone_query - resolved_user_input This same rendering path is used by: - prompt templates - ce_verbose.message - ce_verbose.error_message ## 8. Verbose Runtime and Step Telemetry Are First-Class Features ### ce_verbose (newer v2 addition) The old page did not cover the current verbose runtime model. ce_verbose is now a core control-plane table for runtime progress/error messaging: - statically cached - startup validated - scoped by intent_code and state_code - matched by determinant + step matcher + optional rule/tool filters Current matching inputs include: - intent_code - state_code - determinant - step_match - step_value - optional rule_id - optional tool_code - priority Step match types are validated ( EXACT , REGEX , JSON_PATH ). ### Determinant coverage Current runtime emits determinants across: - step enter/exit/error - dialogue act LLM lifecycle - intent resolution lifecycle - schema extraction lifecycle - MCP planning/tool lifecycle - direct tool orchestration lifecycle - rule matching/application - response generation lifecycle ### Stream transport Both SSE and STOMP now publish: - AUDIT events - VERBOSE events The stream envelope includes a VerboseStreamPayload so clients can render progress updates without scraping audit rows. ### Step telemetry in session Current v2 also records per-step execution details in EngineSession.stepInfos : - status - timing - outcome - error metadata This supports deterministic diagnostics and replay-friendly inspection. ## 9. Memory, Continuity, and Reset Handling Expanded ### MemoryStep Memory remains optional and config-driven through convengine.flow.memory.* . Current behavior: - writes memory.session_summary into context - can use pluggable ConversationMemoryStore - compresses recent conversation context instead of endlessly replaying full history ### Query rewrite and resolved input Current v2 also supports query rewriting: - convengine.flow.query-rewrite.enabled - standalone_query can be generated for follow-up turns - resolved_user_input gives downstream steps a stable \"effective user text\" This is important for MCP, schema extraction, and prompt rendering because the framework now distinguishes raw user text from resolved conversational intent. ### Reset and fallback handling The v2 line also includes: - explicit conversation reset - reset-by-configured-intent via ResetResolvedIntentStep - fallback filling of missing intent/state through FallbackIntentStateStep ## 10. Cache, Startup Validation, and Operational Safety Are Core v2 Features The current v2 line is much stricter operationally than the original feature list suggested. ### Static cache model Control-plane tables are preloaded and cached, including: - ce_intent - ce_intent_classifier - ce_rule - ce_response - ce_output_schema - ce_prompt_template - ce_pending_action - ce_mcp_tool - ce_mcp_planner - ce_verbose ### Startup integrity validation Startup validation now checks scope correctness and row integrity for critical tables such as: - ce_pending_action - ce_mcp_tool - ce_mcp_planner - ce_verbose This means invalid scope rows or malformed verbose matchers can fail startup instead of producing unpredictable runtime behavior. ### Cache analysis and refresh Operational tooling now includes: - cache refresh endpoint - cache analyzer endpoint for visibility into cache wiring and warm state These were added specifically to reduce config debugging friction in real deployments. ## 11. Consumer Integration and Extension Points Are Broader Current v2 supports several framework-level integration hooks beyond the original basic engine enablement. Key annotations and extension surfaces include: - @EnableConvEngine - @EnableConvEngineCaching - @EnableConvEngineAsyncConversation - @EnableConvEngineAsyncAuditDispatch - optional streaming enablement for SSE/STOMP paths Consumer-side custom code can also extend behavior through: - tool handlers/executors - container transformers - response transformers - verbose adapter publishing ( ConvEngineVerboseAdapter ) This lets consumers add UI progress messaging, custom transport shaping, and domain logic without forking core engine flow. ## 12. What Changed From the Old Page The old version of this document was incomplete and partially outdated. The main gaps were: - it treated MCP tool scope as nullable/wildcard, but current v2 requires explicit scope with ANY / UNKNOWN - it missed CorrectionStep - it missed PendingActionStep , AutoAdvanceStep , PolicyEnforcementStep , reset/fallback steps, and the broader DAG - it missed ce_mcp_planner - it missed newer rule phases ( POST_DIALOGUE_ACT , POST_SCHEMA_EXTRACTION , PRE_AGENT_MCP ) - it missed SET_INPUT_PARAM - it missed ce_verbose , stream verbose events, and step telemetry - it missed Thymeleaf-backed prompt rendering and the newer prompt variable model - it did not reflect the stricter startup validation and static cache architecture now present in the repo ## Related Deep Dives - [Pipeline & Steps](/docs/v2/deep-dive/pipeline-steps) - [Rules & Responses](/docs/v2/deep-dive/rules-responses) - [Verbose and Conversation Runtime](/docs/v2/deep-dive/verbose-and-conversation-runtime) - [MCP and Audit](/docs/v2/deep-dive/mcp-audit) - [Version History](/docs/v2/version-history)",
    "excerpt": "ConvEngine Detailed Features (Current v2 Line) This page reflects the current v2 codebase, not just the original 2.0.0 launch set. It consolidates the active runtime behavior across the v2 release line through the curren…"
  },
  {
    "id": "deep-dive/verbose-and-conversation-runtime.mdx",
    "version": "v2",
    "title": "verbose and conversation runtime",
    "permalink": "/docs/v2/deep-dive/verbose-and-conversation-runtime",
    "content": "Verbose and Conversation Runtime This page documents two runtime tables that are often tuned together: ce_conversation (conversation state persistence) ce_verbose (runtime progress/error messaging) ce_conversation runtime contract ce_conversation is the turn to turn state source used by EngineSessionFactory and LoadOrCreateConversationStep . If a conversation row does not exist, EngineSessionFactory creates a minimal row with context_json= , input_params_json= , and status RUNNING , then syncs session from it. ce_verbose runtime contract ce_verbose is resolved by DbVerboseMessageResolver using the current runtime context from session and metadata. Resolver behavior (from Java implementation) 1. Load eligible rows from static cache ( ce_verbose ) by intent/state. 2. Filter by determinant, step match, rule/tool constraints. 3. Score candidates by specificity ( intent , state , determinant , step match type, rule_id , tool_code ) and priority. 4. Render message / error_message through the shared Thymeleaf text renderer using current session/runtime variables. 5. Build VerboseStreamPayload with level=INFO|ERROR . 6. If no row matches and the event is error path, fallback publishes: Something went wrong while processing . Determinants currently emitted by runtime These emitted determinant values are the same values you should use in ce_verbose.determinant . Consumer side verbose emission Consumer hooks, container transformers, response transformers, and other Spring beans can emit UI verbose messages through ConvEngineVerboseAdapter . ]] in state [[\\$ ]].\" ); return responsePayload; } } } For publish(session, this, \"POST_TRANSFORM_START\") , ce_verbose resolution uses: step_value = LoanResponseTransformer determinant = POST_TRANSFORM_START current intent_code and state_code Adapter behavior: publish(session, this, \"...\") uses this.getClass().getSimpleName() as step_value publish(session, ..., metadata) and publishError(...) flow through the same DB backed ce_verbose resolver with extra metadata if no ce_verbose row matches, no custom verbose message is emitted from the DB path publishText(...) bypasses DB lookup and sends the provided text directly, still rendered through Thymeleaf against session + metadata Stream envelope contract ( AUDIT + VERBOSE ) Both SSE and STOMP publish AuditStreamEventResponse with: eventType : AUDIT or VERBOSE verbose : populated for verbose events payload.verbose : verbose payload mirror for clients that read payload map ce_verbose is validated at startup. Invalid step_match or blank step_value / determinant rows can fail startup integrity checks.",
    "rawContent": "# Verbose and Conversation Runtime This page documents two runtime tables that are often tuned together: - ce_conversation (conversation state persistence) - ce_verbose (runtime progress/error messaging) ## ce_conversation runtime contract ce_conversation is the turn-to-turn state source used by EngineSessionFactory and LoadOrCreateConversationStep . <DbTable title=\"ce_conversation fields used at runtime\" columns={[\"Column\", \"How engine uses it\", \"Write path\"]} rows={[ [\"conversation_id\", \"Primary key for session bootstrap and resume\", \"Created once in bootstrap/create step\"], [\"intent_code\", \"Restored into session intent at turn start\", \"Updated through pipeline + persist\"], [\"state_code\", \"Restored into session state at turn start\", \"Updated through pipeline + persist\"], [\"context_json\", \"Restored into session.contextJson \", \"Mutated by steps, saved in persist\"], [\"input_params_json\", \"Restored into session input params baseline\", \"Sanitized and saved in persist\"], [\"last_user_text\", \"Tracks most recent user text for diagnostics\", \"Set in LoadOrCreateConversationStep \"], [\"last_assistant_json\", \"Stores last assistant payload\", \"Set during response/persist flow\"], [\"status\", \"Conversation status marker (normally RUNNING )\", \"Set in bootstrap/persist\"], [\"created_at/updated_at\", \"Turn recency and lifecycle timestamps\", \"Created in bootstrap, updated each turn\"] ]} /> <Highlight type=\"tip\" title=\"Bootstrap behavior\"> If a conversation row does not exist, EngineSessionFactory creates a minimal row with context_json={} , input_params_json={} , and status RUNNING , then syncs session from it. </Highlight> ## ce_verbose runtime contract ce_verbose is resolved by DbVerboseMessageResolver using the current runtime context from session and metadata. <DbTable title=\"ce_verbose matching inputs\" columns={[\"Column\", \"Meaning\", \"Example\"]} rows={[ [\"intent_code/state_code\", \"Primary runtime scope\", \"Exact value or ANY \"], [\"determinant\", \"Event emitted by runtime code\", \" STEP_ENTER , RULE_MATCH , MCP_TOOL_CALL \"], [\"step_match + step_value\", \"Step matcher ( EXACT|REGEX|JSON_PATH )\", \" RulesStep , .*Step$ , $.stepInfo.error \"], [\"rule_id/tool_code\", \"Optional strict narrowing\", \"Specific rule or MCP tool\"], [\"message/error_message\", \"Text returned for info/error paths\", \"Progress and failure variants\"], [\"priority\", \"Lower value wins after specificity scoring\", \"10, 20, 100\"], [\"enabled\", \"Row eligibility switch\", \"true/false\"] ]} /> ### Resolver behavior (from Java implementation) 1. Load eligible rows from static cache ( ce_verbose ) by intent/state. 2. Filter by determinant, step match, rule/tool constraints. 3. Score candidates by specificity ( intent , state , determinant , step match type, rule_id , tool_code ) and priority. 4. Render message / error_message through the shared Thymeleaf text renderer using current session/runtime variables. 5. Build VerboseStreamPayload with level=INFO|ERROR . 6. If no row matches and the event is error path, fallback publishes: Something went wrong while processing <step>. ## Determinants currently emitted by runtime These emitted determinant values are the same values you should use in ce_verbose.determinant . <DbTable title=\"Common emitted determinants\" columns={[\"Source\", \"Determinants\"]} rows={[ [\"Step hook\", \"STEP_ENTER, STEP_EXIT, STEP_ERROR\"], [\"Intent resolver\", \"AGENT_INTENT_START, AGENT_INTENT_ACCEPTED, AGENT_INTENT_REJECTED, AGENT_INTENT_COLLISION, AGENT_INTENT_NEEDS_CLARIFICATION, INTENT_AGENT_LLM_INPUT, INTENT_AGENT_LLM_OUTPUT, INTENT_AGENT_LLM_ERROR\"], [\"Dialogue act\", \"DIALOGUE_ACT_LLM_INPUT, DIALOGUE_ACT_LLM_OUTPUT, DIALOGUE_ACT_LLM_ERROR\"], [\"Rules\", \"RULE_MATCH, RULE_APPLIED, RULE_NO_MATCH\"], [\"Schema\", \"SCHEMA_EXTRACTION_START, SCHEMA_EXTRACTION_LLM_INPUT, SCHEMA_EXTRACTION_LLM_OUTPUT, SCHEMA_EXTRACTION_LLM_ERROR, SCHEMA_STATUS\"], [\"MCP/tool\", \"MCP_PLAN_LLM_INPUT, MCP_PLAN_LLM_OUTPUT, MCP_PLAN_LLM_ERROR, MCP_TOOL_CALL, MCP_TOOL_RESULT, MCP_TOOL_ERROR, MCP_FINAL_ANSWER, TOOL_ORCHESTRATION_REQUEST, TOOL_ORCHESTRATION_RESULT, TOOL_ORCHESTRATION_ERROR\"], [\"Resolver factories\", \"RULE_ACTION_RESOLVER_SELECTED/NOT_FOUND, RESPONSE_TYPE_RESOLVER_SELECTED/NOT_FOUND, OUTPUT_FORMAT_RESOLVER_SELECTED/NOT_FOUND\"], [\"Response step\", \"RESOLVE_RESPONSE, RESOLVE_RESPONSE_SELECTED, RESOLVE_RESPONSE_LLM_INPUT, RESOLVE_RESPONSE_LLM_OUTPUT, RESOLVE_RESPONSE_LLM_ERROR\"], [\"Intent step\", \"INTENT_RESOLVED\"] ]} /> ## Consumer-side verbose emission Consumer hooks, container transformers, response transformers, and other Spring beans can emit UI verbose messages through ConvEngineVerboseAdapter . <CodeBlockToggle title=\"Consumer verbose adapter usage\" language=\"java\"> { @Component @RequiredArgsConstructor public class LoanResponseTransformer implements ResponseTransformerHandler { private final ConvEngineVerboseAdapter verboseAdapter; @Override public OutputPayload transform(OutputPayload responsePayload, EngineSession session, Map<String, Object> inputParams) { verboseAdapter.publish(session, this, \"POST_TRANSFORM_START\"); verboseAdapter.publishText( session, this, \"POST_TRANSFORM_NOTE\", \"Preparing final response for [[\\${intent}]] in state [[\\${state}]].\" ); return responsePayload; } } } </CodeBlockToggle> For publish(session, this, \"POST_TRANSFORM_START\") , ce_verbose resolution uses: - step_value = LoanResponseTransformer - determinant = POST_TRANSFORM_START - current intent_code and state_code Adapter behavior: - publish(session, this, \"...\") uses this.getClass().getSimpleName() as step_value - publish(session, ..., metadata) and publishError(...) flow through the same DB-backed ce_verbose resolver with extra metadata - if no ce_verbose row matches, no custom verbose message is emitted from the DB path - publishText(...) bypasses DB lookup and sends the provided text directly, still rendered through Thymeleaf against session + metadata ## Stream envelope contract ( AUDIT + VERBOSE ) Both SSE and STOMP publish AuditStreamEventResponse with: - eventType : AUDIT or VERBOSE - verbose : populated for verbose events - payload.verbose : verbose payload mirror for clients that read payload map <CodeBlockToggle title=\"Verbose rollout SQL (standalone assets)\" language=\"text\"> { src/main/resources/sql/verbose_ddl.sql src/main/resources/sql/verbose_seed.sql } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Startup safety\"> ce_verbose is validated at startup. Invalid step_match or blank step_value / determinant rows can fail startup integrity checks. </Highlight>",
    "excerpt": "Verbose and Conversation Runtime This page documents two runtime tables that are often tuned together: ce_conversation (conversation state persistence) ce_verbose (runtime progress/error messaging) ce_conversation runtim…"
  },
  {
    "id": "examples.mdx",
    "version": "v2",
    "title": "examples",
    "permalink": "/docs/v2/examples",
    "content": "title: Examples (Bird's Eye View) sidebar_position: 3 hide_table_of_contents: true , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , ]; faq_intent: , faq_schema: , faq_rules: , faq_resp: , faq_mem: , }; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , label: 'Next Turn' }, , ]; t_intent: , t_schema: , t_rules1: , t_resp1: , t_schema2: , t_rules2: , }; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , ]; c_act: , c_policy: , c_guard: , c_pending: , c_rules: , c_resp: , }; , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , ]; i_intent: , i_orch: , i_java: , i_ret: , i_resp: , }; , data: }, , data: }, , data: }, , data: }, ]; , , , ]; s_mem1: , s_intent: , s_resp: , s_mem2: , }; Examples (Bird's Eye View + DML + Audit) This page is the practical E2E companion to the V2 architecture. Each example shows: conversation UX runtime flow graph (interactive) DML seed rows expected audit stages Canonical V2 Runtime Step Set Step loop invokes each execute(session) . If a step returns Stop , response returns immediately; otherwise loop continues. 1 LoadOrCreateConversationStep 2 CacheInspectAuditStep 3 ResetConversationStep 4 PersistConversationBootstrapStep 5 AuditUserInputStep 6 PolicyEnforcementStep 7 DialogueActStep 8 InteractionPolicyStep 9 CorrectionStep 10 ActionLifecycleStep 11 DisambiguationStep 12 GuardrailStep 13 IntentResolutionStep 14 ResetResolvedIntentStep 15 FallbackIntentStateStep 16 AddContainerDataStep 17 PendingActionStep 18 ToolOrchestrationStep 19 McpToolStep 20 SchemaExtractionStep 21 AutoAdvanceStep 22 RulesStep 23 StateGraphStep 24 ResponseResolutionStep 25 MemoryStep 26 PersistConversationStep 27 PipelineEndGuardStep FAQ How do I transfer my electricity connection? Share customerId, phone, email, source city, and target city. Then confirm to submit transfer. }\\nFAQ context: }\\nReturn short helpful answer.', 0.10, true); INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'DERIVED', 'Answer FAQ using available context and user question.', 10, true); } CONNECTION_TRANSFER Move my electricity connection from City1 to City2. Please provide customerId, phone, email, sourceCity, and targetCity. customerId 9912, phone 9988776655, email user@zapper.com, sourceCity City1, targetCity City2 Do you want to move this connection right away? ,\"phone\": ,\"email\": ,\"sourceCity\": ,\"targetCity\": }, \"required\":[\"customerId\",\"phone\",\"email\",\"sourceCity\",\"targetCity\"]}', true); INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled) VALUES ('PRE_RESPONSE_RESOLUTION', 'CONNECTION_TRANSFER', 'IDLE', 'REGEX', '. ', 'SET_STATE', 'COLLECT_INPUTS', 10, true), ('PRE_RESPONSE_RESOLUTION', 'CONNECTION_TRANSFER', 'COLLECT_INPUTS', 'JSON_PATH', '$[?(@.state == ''COLLECT_INPUTS'' && @.customerId && @.phone && @.email && @.sourceCity && @.targetCity)]', 'SET_STATE', 'AWAITING_CONFIRMATION', 100, true); INSERT INTO ce_response (intent_code, state_code, response_type, output_format, enabled) VALUES ('CONNECTION_TRANSFER', 'COLLECT_INPUTS', 'DERIVED', 'TEXT', true); INSERT INTO ce_response (intent_code, state_code, response_type, output_format, enabled) VALUES ('CONNECTION_TRANSFER', 'AWAITING_CONFIRMATION', 'DERIVED', 'TEXT', true); } COLLECT_INPUTS switch\"], [\"ASSISTANT_OUTPUT\", \"Prompts for slot filling\"] ]} / ORDER_CANCELLATION Cancel my shoe order. What is your order number? It's 48392. Are you sure you want to cancel order 48392? Yes please do that. Order 48392 has been completely cancelled. } has been completely cancelled.', 'tmpl_cancelled', true); } CANCELLED\"] ]} / INVENTORY_LOOKUP How many running shoes are left in warehouse B? Checking the inventory database... [System delay executing Tool] We currently have 421 units of running shoes allocated to warehouse B. }', 'tmpl_inventory_gen', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, priority, enabled) VALUES ('DATABASE_QUERY', 'IDLE', 'DERIVED', 'tmpl_inventory_gen', 10, true); } SUPPORT_DIAGNOSTIC [Turn 15]: Wait, what link did you tell me to use for the firmware reset again? Based on our previous troubleshooting, you should use http://router.local/admin_reset with the default PIN 1234. For each example run, inspect both /api/v2/conversation/audit/ '} and /api/v2/conversation/audit/ '}/trace .",
    "rawContent": "title: Examples (Bird's-Eye View) sidebar_position: 3 hide_table_of_contents: true --- { id: \"faq_intent\", position: { x: 20, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"faq_schema\", position: { x: 300, y: 60 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"faq_rules\", position: { x: 580, y: 60 }, data: { label: \"RulesStep\" } }, { id: \"faq_resp\", position: { x: 300, y: 220 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"faq_mem\", position: { x: 580, y: 220 }, data: { label: \"MemoryStep\" } }, ]; { id: \"faq_e1\", source: \"faq_intent\", target: \"faq_schema\" }, { id: \"faq_e2\", source: \"faq_schema\", target: \"faq_rules\" }, { id: \"faq_e3\", source: \"faq_rules\", target: \"faq_resp\" }, { id: \"faq_e4\", source: \"faq_resp\", target: \"faq_mem\" }, ]; faq_intent: { title: \"Intent resolution\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"Classifier resolves FAQ intent.\", session: [\"intent=FAQ, state=IDLE\"] }, faq_schema: { title: \"Fact extraction\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...) \", stage: \"SCHEMA_EVALUATED\", summary: \"Minimal schema evaluation.\", session: [\"schema complete\"] }, faq_rules: { title: \"Rules evaluation\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_NO_MATCH\", summary: \"No auto-advance transition required.\", session: [\"state unchanged\"] }, faq_resp: { title: \"Response resolution\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Resolves DERIVED response text.\", session: [\"LLM synthesized string\"] }, faq_mem: { title: \"Context memory\", file: \"engine/steps/MemoryStep.java\", method: \"execute(...) \", stage: \"MEMORY_UPDATED\", summary: \"Records turn for future summaries.\", session: [\"memory summary updated\"] }, }; { id: \"t_intent\", position: { x: 20, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"t_schema\", position: { x: 300, y: 60 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"t_rules1\", position: { x: 580, y: 60 }, data: { label: \"RulesStep (Turn 1)\" } }, { id: \"t_resp1\", position: { x: 860, y: 60 }, data: { label: \"Ask for slots\" } }, { id: \"t_schema2\", position: { x: 300, y: 220 }, data: { label: \"SchemaExtractionStep (Turn 2)\" } }, { id: \"t_rules2\", position: { x: 580, y: 220 }, data: { label: \"RulesStep -> Confirm\" } }, ]; { id: \"t_e1\", source: \"t_intent\", target: \"t_schema\" }, { id: \"t_e2\", source: \"t_schema\", target: \"t_rules1\" }, { id: \"t_e3\", source: \"t_rules1\", target: \"t_resp1\" }, { id: \"t_e4\", source: \"t_resp1\", target: \"t_schema2\", style: { strokeDasharray: '5,5' }, label: 'Next Turn' }, { id: \"t_e5\", source: \"t_schema2\", target: \"t_rules2\" }, ]; t_intent: { title: \"Intent resolution\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"CONNECTION_TRANSFER locked.\", session: [\"state=IDLE\"] }, t_schema: { title: \"Slot extraction\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...) \", stage: \"SCHEMA_INCOMPLETE\", summary: \"Identifies missing slots.\", session: [\"missingFields tracked\"] }, t_rules1: { title: \"Bootstrap state\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_MATCH\", summary: \"Transitions IDLE -> COLLECT_INPUTS.\", session: [\"state -> COLLECT_INPUTS\"] }, t_resp1: { title: \"Clarification\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Prompts for customerId, email, etc.\", session: [\"Prompt sent\"] }, t_schema2: { title: \"Fill slots\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...) \", stage: \"SCHEMA_COMPLETE\", summary: \"User provides all missing slots.\", session: [\"schema locked\"] }, t_rules2: { title: \"Advance\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_MATCH\", summary: \"Transitions to AWAITING_CONFIRMATION.\", session: [\"state -> AWAITING_CONFIRMATION\"] }, }; { id: \"c_act\", position: { x: 20, y: 60 }, data: { label: \"DialogueActStep\" } }, { id: \"c_policy\", position: { x: 300, y: 60 }, data: { label: \"InteractionPolicyStep\" } }, { id: \"c_guard\", position: { x: 580, y: 60 }, data: { label: \"GuardrailStep\" } }, { id: \"c_pending\", position: { x: 860, y: 60 }, data: { label: \"PendingActionStep\" } }, { id: \"c_rules\", position: { x: 300, y: 220 }, data: { label: \"RulesStep\" } }, { id: \"c_resp\", position: { x: 580, y: 220 }, data: { label: \"Finalizer\" } }, ]; { id: \"c_e1\", source: \"c_act\", target: \"c_policy\" }, { id: \"c_e2\", source: \"c_policy\", target: \"c_guard\" }, { id: \"c_e3\", source: \"c_guard\", target: \"c_pending\" }, { id: \"c_e4\", source: \"c_pending\", target: \"c_rules\" }, { id: \"c_e5\", source: \"c_rules\", target: \"c_resp\" }, ]; c_act: { title: \"Act check\", file: \"engine/steps/DialogueActStep.java\", method: \"execute(...) \", stage: \"DIALOGUE_ACT_CLASSIFIED\", summary: \"User says 'yes'. Act=AFFIRM.\", session: [\"dialogueAct=AFFIRM\"] }, c_policy: { title: \"Policy lock\", file: \"engine/steps/InteractionPolicyStep.java\", method: \"execute(...) \", stage: \"INTERACTION_POLICY_DECIDED\", summary: \"Routes to pending task over intent.\", session: [\"policyDecision=EXECUTE_PENDING_ACTION\"] }, c_guard: { title: \"Safety check\", file: \"engine/steps/GuardrailStep.java\", method: \"execute(...) \", stage: \"GUARDRAIL_ALLOW\", summary: \"Ensures benign operation.\", session: [\"result=ALLOW\"] }, c_pending: { title: \"Task execute\", file: \"engine/steps/PendingActionStep.java\", method: \"execute(...) \", stage: \"PENDING_ACTION_EXECUTED\", summary: \"Triggers API cancellation bean.\", session: [\"status=EXECUTED\"] }, c_rules: { title: \"Completion rule\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_MATCH\", summary: \"EXECUTED -> CANCELLED state.\", session: [\"state -> CANCELLED\"] }, c_resp: { title: \"Response\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Completion text.\", session: [\"done\"] }, }; { id: \"i_intent\", position: { x: 20, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"i_orch\", position: { x: 300, y: 60 }, data: { label: \"ToolOrchestrationStep\" } }, { id: \"i_java\", position: { x: 580, y: 60 }, data: { label: \"Live MCP Tool Call\" } }, { id: \"i_ret\", position: { x: 300, y: 220 }, data: { label: \"Orchestration Returns\" } }, { id: \"i_resp\", position: { x: 580, y: 220 }, data: { label: \"ResponseResolutionStep\" } }, ]; { id: \"i_e1\", source: \"i_intent\", target: \"i_orch\" }, { id: \"i_e2\", source: \"i_orch\", target: \"i_java\" }, { id: \"i_e3\", source: \"i_java\", target: \"i_ret\" }, { id: \"i_e4\", source: \"i_ret\", target: \"i_resp\" }, ]; i_intent: { title: \"Intent\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"DATABASE_QUERY intent.\", session: [\"intent=DATABASE_QUERY\"] }, i_orch: { title: \"Tool Dispatch\", file: \"engine/steps/ToolOrchestrationStep.java\", method: \"execute(...) \", stage: \"TOOL_ORCHESTRATION_DISPATCH\", summary: \"Delegates to MCP runtime.\", session: [\"group=INVENTORY_DB\"] }, i_java: { title: \"Execution\", file: \"external/java/Adapter.java\", method: \"execute(...) \", stage: \"EXTERNAL\", summary: \"Java connector runs backend DB.\", session: [\"Fetching rows\"] }, i_ret: { title: \"Tool Finish\", file: \"engine/steps/ToolOrchestrationStep.java\", method: \"execute(...) \", stage: \"TOOL_ORCHESTRATION_RESULT\", summary: \"Assigns result to session context.\", session: [\"tool_result.dbList\"] }, i_resp: { title: \"Interpolate\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"LLM uses live tool data in response.\", session: [\"Synthesized text\"] }, }; { id: \"s_mem1\", position: { x: 20, y: 60 }, data: { label: \"MemoryStep (Load)\" } }, { id: \"s_intent\", position: { x: 300, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"s_resp\", position: { x: 580, y: 60 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"s_mem2\", position: { x: 860, y: 60 }, data: { label: \"MemoryStep (Compute)\" } }, ]; { id: \"s_e1\", source: \"s_mem1\", target: \"s_intent\" }, { id: \"s_e2\", source: \"s_intent\", target: \"s_resp\" }, { id: \"s_e3\", source: \"s_resp\", target: \"s_mem2\" }, ]; s_mem1: { title: \"Load summary\", file: \"engine/steps/MemoryStep.java\", method: \"execute(...) \", stage: \"MEMORY_INJECTED\", summary: \"Injects context from 14 turns ago.\", session: [\"memory.session_summary available\"] }, s_intent: { title: \"Guided AI\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"Resolves meaning over ambiguous input.\", session: [\"intent=SUPPORT_DIAGNOSTIC\"] }, s_resp: { title: \"Accurate query\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Answers with previous link text.\", session: [\"derived text\"] }, s_mem2: { title: \"Update Rolling\", file: \"engine/steps/MemoryStep.java\", method: \"execute(...) \", stage: \"MEMORY_UPDATED\", summary: \"Compresses latest turns into new summary.\", session: [\"re-evaluated summary\"] }, }; # Examples (Bird's-Eye View + DML + Audit) This page is the practical E2E companion to the V2 architecture. Each example shows: - conversation UX - runtime flow graph (interactive) - DML seed rows - expected audit stages ## Canonical V2 Runtime Step Set <Highlight type=\"info\" title=\"Step loop behavior\"> Step loop invokes each <MethodRef>execute(session)</MethodRef>. If a step returns <MethodRef>Stop</MethodRef>, response returns immediately; otherwise loop continues. </Highlight> <div className=\"ce-step-badge-list\" role=\"list\" aria-label=\"Canonical runtime step set\"> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">1</span><span className=\"ce-step-badge-label\">LoadOrCreateConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">2</span><span className=\"ce-step-badge-label\">CacheInspectAuditStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">3</span><span className=\"ce-step-badge-label\">ResetConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">4</span><span className=\"ce-step-badge-label\">PersistConversationBootstrapStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">5</span><span className=\"ce-step-badge-label\">AuditUserInputStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">6</span><span className=\"ce-step-badge-label\">PolicyEnforcementStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">7</span><span className=\"ce-step-badge-label\">DialogueActStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">8</span><span className=\"ce-step-badge-label\">InteractionPolicyStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">9</span><span className=\"ce-step-badge-label\">CorrectionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">10</span><span className=\"ce-step-badge-label\">ActionLifecycleStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">11</span><span className=\"ce-step-badge-label\">DisambiguationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">12</span><span className=\"ce-step-badge-label\">GuardrailStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">13</span><span className=\"ce-step-badge-label\">IntentResolutionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">14</span><span className=\"ce-step-badge-label\">ResetResolvedIntentStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">15</span><span className=\"ce-step-badge-label\">FallbackIntentStateStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">16</span><span className=\"ce-step-badge-label\">AddContainerDataStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">17</span><span className=\"ce-step-badge-label\">PendingActionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">18</span><span className=\"ce-step-badge-label\">ToolOrchestrationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">19</span><span className=\"ce-step-badge-label\">McpToolStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">20</span><span className=\"ce-step-badge-label\">SchemaExtractionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">21</span><span className=\"ce-step-badge-label\">AutoAdvanceStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">22</span><span className=\"ce-step-badge-label\">RulesStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">23</span><span className=\"ce-step-badge-label\">StateGraphStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">24</span><span className=\"ce-step-badge-label\">ResponseResolutionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">25</span><span className=\"ce-step-badge-label\">MemoryStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">26</span><span className=\"ce-step-badge-label\">PersistConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">27</span><span className=\"ce-step-badge-label\">PipelineEndGuardStep</span></div> </div> ## FAQ <Tabs groupId=\"example-faq\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"FAQ\"> <User info={[\"FAQ style informational request.\", \"Triggers QUESTION dialogue act.\"]}>How do I transfer my electricity connection?</User> <Assistant tables={[\"ce_intent\", \"ce_intent_classifier\", \"ce_response\"]} info={[\"Intent resolved as FAQ.\", \"Response selected from FAQ mapping.\"]}>Share customerId, phone, email, source city, and target city. Then confirm to submit transfer.</Assistant> </Conversation> <EngineDebugFlow title=\"FAQ runtime flow\" subtitle=\"Basic Intent + Memory retention\" nodes={faqNodes} edges={faqEdges} detailsById={faqDetails} defaultSelectedId=\"faq_intent\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"FAQ seed SQL\" language=\"sql\" defaultOpen={true}> { INSERT INTO ce_intent (intent_code, description, priority, enabled) VALUES ('FAQ', 'Answer informational questions from FAQ knowledge base', 10, true); INSERT INTO ce_intent_classifier (intent_code, rule_type, pattern, priority, enabled) VALUES ('FAQ', 'REGEX', '(?i)\\\\b(what|how|help|faq|information|details|explain)\\\\b', 10, true); INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, temperature, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'You are a concise FAQ assistant. Answer directly and clearly.', 'User question: {{user_input}}\\nFAQ context: {{container_data}}\\nReturn short helpful answer.', 0.10, true); INSERT INTO ce_response (intent_code, state_code, output_format, response_type, derivation_hint, priority, enabled) VALUES ('FAQ', 'IDLE', 'TEXT', 'DERIVED', 'Answer FAQ using available context and user question.', 10, true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"Expected audit stages (ordered)\" columns={[\"Order\", \"Stage\", \"Must contain\"]} rows={[ [\"1\", \"USER_INPUT\", \"original user message\"], [\"2\", \"DIALOGUE_ACT_CLASSIFIED\", \"dialogueAct=QUESTION\"], [\"3\", \"INTERACTION_POLICY_DECIDED\", \"policyDecision=RECLASSIFY_INTENT\"], [\"4\", \"INTENT_RESOLVED\", \"intent=FAQ\"], [\"5\", \"RESOLVE_RESPONSE_SELECTED\", \"responseType=DERIVED\"], [\"6\", \"ASSISTANT_OUTPUT\", \"output text or json payload\"], [\"7\", \"MEMORY_UPDATED\", \"summaryChars/recalled flags\"], ]} /> </TabItem> </Tabs> ## CONNECTION_TRANSFER <Tabs groupId=\"example-transfer\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"Connection transfer conversation\"> <User info={[\"Initial transfer request.\", \"Intent should resolve to CONNECTION_TRANSFER.\"]}>Move my electricity connection from City1 to City2.</User> <Assistant tables={[\"ce_output_schema\", \"ce_response\"]} info={[\"Schema incomplete path.\", \"Assistant asks for required fields.\"]}>Please provide customerId, phone, email, sourceCity, and targetCity.</Assistant> <User info={[\"User provides all required slots.\", \"Schema completeness expected = true.\"]}>customerId 9912, phone 9988776655, email user@zapper.com, sourceCity City1, targetCity City2</User> <Assistant tables={[\"ce_rule\", \"ce_pending_action\"]} info={[\"State moves to AWAITING_CONFIRMATION.\", \"Pending action staged for confirmation.\"]}>Do you want to move this connection right away?</Assistant> </Conversation> <EngineDebugFlow title=\"Connection Transfer Flow\" subtitle=\"Slot fill auto advance\" nodes={transferNodes} edges={transferEdges} detailsById={transferDetails} defaultSelectedId=\"t_schema\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"Schema & Rules SQL\" language=\"sql\" defaultOpen={true}> { INSERT INTO ce_intent (intent_code, enabled) VALUES ('CONNECTION_TRANSFER', true); INSERT INTO ce_output_schema (intent_code, format_type, schema_json, enabled) VALUES ('CONNECTION_TRANSFER', 'JSON', '{\"properties\":{\"customerId\":{},\"phone\":{},\"email\":{},\"sourceCity\":{},\"targetCity\":{}}, \"required\":[\"customerId\",\"phone\",\"email\",\"sourceCity\",\"targetCity\"]}', true); INSERT INTO ce_rule (phase, intent_code, state_code, rule_type, match_pattern, \"action\", action_value, priority, enabled) VALUES ('PRE_RESPONSE_RESOLUTION', 'CONNECTION_TRANSFER', 'IDLE', 'REGEX', '.*', 'SET_STATE', 'COLLECT_INPUTS', 10, true), ('PRE_RESPONSE_RESOLUTION', 'CONNECTION_TRANSFER', 'COLLECT_INPUTS', 'JSON_PATH', '$[?(@.state == ''COLLECT_INPUTS'' && @.customerId && @.phone && @.email && @.sourceCity && @.targetCity)]', 'SET_STATE', 'AWAITING_CONFIRMATION', 100, true); INSERT INTO ce_response (intent_code, state_code, response_type, output_format, enabled) VALUES ('CONNECTION_TRANSFER', 'COLLECT_INPUTS', 'DERIVED', 'TEXT', true); INSERT INTO ce_response (intent_code, state_code, response_type, output_format, enabled) VALUES ('CONNECTION_TRANSFER', 'AWAITING_CONFIRMATION', 'DERIVED', 'TEXT', true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"Collection Turn Expected Trace\" columns={[\"Stage\", \"Meaning\"]} rows={[ [\"INTENT_RESOLVED\", \"Intent locked to CONNECTION_TRANSFER\"], [\"SCHEMA_INCOMPLETE\", \"Signals partial JSON payload extraction\"], [\"RULE_MATCH\", \"Initial IDLE -> COLLECT_INPUTS switch\"], [\"ASSISTANT_OUTPUT\", \"Prompts for slot filling\"] ]} /> </TabItem> </Tabs> ## ORDER_CANCELLATION <Tabs groupId=\"example-cancel\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"Protected Order Cancellation\"> <User info={[\"Cancellation intent request.\", \"Order id missing in this turn.\"]}>Cancel my shoe order.</User> <Assistant tables={[\"ce_output_schema\", \"ce_response\"]} info={[\"Missing-field follow-up.\", \"Collect order number before execution.\"]}>What is your order number?</Assistant> <User info={[\"Provides order number.\", \"Enables confirmation state transition.\"]}>It's 48392.</User> <Assistant tables={[\"ce_rule\", \"ce_pending_action\"]} info={[\"Action moved to confirmation state.\", \"Awaiting explicit AFFIRM from user.\"]}>Are you sure you want to cancel order 48392?</Assistant> <User info={[\"AFFIRM dialogue act.\", \"Interaction policy should execute pending action.\"]}>Yes please do that.</User> <Assistant tables={[\"ce_audit\", \"ce_response\"]} info={[\"Pending action executed.\", \"Final cancelled response generated.\"]}>Order 48392 has been completely cancelled.</Assistant> </Conversation> <EngineDebugFlow title=\"Action Execution Flow (Turn 3)\" subtitle=\"Interaction Policy executing Pending Action\" nodes={cancelNodes} edges={cancelEdges} detailsById={cancelDetails} defaultSelectedId=\"c_policy\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"Pending Action Assignment SQL\" language=\"sql\" defaultOpen={true}> { INSERT INTO ce_intent (intent_code, enabled) VALUES ('CANCEL_ORDER', true); INSERT INTO ce_pending_action (intent_code, state_code, action_key, bean_name, method_names, priority, enabled, description) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'stripe_cancel', 'stripeCancelTask', 'execute', 10, true, 'Cancel the order in the provider system'); INSERT INTO ce_rule (intent_code, state_code, rule_type, rule_value, action, action_value, phase, priority, enabled) VALUES ('CANCEL_ORDER', 'CONFIRM_CANCEL', 'EXACT', 'ANY', 'SET_STATE', 'CANCELLED', 'PRE_RESPONSE_RESOLUTION', 10, true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, user_prompt, template_id, enabled) VALUES ('CANCEL_ORDER', 'DERIVED', 'Format cleanly.', 'Order {{context.orderNumber}} has been completely cancelled.', 'tmpl_cancelled', true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"Action Commit Expected Trace\" columns={[\"Stage\", \"Required Contents\"]} rows={[ [\"DIALOGUE_ACT_CLASSIFIED\", \"dialogueAct=AFFIRM\"], [\"INTERACTION_POLICY_DECIDED\", \"policyDecision=EXECUTE_PENDING_ACTION\"], [\"PENDING_ACTION_EXECUTED\", \"status=EXECUTED, pendingActionRef=stripeCancelTask\"], [\"RULE_APPLIED\", \"state -> CANCELLED\"] ]} /> </TabItem> </Tabs> ## INVENTORY_LOOKUP <Tabs groupId=\"example-inventory\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"DB Orchestration Flow\"> <User info={[\"Tool-backed inventory lookup request.\", \"Expected tool group: DB/INVENTORY.\"]}>How many running shoes are left in warehouse B?</User> <Assistant tables={[\"ce_mcp_tool\"]} info={[\"Tool orchestration starts.\", \"System preparing DB call.\"]}>Checking the inventory database...</Assistant> <User info={[\"Represents async tool latency.\", \"No new user data provided.\"]}>*[System delay executing Tool]*</User> <Assistant tables={[\"ce_audit\", \"ce_response\"]} info={[\"tool_result injected into response derivation.\", \"Final value rendered from tool output.\"]}>We currently have 421 units of running shoes allocated to warehouse B.</Assistant> </Conversation> <EngineDebugFlow title=\"Tool Request Flow\" subtitle=\"Tool orchestration injects payload\" nodes={invNodes} edges={invEdges} detailsById={invDetails} defaultSelectedId=\"i_orch\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"Virtual DB Binding SQL\" language=\"sql\" defaultOpen={true}> { INSERT INTO ce_mcp_tool (intent_code, tool_group, required_params_json, execution_timeout_ms, enabled) VALUES ('DATABASE_QUERY', 'INVENTORY_DB', '[\"itemType\", \"warehouseId\"]', 5000, true); INSERT INTO ce_prompt_template (intent_code, response_type, system_prompt, user_prompt, template_id, enabled) VALUES ('DATABASE_QUERY', 'DERIVED', 'You are an inventory assistant.', 'Answer from these database results: {{tool_result.dbList}}', 'tmpl_inventory_gen', true); INSERT INTO ce_response (intent_code, state_code, response_type, template_id, priority, enabled) VALUES ('DATABASE_QUERY', 'IDLE', 'DERIVED', 'tmpl_inventory_gen', 10, true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"Data Request Trace\" columns={[\"Stage\", \"Context Checkpoint\"]} rows={[ [\"TOOL_ORCHESTRATION_DISPATCH\", \"toolGroup=INVENTORY_DB\"], [\"TOOL_ORCHESTRATION_RESULT\", \"toolResult={'count': 421}\"], [\"ASSISTANT_OUTPUT\", \"Final text uses 421 units output\"] ]} /> </TabItem> </Tabs> ## SUPPORT_DIAGNOSTIC <Tabs groupId=\"example-support\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"Long Context Support Thread\"> <User info={[\"Late-turn follow-up question.\", \"Requires memory/session summary recall.\"]}>[Turn 15]: Wait, what link did you tell me to use for the firmware reset again?</User> <Assistant tables={[\"ce_conversation_history\", \"ce_audit\"]} info={[\"Memory-assisted recall response.\", \"References earlier troubleshooting context.\"]}>Based on our previous troubleshooting, you should use http://router.local/admin_reset with the default PIN 1234.</Assistant> </Conversation> <EngineDebugFlow title=\"Memory Summary Flow\" subtitle=\"Long-context retrieval during turn evaluation\" nodes={supportNodes} edges={supportEdges} detailsById={supportDetails} defaultSelectedId=\"s_mem1\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"Memory Auto-Summarization Config\" language=\"yaml\" defaultOpen={true}> { convengine: flow: memory: enabled: true # Max token size for the compressed summary string summary-max-chars: 1200 # Number of turns to trigger a new summary compression cycle recent-turns-for-summary: 3 } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"Memory Trace\" columns={[\"Stage\", \"Context Action\"]} rows={[ [\"MEMORY_INJECTED\", \"old sequence of facts available to tool_result/intent logic\"], [\"INTENT_RESOLVED\", \"Supports historical context\"], [\"MEMORY_UPDATED\", \"newSummary generated and injected\"] ]} /> </TabItem> </Tabs> <Highlight type=\"tip\" title=\"Fast validation\"> For each example run, inspect both <FileRef>/api/v2/conversation/audit/{'{conversationId}'}</FileRef> and <FileRef>/api/v2/conversation/audit/{'{conversationId}'}/trace</FileRef>. </Highlight>",
    "excerpt": "title: Examples (Bird's Eye View) sidebar_position: 3 hide_table_of_contents: true , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , ]; faq_intent: , faq_schema: , faq_rules: , faq_resp: , faq_mem: , }; ,…"
  },
  {
    "id": "faq.mdx",
    "version": "v2",
    "title": "faq",
    "permalink": "/docs/v2/faq",
    "content": "FAQ What version is the current v2 documentation aligned to? The current v2 docs are aligned to the active repo state and the current released line documented in this repo, which is 2.0.9 . That includes newer v2 additions such as: CorrectionStep ce_mcp_planner ce_verbose extra rule phases like POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP shared Thymeleaf backed prompt rendering Is v1 still available? Yes. v1 docs are still available from the version selector. Use v1 only if you are maintaining an existing older integration. New work should target the current v2 line. What is the fastest mental model for ConvEngine? ConvEngine is a deterministic, database configured conversation engine. In practice: Java code provides the runtime pipeline ce_ tables provide domain behavior rules and scoped rows decide transitions the LLM is a bounded subsystem inside that pipeline, not the whole engine Does the engine rely only on intent classification? No. Current v2 uses a broader turn routing model: DialogueActStep interprets turn intent like AFFIRM , NEGATE , EDIT , QUESTION , RESET , and ANSWER InteractionPolicyStep applies deterministic routing CorrectionStep can keep a turn in place for confirm/edit/retry flows only then does the engine continue into intent, schema, tools, rules, and response resolution How does the engine understand messages like \"yes\", \"no\", \"retry\", or \"change email\"? It is not just keyword matching against business intents. Those turns are primarily handled by: DialogueActStep InteractionPolicyStep CorrectionStep pending action runtime state prompt template interaction metadata That is why modern v2 can confirm, reject, retry, or patch fields without forcing a full reclassification every time. Does StateGraphStep mutate state? No. The current implementation is validate only. It checks whether the current transition path is acceptable and can set state graph validity signals for downstream behavior, but it does not directly rewrite the state by itself. Can I configure behavior without changing Java code? Yes. That is the normal operating model. Most consumer behavior should be driven through configuration and data: ce_intent ce_intent_classifier ce_output_schema ce_prompt_template ce_rule ce_response ce_pending_action ce_mcp_tool ce_mcp_planner ce_verbose convengine.flow. convengine.mcp. Custom Java should be reserved for: LLM provider integration tool handlers / executors task execution app specific transformers and policy hooks Do ce_mcp_tool.intent_code and state_code still support null wildcard behavior? No. That older description is no longer correct for the current v2 line. Current behavior: intent_code is required state_code is required valid values are exact scope, ANY , or UNKNOWN invalid scope rows are blocked by startup validation The same explicit scope model also applies to ce_mcp_planner . What is ce_mcp_planner for? ce_mcp_planner is the scoped planner prompt source for MCP. It lets the framework choose planner prompts by intent/state rather than relying only on legacy config keys. Current fallback order is: 1. exact intent_code + state_code 2. exact intent_code + ANY 3. ANY + ANY 4. legacy fallback config when planner rows are unavailable What is the difference between ToolOrchestrationStep and McpToolStep ? They are different execution models. ToolOrchestrationStep : executes exactly one requested tool works from tool_request writes tool_result , tool_status , and context.mcp.toolExecution. runs POST_TOOL_EXECUTION rules McpToolStep : runs planner driven MCP loops can call multiple tools across a bounded loop stores planner observations in context.mcp.observations stores planner answer in context.mcp.finalAnswer runs PRE_AGENT_MCP and POST_AGENT_MCP rule paths When should I use ANY scope? Only when the configuration is truly global. Use exact intent/state scope first. Move to ANY only when: the behavior is genuinely shared the blast radius is acceptable the row still makes sense across all intended flows Overusing ANY is one of the easiest ways to create broad but subtle misbehavior. What is ce_verbose , and do I need it? ce_verbose is a runtime progress/error messaging table. It is strongly recommended in current v2 because it: gives the UI and QA a readable progress layer helps operators understand skipped or degraded paths complements raw audit events It is not required for the engine to work, but most serious deployments should use it. What are the most important rule phases now? Current v2 phases are: POST_DIALOGUE_ACT POST_SCHEMA_EXTRACTION PRE_AGENT_MCP PRE_RESPONSE_RESOLUTION POST_AGENT_INTENT POST_AGENT_MCP POST_TOOL_EXECUTION Legacy names are still normalized, but new configurations should use the current phase names. Can rules change more than state and intent? Yes. The rule engine can now do more than classic transition logic. Current actions include: SET_STATE SET_INTENT SET_DIALOGUE_ACT SET_INPUT_PARAM SET_JSON SET_TASK GET_CONTEXT GET_SCHEMA_JSON GET_SESSION That makes rules more powerful, but also easier to misuse. Keep rule ownership disciplined. How should I think about ce_prompt_template in current v2? As both prompt content and runtime behavior metadata. In 2.0.9+ , prompt rows should also describe turn semantics using: interaction_mode interaction_contract That is what allows the framework to safely interpret whether a state supports: affirm edit retry reset structured input collection Is prompt rendering still just } substitution? No. Current v2 uses a shared Thymeleaf backed renderer. Supported patterns include: } [$ ] This rendering path is used across prompt templates and ce_verbose messages. What are the most important runtime endpoints for debugging? The core ones are: POST /api/v1/conversation/message GET /api/v1/conversation/audit/ GET /api/v1/conversation/audit/ /trace POST /api/v1/cache/refresh GET /api/v1/cache/analyze If experimental SQL generation is enabled: POST /api/v1/conversation/experimental/generate sql POST /api/v1/conversation/experimental/generate sql/zip What is the most important production safeguard the framework does not provide automatically? Conversation level concurrency control. The framework does not give you built in optimistic locking on ce_conversation , so you should prevent parallel active turns for the same conversationId . This is still the most important operational safeguard for correctness. How do we avoid 500s or broken user output for conversational mismatches? The best protection is layered: make every reachable state have a valid response strategy keep exact response/rule coverage for active flows use UNKNOWN / ANY intentionally, not accidentally test correction, failure, and no match paths inspect trace output before shipping config changes The goal is not just \"no exception.\" The goal is \"no misleading fallback that looks valid.\" Should new consumers enable everything immediately? No. The safest rollout path is: 1. One narrow intent and one deterministic response path. 2. Then schema collection. 3. Then confirmation/correction behavior. 4. Then pending actions or MCP. 5. Then verbose polish and richer streaming behavior. That sequence gives you a stable baseline before you widen the runtime surface.",
    "rawContent": "# FAQ ## What version is the current v2 documentation aligned to? The current v2 docs are aligned to the active repo state and the current released line documented in this repo, which is 2.0.9 . That includes newer v2 additions such as: - CorrectionStep - ce_mcp_planner - ce_verbose - extra rule phases like POST_SCHEMA_EXTRACTION and PRE_AGENT_MCP - shared Thymeleaf-backed prompt rendering ## Is v1 still available? Yes. v1 docs are still available from the version selector. Use v1 only if you are maintaining an existing older integration. New work should target the current v2 line. ## What is the fastest mental model for ConvEngine? ConvEngine is a deterministic, database-configured conversation engine. In practice: - Java code provides the runtime pipeline - ce_* tables provide domain behavior - rules and scoped rows decide transitions - the LLM is a bounded subsystem inside that pipeline, not the whole engine ## Does the engine rely only on intent classification? No. Current v2 uses a broader turn-routing model: - DialogueActStep interprets turn intent like AFFIRM , NEGATE , EDIT , QUESTION , RESET , and ANSWER - InteractionPolicyStep applies deterministic routing - CorrectionStep can keep a turn in-place for confirm/edit/retry flows - only then does the engine continue into intent, schema, tools, rules, and response resolution ## How does the engine understand messages like \"yes\", \"no\", \"retry\", or \"change email\"? It is not just keyword matching against business intents. Those turns are primarily handled by: - DialogueActStep - InteractionPolicyStep - CorrectionStep - pending-action runtime state - prompt-template interaction metadata That is why modern v2 can confirm, reject, retry, or patch fields without forcing a full reclassification every time. ## Does StateGraphStep mutate state? No. The current implementation is validate-only. It checks whether the current transition path is acceptable and can set state-graph validity signals for downstream behavior, but it does not directly rewrite the state by itself. ## Can I configure behavior without changing Java code? Yes. That is the normal operating model. Most consumer behavior should be driven through configuration and data: - ce_intent - ce_intent_classifier - ce_output_schema - ce_prompt_template - ce_rule - ce_response - ce_pending_action - ce_mcp_tool - ce_mcp_planner - ce_verbose - convengine.flow.* - convengine.mcp.* Custom Java should be reserved for: - LLM provider integration - tool handlers / executors - task execution - app-specific transformers and policy hooks ## Do ce_mcp_tool.intent_code and state_code still support null wildcard behavior? No. That older description is no longer correct for the current v2 line. Current behavior: - intent_code is required - state_code is required - valid values are exact scope, ANY , or UNKNOWN - invalid scope rows are blocked by startup validation The same explicit-scope model also applies to ce_mcp_planner . ## What is ce_mcp_planner for? ce_mcp_planner is the scoped planner prompt source for MCP. It lets the framework choose planner prompts by intent/state rather than relying only on legacy config keys. Current fallback order is: 1. exact intent_code + state_code 2. exact intent_code + ANY 3. ANY + ANY 4. legacy fallback config when planner rows are unavailable ## What is the difference between ToolOrchestrationStep and McpToolStep ? They are different execution models. ToolOrchestrationStep : - executes exactly one requested tool - works from tool_request - writes tool_result , tool_status , and context.mcp.toolExecution.* - runs POST_TOOL_EXECUTION rules McpToolStep : - runs planner-driven MCP loops - can call multiple tools across a bounded loop - stores planner observations in context.mcp.observations - stores planner answer in context.mcp.finalAnswer - runs PRE_AGENT_MCP and POST_AGENT_MCP rule paths ## When should I use ANY scope? Only when the configuration is truly global. Use exact intent/state scope first. Move to ANY only when: - the behavior is genuinely shared - the blast radius is acceptable - the row still makes sense across all intended flows Overusing ANY is one of the easiest ways to create broad but subtle misbehavior. ## What is ce_verbose , and do I need it? ce_verbose is a runtime progress/error messaging table. It is strongly recommended in current v2 because it: - gives the UI and QA a readable progress layer - helps operators understand skipped or degraded paths - complements raw audit events It is not required for the engine to work, but most serious deployments should use it. ## What are the most important rule phases now? Current v2 phases are: - POST_DIALOGUE_ACT - POST_SCHEMA_EXTRACTION - PRE_AGENT_MCP - PRE_RESPONSE_RESOLUTION - POST_AGENT_INTENT - POST_AGENT_MCP - POST_TOOL_EXECUTION Legacy names are still normalized, but new configurations should use the current phase names. ## Can rules change more than state and intent? Yes. The rule engine can now do more than classic transition logic. Current actions include: - SET_STATE - SET_INTENT - SET_DIALOGUE_ACT - SET_INPUT_PARAM - SET_JSON - SET_TASK - GET_CONTEXT - GET_SCHEMA_JSON - GET_SESSION That makes rules more powerful, but also easier to misuse. Keep rule ownership disciplined. ## How should I think about ce_prompt_template in current v2? As both prompt content and runtime behavior metadata. In 2.0.9+ , prompt rows should also describe turn semantics using: - interaction_mode - interaction_contract That is what allows the framework to safely interpret whether a state supports: - affirm - edit - retry - reset - structured input collection ## Is prompt rendering still just {{var}} substitution? No. Current v2 uses a shared Thymeleaf-backed renderer. Supported patterns include: - {{var}} - #{...} - [${...}] This rendering path is used across prompt templates and ce_verbose messages. ## What are the most important runtime endpoints for debugging? The core ones are: - POST /api/v1/conversation/message - GET /api/v1/conversation/audit/{conversationId} - GET /api/v1/conversation/audit/{conversationId}/trace - POST /api/v1/cache/refresh - GET /api/v1/cache/analyze If experimental SQL generation is enabled: - POST /api/v1/conversation/experimental/generate-sql - POST /api/v1/conversation/experimental/generate-sql/zip ## What is the most important production safeguard the framework does not provide automatically? Conversation-level concurrency control. The framework does not give you built-in optimistic locking on ce_conversation , so you should prevent parallel active turns for the same conversationId . This is still the most important operational safeguard for correctness. ## How do we avoid 500s or broken user output for conversational mismatches? The best protection is layered: - make every reachable state have a valid response strategy - keep exact response/rule coverage for active flows - use UNKNOWN / ANY intentionally, not accidentally - test correction, failure, and no-match paths - inspect trace output before shipping config changes The goal is not just \"no exception.\" The goal is \"no misleading fallback that looks valid.\" ## Should new consumers enable everything immediately? No. The safest rollout path is: 1. One narrow intent and one deterministic response path. 2. Then schema collection. 3. Then confirmation/correction behavior. 4. Then pending actions or MCP. 5. Then verbose polish and richer streaming behavior. That sequence gives you a stable baseline before you widen the runtime surface.",
    "excerpt": "FAQ What version is the current v2 documentation aligned to? The current v2 docs are aligned to the active repo state and the current released line documented in this repo, which is 2.0.9 . That includes newer v2 additio…"
  },
  {
    "id": "local-development.mdx",
    "version": "v2",
    "title": "local development",
    "permalink": "/docs/v2/local-development",
    "content": "Local Development This page covers the practical local setup loop for the current v2 framework, not the early v2 minimum only setup. The modern local dev workflow should help you do five things reliably: boot the engine with the right annotations run one full conversation locally inspect audit and trace output reload static config safely debug rule, prompt, MCP, and response behavior quickly Local prerequisites Use these as the baseline: Java 21 a Spring Boot host application a local relational database with the current ce_ schema one working LlmClient bean Recommended for a productive setup: one seeded example intent audit enabled SSE enabled @EnableConvEngineCaching @EnableConvEngineAsyncConversation Minimal application wiring } } Add @EnableConvEngineAsyncAuditDispatch only if you want to test async audit dispatch behavior locally. Required consumer owned pieces Your local app still owns: LlmClient datasource and JPA config any custom task executors any tool handlers or transport adapters any response/container transformers you use If any of those are missing, the framework may start but your target flow will still be incomplete. Recommended local config Local database setup strategy For local development, do not start by seeding everything. A cleaner path is: 1. Apply the current DDL for your database dialect. 2. Seed one tiny end to end intent. 3. Add one response. 4. Add schema, rules, tools, or pending actions only when the base flow is stable. The smallest useful local slice is: one ce_intent one ce_intent_classifier one ce_prompt_template one ce_response Then add: ce_output_schema if the flow collects structured fields ce_rule if the flow has transitions ce_verbose if you want readable progress feedback ce_mcp_tool / ce_mcp_planner only when testing MCP Core local test loop This is the fastest stable loop for current v2: 1. Call POST /api/v1/conversation/message . 2. Inspect GET /api/v1/conversation/audit/ . 3. Inspect GET /api/v1/conversation/audit/ /trace . 4. Fix DML, prompt rows, or config. 5. Refresh caches if needed. 6. Re run the same or a fresh conversationId . That loop is still the single most useful way to debug behavior. Cache aware local development The current framework caches static control plane data. That is good for runtime performance, but it changes how local iteration feels. When you change seeded rows in tables like: ce_rule ce_response ce_output_schema ce_prompt_template ce_pending_action ce_mcp_tool ce_mcp_planner ce_verbose you should refresh the static cache before assuming the runtime sees the new data. Useful endpoints: POST /api/v1/cache/refresh GET /api/v1/cache/analyze Use cache analysis when you need to confirm whether the expected table cache is actually populated and active. Debugging the most important runtime surfaces 1. Rule and state debugging Check: RULE_MATCH RULE_APPLIED final intent_code and state_code trace step ordering If the engine is \"technically working\" but answering incorrectly, this is often where the root cause lives. 2. Prompt and LLM debugging Check: DIALOGUE_ACT_LLM_ INTENT_ SCHEMA_EXTRACTION_LLM_ MCP_PLAN_LLM_ RESOLVE_RESPONSE_LLM_ Modern v2 uses shared prompt rendering, so a prompt variable issue can affect multiple steps. 3. MCP debugging Check: context.mcp.lifecycle. context.mcp.toolExecution. MCP_TOOL_CALL MCP_TOOL_RESULT MCP_TOOL_ERROR MCP_FINAL_ANSWER Remember that current MCP scope is explicit. If a tool is not visible, verify intent_code , state_code , and whether the row is too narrow or too broad. 4. Direct tool debugging Check: tool_request tool_result tool_status TOOL_ORCHESTRATION_REQUEST TOOL_ORCHESTRATION_RESULT TOOL_ORCHESTRATION_ERROR When to enable optional local features STOMP Use STOMP locally only when you need to test websocket clients or broker behavior. If you do not need bidirectional messaging yet, keep: SSE enabled STOMP disabled Async audit dispatch Use it when you need to test local behavior under heavier audit load. Keep it off when you want the simplest, most deterministic debugging path. Experimental SQL generation Enable only when you are explicitly testing the experimental SQL generator APIs: POST /api/v1/conversation/experimental/generate sql POST /api/v1/conversation/experimental/generate sql/zip These routes are gated behind convengine.experimental.enabled=true . Most common local development mistakes Editing database config and forgetting to refresh caches. Testing with multiple browser tabs against the same conversationId . Enabling too many features before one base flow is stable. Treating prompt rows as plain text instead of behavior contracts. Inspecting only the final response and not the trace. Good local development target Your local environment is in good shape when you can do all of the following quickly: reproduce a good turn reproduce a bad turn explain the exact step where it went wrong fix the config rerun and verify the correction For current v2, the fastest path is still: change config, refresh cache, call /message , inspect audit/trace, repeat. The framework is heavily data driven, so a disciplined local trace loop is more valuable than ad hoc code debugging.",
    "rawContent": "# Local Development This page covers the practical local setup loop for the current v2 framework, not the early-v2 minimum-only setup. The modern local dev workflow should help you do five things reliably: - boot the engine with the right annotations - run one full conversation locally - inspect audit and trace output - reload static config safely - debug rule, prompt, MCP, and response behavior quickly ## Local prerequisites Use these as the baseline: - Java 21 - a Spring Boot host application - a local relational database with the current ce_* schema - one working LlmClient bean Recommended for a productive setup: - one seeded example intent - audit enabled - SSE enabled - @EnableConvEngineCaching - @EnableConvEngineAsyncConversation ## Minimal application wiring <CodeBlockToggle title=\"Recommended local bootstrap\" language=\"java\"> { @SpringBootApplication @EnableConvEngine(stream = true) @EnableConvEngineCaching @EnableConvEngineAsyncConversation public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> Add @EnableConvEngineAsyncAuditDispatch only if you want to test async audit dispatch behavior locally. ## Required consumer-owned pieces Your local app still owns: - LlmClient - datasource and JPA config - any custom task executors - any tool handlers or transport adapters - any response/container transformers you use If any of those are missing, the framework may start but your target flow will still be incomplete. ## Recommended local config <CodeBlockToggle title=\"Local application.yml baseline\" language=\"yaml\"> { server: port: 8080 spring: datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd convengine: flow: dialogue-act: resolute: REGEX_THEN_LLM llm-threshold: 0.90 conversation-history: max-turns: 20 interaction-policy: execute-pending-on-affirm: true reject-pending-on-negate: true fill-pending-slot-on-non-new-request: true require-resolved-intent-and-state: true action-lifecycle: enabled: true ttl-turns: 3 ttl-minutes: 30 tool-orchestration: enabled: true guardrail: enabled: true sanitize-input: true require-approval-for-sensitive-actions: false approval-gate-fail-closed: false sensitive-patterns: [] state-graph: enabled: true soft-block-on-violation: false disambiguation: enabled: true max-options: 5 memory: enabled: true summary-max-chars: 1200 recent-turns-for-summary: 3 query-rewrite: enabled: true transport: sse: enabled: true emitter-timeout-ms: 1800000 stomp: enabled: false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE relay-destination-prefixes: - /topic - /queue relay-host: localhost relay-port: 61613 audit: enabled: true persist-meta: true cache-inspector: false level: ALL include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: - ENGINE_KNOWN_FAILURE - ENGINE_UNKNOWN_FAILURE final-step-names: - PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS keep-alive-seconds: 60 mcp: guardrail: enabled: false fail-closed: false experimental: enabled: false } </CodeBlockToggle> ## Local database setup strategy For local development, do not start by seeding everything. A cleaner path is: 1. Apply the current DDL for your database dialect. 2. Seed one tiny end-to-end intent. 3. Add one response. 4. Add schema, rules, tools, or pending actions only when the base flow is stable. The smallest useful local slice is: - one ce_intent - one ce_intent_classifier - one ce_prompt_template - one ce_response Then add: - ce_output_schema if the flow collects structured fields - ce_rule if the flow has transitions - ce_verbose if you want readable progress feedback - ce_mcp_tool / ce_mcp_planner only when testing MCP ## Core local test loop This is the fastest stable loop for current v2: 1. Call POST /api/v1/conversation/message . 2. Inspect GET /api/v1/conversation/audit/{conversationId} . 3. Inspect GET /api/v1/conversation/audit/{conversationId}/trace . 4. Fix DML, prompt rows, or config. 5. Refresh caches if needed. 6. Re-run the same or a fresh conversationId . That loop is still the single most useful way to debug behavior. ## Cache-aware local development The current framework caches static control-plane data. That is good for runtime performance, but it changes how local iteration feels. When you change seeded rows in tables like: - ce_rule - ce_response - ce_output_schema - ce_prompt_template - ce_pending_action - ce_mcp_tool - ce_mcp_planner - ce_verbose you should refresh the static cache before assuming the runtime sees the new data. Useful endpoints: - POST /api/v1/cache/refresh - GET /api/v1/cache/analyze Use cache analysis when you need to confirm whether the expected table cache is actually populated and active. ## Debugging the most important runtime surfaces ### 1. Rule and state debugging Check: - RULE_MATCH - RULE_APPLIED - final intent_code and state_code - trace step ordering If the engine is \"technically working\" but answering incorrectly, this is often where the root cause lives. ### 2. Prompt and LLM debugging Check: - DIALOGUE_ACT_LLM_* - INTENT_* - SCHEMA_EXTRACTION_LLM_* - MCP_PLAN_LLM_* - RESOLVE_RESPONSE_LLM_* Modern v2 uses shared prompt rendering, so a prompt-variable issue can affect multiple steps. ### 3. MCP debugging Check: - context.mcp.lifecycle.* - context.mcp.toolExecution.* - MCP_TOOL_CALL - MCP_TOOL_RESULT - MCP_TOOL_ERROR - MCP_FINAL_ANSWER Remember that current MCP scope is explicit. If a tool is not visible, verify intent_code , state_code , and whether the row is too narrow or too broad. ### 4. Direct tool debugging Check: - tool_request - tool_result - tool_status - TOOL_ORCHESTRATION_REQUEST - TOOL_ORCHESTRATION_RESULT - TOOL_ORCHESTRATION_ERROR ## When to enable optional local features ### STOMP Use STOMP locally only when you need to test websocket clients or broker behavior. If you do not need bidirectional messaging yet, keep: - SSE enabled - STOMP disabled ### Async audit dispatch Use it when you need to test local behavior under heavier audit load. Keep it off when you want the simplest, most deterministic debugging path. ### Experimental SQL generation Enable only when you are explicitly testing the experimental SQL generator APIs: - POST /api/v1/conversation/experimental/generate-sql - POST /api/v1/conversation/experimental/generate-sql/zip These routes are gated behind convengine.experimental.enabled=true . ## Most common local-development mistakes - Editing database config and forgetting to refresh caches. - Testing with multiple browser tabs against the same conversationId . - Enabling too many features before one base flow is stable. - Treating prompt rows as plain text instead of behavior contracts. - Inspecting only the final response and not the trace. ## Good local-development target Your local environment is in good shape when you can do all of the following quickly: - reproduce a good turn - reproduce a bad turn - explain the exact step where it went wrong - fix the config - rerun and verify the correction <Highlight type=\"info\" title=\"Best local workflow\"> For current v2, the fastest path is still: change config, refresh cache, call /message , inspect audit/trace, repeat. The framework is heavily data-driven, so a disciplined local trace loop is more valuable than ad hoc code debugging. </Highlight>",
    "excerpt": "Local Development This page covers the practical local setup loop for the current v2 framework, not the early v2 minimum only setup. The modern local dev workflow should help you do five things reliably: boot the engine …"
  },
  {
    "id": "overview.mdx",
    "version": "v2",
    "title": "overview",
    "permalink": "/docs/v2/overview",
    "content": "ConvEngine Overview ConvEngine is a deterministic conversation workflow engine with explicit turn control steps for dialogue act, policy, pending action lifecycle, guardrails, tool orchestration, state graph validation, and memory. Core Features Turn understanding before intent re resolution: DialogueActStep InteractionPolicyStep CorrectionStep Pending action runtime control: ActionLifecycleStep DisambiguationStep PendingActionStep Safety controls: GuardrailStep StateGraphStep (validate only) Tool runtime unification: ToolOrchestrationStep McpToolStep with executor per tool group Memory and replay: MemoryStep ConversationReplayService Rule phases expanded with schema/MCP hooks: POST_SCHEMA_EXTRACTION PRE_AGENT_MCP POST_AGENT_MCP POST_TOOL_EXECUTION New control tables: ce_pending_action ce_verbose (runtime progress/error messaging) Runtime model ConvEngine remains config first: DB control plane: ce_intent , ce_rule , ce_response , ce_prompt_template , ce_pending_action , ce_verbose , ce_mcp_ Runtime policy config: convengine.flow. Deterministic pipeline with audited stage output Key outcomes Handles yes / ok / do that against pending context, not standalone intent. Avoids hidden state mutation by validating transitions ( StateGraphStep ) and auditing violations. Supports multiple tool groups ( DB , HTTP_API , WORKFLOW_ACTION , DOCUMENT_RETRIEVAL , CALCULATOR_TRANSFORM , NOTIFICATION , FILES ). Keeps every control decision visible in audit timeline. Next Reads",
    "rawContent": "# ConvEngine Overview ConvEngine is a deterministic conversation workflow engine with explicit turn-control steps for dialogue act, policy, pending-action lifecycle, guardrails, tool orchestration, state-graph validation, and memory. ## Core Features - Turn understanding before intent re-resolution: - DialogueActStep - InteractionPolicyStep - CorrectionStep - Pending action runtime control: - ActionLifecycleStep - DisambiguationStep - PendingActionStep - Safety controls: - GuardrailStep - StateGraphStep (validate-only) - Tool runtime unification: - ToolOrchestrationStep - McpToolStep with executor-per-tool-group - Memory and replay: - MemoryStep - ConversationReplayService - Rule phases expanded with schema/MCP hooks: - POST_SCHEMA_EXTRACTION - PRE_AGENT_MCP - POST_AGENT_MCP - POST_TOOL_EXECUTION - New control tables: - ce_pending_action - ce_verbose (runtime progress/error messaging) ## Runtime model ConvEngine remains config-first: - DB control plane: ce_intent* , ce_rule , ce_response , ce_prompt_template , ce_pending_action , ce_verbose , ce_mcp_* - Runtime policy config: convengine.flow.* - Deterministic pipeline with audited stage output ## Key outcomes - Handles yes / ok / do that against pending context, not standalone intent. - Avoids hidden state mutation by validating transitions ( StateGraphStep ) and auditing violations. - Supports multiple tool groups ( DB , HTTP_API , WORKFLOW_ACTION , DOCUMENT_RETRIEVAL , CALCULATOR_TRANSFORM , NOTIFICATION , FILES ). - Keeps every control decision visible in audit timeline. ## Next Reads - [Architecture](/docs/v2/architecture) - [Pipeline (Step-by-Step)](/docs/v2/deep-dive/pipeline-steps) - [Real World Examples (chat + DB + audit)](/docs/v2/examples) - [Detailed Features](/docs/v2/deep-dive/v2-features) - [Version History](/docs/v2/version-history)",
    "excerpt": "ConvEngine Overview ConvEngine is a deterministic conversation workflow engine with explicit turn control steps for dialogue act, policy, pending action lifecycle, guardrails, tool orchestration, state graph validation, …"
  },
  {
    "id": "version-history.mdx",
    "version": "v2",
    "title": "version history",
    "permalink": "/docs/v2/version-history",
    "content": "2.0.9 2.0.9 is the prompt control and correction routing release line. Compared to 2.0.8, this adds Thymeleaf backed prompt rendering, richer runtime routing for confirmations/corrections, new rule capabilities, and a consumer friendly verbose adapter. Shared Thymeleaf rendering path: prompts now render through ThymeleafTemplateRenderer ce_verbose.message / ce_verbose.error_message render through the same engine supported prompt styles: legacy } [$ ] session aware template variables include session , inputParams , rawInputParams , context , schema , schemaJson , promptVars , and metadata. Prompt/session variable upgrades: PromptTemplateContext now includes standalone_query and resolved_user_input resolved_user_input is derived from standaloneQuery first, then user_input Rule engine expansion: new action: SET_INPUT_PARAM new phases: POST_SCHEMA_EXTRACTION PRE_AGENT_MCP phase/state rule lookup now uses a dedicated cache path for faster repeated evaluation Dialogue and correction flow upgrades: new DialogueAct : ANSWER new CorrectionStep inserted before intent/schema resolution confirmation routing now uses routing_decision confirmation AFFIRM can skip reclassification/re extraction and continue to MCP confirmation EDIT can patch a single field in existing context without full schema extraction Verbose and audit coverage expansion: added LLM input/output/error verbose events across: dialogue act intent resolution schema extraction MCP planning response generation MCP_TOOL_CALL now emits richer metadata ( tool_code , args, action, intent, state, routing decision, observation context) Consumer extension support: new ConvEngineVerboseAdapter allows hooks, container transformers, response transformers, and custom beans to emit either: DB resolved ce_verbose events direct UI verbose text events 2.0.8 2.0.8 is the runtime observability and deterministic progress release line. Compared to 2.0.7, this adds database driven verbose messaging, step telemetry in session context, stream envelope upgrades, and tighter MCP schema completeness behavior. New control plane table for runtime verbose messaging: ce_verbose added across DDLs ( ddl.sql , ddl_postgres.sql , ddl_oracle.sql , ddl_sqlite.sql ). seed rows added across seeds ( seed.sql , seed_postgres.sql , seed_oracle.sql , seed_sqlite.sql ). standalone SQL assets added: src/main/resources/sql/verbose_ddl.sql src/main/resources/sql/verbose_seed.sql Static cache integration for verbose table: StaticConfigurationCacheService getAllVerboses() with cache key ce_verbose . preload and integrity validation wired into startup ( StaticTableCachePreloader , StaticScopeIntegrityValidator ). validation now enforces step_match in EXACT|REGEX|JSON_PATH and non empty step_value / determinant . New verbose runtime transport model: VerboseStreamPayload DTO added. stream envelope ( AuditStreamEventResponse ) now includes: eventType optional verbose payload both SSE and STOMP publish AUDIT and VERBOSE events on conversation channel. Step telemetry model added to session: new StepInfo model EngineSession.stepInfos now stores per step status/timing/outcome/error metadata pipeline writes deterministic step markers ( STEP_ENTER , STEP_EXIT , STEP_ERROR ). Verbose publishing across core pipeline and resolvers: step lifecycle ( EnginePipelineFactory hook path) intent lifecycle ( AgentIntentResolver ) rule lifecycle ( RulesStep , RuleActionResolverFactory ) response/output resolver selection ( ResponseTypeResolverFactory , OutputFormatResolverFactory ) tool + MCP lifecycle ( ToolOrchestrationStep , McpToolStep ) response resolution ( ResponseResolutionStep ) MCP schema completeness hardening: new stage MCP_SKIPPED_SCHEMA_INCOMPLETE new status STATUS_SKIPPED_SCHEMA_INCOMPLETE McpToolStep now skips MCP execution when schema required fields are missing and writes lifecycle metadata deterministically. 2.0.7 2.0.7 is the MCP revamp release line. Compared to 2.0.6, this adds planner scoped prompts, advanced tool execution modes, stricter static scope validation, richer MCP runtime metadata, and renamed rule phases. Advanced MCP execution model: DB handler first path ( DbToolHandler ) with SQL template fallback. HTTP handler models: HttpApiProcessorToolHandler ( / RestWebServiceFacade path) HttpApiRequestingToolHandler (framework managed request policy path) classic HttpApiToolHandler . HTTP policy support in framework invoker: timeout, retry/backoff, in memory circuit breaker, auth providers, response mapping. MCP planner scoping table: ce_mcp_planner with intent/state scoped prompt selection. seed support added for Postgres/SQLite planner rows. MCP context metadata model for rule branching: context.mcp.lifecycle. context.mcp.toolExecution. enables deterministic ce_rule.match_pattern JSON_PATH checks. Guardrail behavior clarity: when planner proposes blocked next tool, fallback answer is written to context.mcp.finalAnswer . POST_AGENT_MCP rules still run, then normal response resolution. MCP guardrail + determinism upgrades: planner output is validated against allowed next tool policy before execution. blocked decisions emit deterministic lifecycle metadata for rule branching. Tool execution observability upgrade: direct tool mode writes rich metadata into context.mcp.toolExecution. including toolCode , toolGroup , status/outcome, scope mismatch flags, and tool row metadata. Scope consistency hardening in static config: ce_mcp_tool / ce_mcp_planner scope values are validated at load/startup ( intent_code , state_code ) against allowed forms ( ANY , UNKNOWN , configured values). invalid scope rows fail fast to prevent cross intent tool leakage. ce_intent_classifier enhancement: state_code support (default UNKNOWN ) so classifier can set state directly without extra transition rules. Rule phase naming update: PRE_RESPONSE_RESOLUTION (old PIPELINE_RULES ) POST_AGENT_INTENT (old AGENT_POST_INTENT ) POST_AGENT_MCP (old AGENT_POST_MCP ) POST_TOOL_EXECUTION (old TOOL_POST_EXECUTION ) runtime normalization keeps old phase values compatible during migration. MCP docs expansion: advanced guide updates for metadata and rule patterns. new dedicated with chat by chat flow, table impact, and step graph. 2.0.6 2.0.6 focused on cache reliability and diagnostics to eliminate static table query noise in consumer environments. Proxy hygiene for static caches : StaticConfigurationCacheService helper paths now resolve through the Spring proxied bean so @Cacheable consistently suppresses repeated ce_ static table SQL after warmup. ConvEngineCacheAnalyzer + diagnostics endpoint : Added GET /api/v1/cache/analyze (with optional warmup flag) to expose active CacheManager metadata, Spring cache properties, cache infrastructure beans, runtime AOP proxy/advisor diagnostics, SimpleKey.EMPTY entry visibility, native cache counts, and warmup timing deltas. Operational debugging uplift : Teams can now validate cache hit/miss behavior directly in runtime and quickly detect provider/proxy misconfiguration in enterprise deployments. 2.0.5 Introduces massive execution path optimizations targeting latency removal, background history persistence, and static framework component caching. Static Configurations Cache Loader : All static framework properties ( ce_intent , ce_rule , ce_mcp_tool , etc.) are pre loaded entirely into memory on JVM live via StaticTableCachePreloader , dropping complex query I/O across RulesStep and InteractionPolicyStep to sub millisecond evaluate times. Cache Eviction API : Deployed /api/v1/cache/refresh endpoint natively inside ConvEngineCacheController to allow database administrators to immediately flush and reload RAM without bouncing the application. Async LLM Call Logging : Integrated @Async onto LlmCallLogPersistenceService . Lengthy physical HTTP prompts/completions are recorded in background threads preserving microsecond user facing SLA times. History DDL Revolution : Hard deprecated noisy legacy role & stage ce_conversation_history table arrays. Decoupled history updates away from the core DbAuditService pipeline loop entirely, deploying an explicit user_input + assistant_output monolithic string format that tracks asynchronously inside the final PipelineEndGuardStep . SQLite Timezone Idempotency : Normalized all underlying timestamp extractions across standard JSON mapping using formal JVM jackson datatype jsr310 deployments and rigorous OffsetDateTime string converters preserving micro transaction timezone stability across disparate engine host OS profiles. 2.0.4 Patches internal OffsetDateTime JSON serialization stability when executing audit cache inspection. JavaTimeModule Jackson Integration : Formally added the jackson datatype jsr310 dependency to the core engine pom.xml build matrix. CacheInspectAuditStep Modularization : Refactored the step to insulate itself from potentially unconfigured host Spring application contexts. It now natively spins up and governs a strictly private internal ObjectMapper exclusively pre configured with the JavaTimeModule and ISO 8601 formatting to cleanly convert internal OffsetDateTime objects found inside ce_conversation . 2.0.3 Introduces deep cache auditing utilities and executor level history optimization. Cache Inspection Audit Logging : Added a dedicated CacheInspectAuditStep and the convengine.audit.cache inspector boolean property. When enabled, the engine evaluates a full JSON snapshot of the hydrated EngineSession conversation cache tree and logs it to ce_audit under the CACHE_INSPECTION stage before user input audits finalize. Global Audit Meta Metadata : The DbAuditService now natively intercepts convengine.audit.cache inspector triggers to permanently append a discrete _cache analysis object map inside the _meta root node across all audit phases for continuous memory visibility. Optimized Executor History Provisioning : Refactored the underlying conversational history provisioner array evaluation ( historyProvider.lastTurns(...) ) natively into the root DefaultConversationalEngine.process ingress method. This formally prevents downstream LLM nodes from executing entirely redundant ce_conversation relational database queries across consecutive lifecycle turns. 2.0.2 Introduces deep performance optimizations targeting conversational latency, RAG context injection, and rigid data payloads. Query Rewrite (Contextual RAG) : Added convengine.flow.query rewrite.enabled property. DialogueActStep now natively evaluates conversation history to extract a standaloneQuery into session parameters, allowing downstream RAG tools to receive explicit context without incurring secondary LLM execution penalties. JSON Payload Flattening : Patched EngineSession storage logic to aggressively filter redundant structural blocks ( CONTEXT , SCHEMA_JSON , SESSION ) before database serialization, permanently resolving exponential payload bloat inside ce_conversation.input_params_json . Framework Caching & Async Pipelines Integrated standard Spring @Cacheable and @Async interfaces over all state persistence mutations to entirely decouple zero latency edge delivery from blocking background Relational Database I/O. Introduced explicitly managed @EnableConvEngineCaching and @EnableConvEngineAsyncConversation consumer integration decorators. Automatically intercepts the internal engine pipeline via Spring's CacheManager to execute synchronous memory writes while offloading slow I/O Relational DB saves to background asynchronous threads. 2.0.1 Add audit metadata support for prompt rendering and context Introduced new fields in PromptTemplateContext : templateName systemPrompt userPrompt session (EngineSession) Updated all response format resolvers ( JsonOutputFormatResolver , TextOutputFormatResolver ) to build a context that includes the new metadata. Updated intent resolution, disambiguation, schema extraction and MCP planner steps to supply the new metadata when creating PromptTemplateContext . Enhanced PromptTemplateRenderer : Collects metadata (selected prompt, system/user prompts, session dump, and prompt variables) into a map. Throws ConversationEngineException with the metadata via withMetaData . Added a metaData field and withMetaData() method to ConversationEngineException . Updated imports across modified classes. Adjusted the database DDL for SQLite to use strftime('%Y %m %d %H:%M:%f', 'now') for timestamp defaults. Bumped project version to 2.0.1 in pom.xml . These changes provide richer audit traces for prompt usage and enable better debugging of engine behaviour. 2.0.0 Major runtime engine evolution focused on production grade turn control, tool orchestration, safety, and observability. Major runtime engine evolution focused on production grade turn control, tool orchestration, safety, and observability. Major runtime engine evolution focused on production grade turn control, tool orchestration, safety, and observability. 1. Robust Pending Action & Task Execution Lifecycle Introduction of ce_pending_action : A new core configuration table used to catalog multi turn action candidates by intent, state, and action_key . Features indexed lookups idx_ce_pending_action_lookup across enabled , action_key , intent_code , and state_code . PendingActionRepository : Added Spring Data JPA queries focused on filtering eligible actions by phase, intent ( intentCode IS NULL OR ... ), state ( stateCode IS NULL OR ... ), and enabled status, ordering strictly by integer priority . CePendingAction Entity : A JPA entity mapping to ce_pending_action with bean_name , method_names , priority , intent_code , and state_code enabling highly parameterized late binding invocations. ActionLifecycleStep : A top level orchestration step responsible for managing the state transitions of modular pending actions within the conversation. Actions are stored in the session context as IN_PROGRESS pending definitive confirmation from the user. It evaluates configurable Time To Live parameters ( convengine.flow.action lifecycle.ttl turns and ttl minutes ). PendingActionStep : A core execution step designed to finalize these actions. It routes the action to the corresponding bean_name and method_names if the user successfully confirms the action sequence. CeTaskExecutor : A specialized executor pattern designed to securely evaluate and invoke pending tasks synchronously within the strict temporal limits of the conversational turn. Context Lifecycle Persistence : The engine tracks the holistic lifecycle of these actions ( OPEN , IN_PROGRESS , EXECUTED , REJECTED , EXPIRED ) purely in the stringified JSON memory context map ( pending_action_runtime ), meticulously decoupled from the static table definition. Disambiguation Matrix Controls : Pending actions that are ambiguous or require explicit missing slot inputs before execution dynamically trigger the new disambiguation mechanisms to halt execution, stash the context, and query the user. 2. Deterministic Interaction Policies & Dialogue Acts DialogueActStep : A brand new classification pipeline step heavily augmenting the traditional NLP pass. Instead of relying purely on heavy LLM intent classification for simple operational conversational shifts, this step evaluates the user's raw input against fast strict Pattern Regex patterns ( AFFIRM , NEGATE , EDIT , RESET ) before triggering fallback heuristic LLM logic. Dialogue Act Taxonomy : Standardized ENUM classification integrated precisely into ConvEngineInputParamKey.DIALOGUE_ACT including AFFIRM (yes, proceed), NEGATE (no, cancel), EDIT (change something), RESET (start over), QUESTION (inquiry), and NEW_REQUEST (topic switch). DialogueActResolveMode Enum : Explicit execution evaluation modes ( REGEX_ONLY , REGEX_THEN_LLM , LLM_ONLY ) allowing the system to rapidly identify acts using extremely fast regex thresholds prior to paying LLM generation costs. InteractionPolicyStep & InteractionPolicyDecision : The primary \"brain\" of the v2 matrix routing implementation. This step evaluates the DialogueAct alongside the current discrete SessionState . For instance, if a pending action is marked IN_PROGRESS in memory, and the new turn evaluates to the act AFFIRM , it makes an instantaneous deterministic policy decision EXECUTE_PENDING_ACTION . If it evaluates to NEGATE , it selects REJECT_PENDING_ACTION . If it's QUESTION , it evaluates to FILL_PENDING_SLOT . This massive enhancement completely bypasses stochastic LLM generative behaviors for discrete boolean pathing. 3. Strict MCP Tool Management and Orchestration Scoping CeMcpTool Scope Isolation : The intent_code and state_code columns were physically integrated into the ce_mcp_tool table architecture to formally mandate extreme compartmentalization of tool access limits. Tools are strictly bound to domains and are no longer assumed \"global by default.\" McpToolRepository Refactoring : Updated JPQL definitions in the repository ( findEnabledByIntentAndState , findByToolCodeEnabledAndIntentAndState ) leveraging the Spring Data @Param annotation to guarantee tools are flawlessly filtered. The internal McpPlanner is logically isolated from discovering tools sitting externally to the current active conversational domain intent scope. McpToolRegistry Improvements : A hardened centralized registry mechanism uniquely responsible for standardizing tool_group domains and resolving perfectly legal tools for a given conversation cycle loop, mathematically preventing hallucinations where an LLM invokes an unbound tool. McpToolExecutor Interface Expansion : Designed a formalized executor functional contract natively implemented by a vast array of specialized business adapters for standardized output structures. New Executor Adapter Implementations : Delivered fully mocked execution wrappers capable of expanding to live implementations: McpDbToolExecutor : For parsing database querying and modification parameter mapping tools. McpHttpApiToolExecutor : For serializing outbound REST/SOAP API tool integrations. McpWorkflowActionToolExecutor : For complex cross system async workflow pipeline triggers. McpDocumentRetrievalToolExecutor : For executing dynamic RAG (Retrieval Augmented Generation) Knowledge Base queries. McpCalculatorTransformToolExecutor : For executing deterministic programmatic mathematical transformations. McpFileToolExecutor : For OS level file parsing, reading, generation, and file management tools. McpNotificationToolExecutor : For serializing logic aimed at SMS/Email/Push notification gateways. Early Exit Execution Guardrails : ToolOrchestrationStep and McpToolStep logic matrices were fortified to immediately halt and bypass tool discovery planning on simple conversational greetings (e.g., regex checks against hi , hello , good morning ) or explicit internal dialogue acts ( AFFIRM , NEGATE ) to drastically curb overhead computational latency and expensive LLM generative token expenditures. 4. Advanced Pipeline Governance: Memory, Guardrails, and Graphs GuardrailStep Framework : A foundational preventative pipeline step strategically positioned to screen dynamic inputs against hardcoded blocked configuration patterns or sanitize output payload injections before advancing. Generates robust metrics to soft block or strictly hard block the ConvEngineInputParamKey.STATE_GRAPH_VALID control parameter. DisambiguationStep Integration : An autonomous discrete evaluation system boundary. If multiple valid intents or competing multi turn pending actions exhibit mathematically adjacent probabilities (Confidence score collisions), this step halts the internal execution state transitions and forces a deterministic query back to the end user for explicit disambiguation. StateGraphStep Validation : Built an internal compliance enforcement algorithm explicitly assessing whether the current proposed transition route from State A State B functionally complies with the statically mapped topologies inside the convengine.flow.state graph.allowed transitions logic limits. MemoryStep and ConversationMemoryStore Context Modeling : Engineered a long term conversation compression service layer. The orchestration engine dynamically aggregates rolling conversation turns bounded by the recent turns for summary threshold and compresses them into a highly compact ConvEngineInputParamKey.MEMORY_SESSION_SUMMARY . This drastically scales up context capacities, permitting the underlying LLM to seamlessly address sliding window follow up questions without wasting tokens continuously re parsing huge historical payload stacks. 5. Deterministic Evaluation and Replay CI/CD Logics ConversationReplayService Orchestration : Wrote advanced system test capabilities modeled exclusively for deep auditing metrics and automated CI/CD gating strategies. It fundamentally enables developers to parse a target conversation_id string into the service to perfectly replay historical conversational turns sequentially across the precise state parameters to test robustness over time. TraceExpectation Object Structure : Represents the mathematical and contextual logical assertions required during a turn replay scenario (e.g., Assert Intent == X , Assert Dialogue Act == Y ). TraceReplayResult & TraceTurnResult Analytics : Deployed overarching replay evaluation metrics classes designed to empower automated pipelines with the tooling necessary to validate whether newly submitted behavior rules applied directly within ce_rule or ce_policy unexpectedly fractured long standing static historically recorded conversation progression structures. SQL Initialization DDL Enhancements : Segmented and significantly refactored database procedural seeding generation structures intended for clean, error free automated platform tests. Explicitly divided the sprawling monolithic ddl.sql logic into dedicated dialect specific SQL instances ( seed_sqlite.sql , seed_postgres.sql , seed_oracle.sql ). Spliced all auto generated DBeaver boilerplate syntax elements and strategically configured dependency oriented DROP TABLE definitions to ensure identically idempotent and stateless automated unit test deployment loops continuously without breaking consistency schemas. Added new steps DialogueActStep InteractionPolicyStep ActionLifecycleStep DisambiguationStep GuardrailStep ToolOrchestrationStep StateGraphStep MemoryStep PendingActionStep enhanced for robust policy/lifecycle integration Added new flow configuration model ConvEngineFlowConfig ( convengine.flow. ) dialogue act interaction policy matrix action lifecycle TTL disambiguation options guardrail controls state graph settings tool orchestration toggle memory summary settings Added new control table ce_pending_action action catalog for pending action execution indexed by action key/intent/state/priority Added new rule phases POST_AGENT_MCP POST_TOOL_EXECUTION Added tool execution architecture McpToolExecutor interface group executors for: DB HTTP_API WORKFLOW_ACTION DOCUMENT_RETRIEVAL CALCULATOR_TRANSFORM NOTIFICATION FILES adapter interfaces for consumer implementations Added memory and replay scaffolding ConversationMemoryStore ConversationReplayService replay model classes ( Trace ) Added audit stage coverage Expanded audit visibility for: dialogue act and interaction policy dialogue act LLM input/output/error checkpoints ( DIALOGUE_ACT_LLM_INPUT , DIALOGUE_ACT_LLM_OUTPUT , DIALOGUE_ACT_LLM_ERROR ) post dialogue act override hook via POST_DIALOGUE_ACT and SET_DIALOGUE_ACT pending action lifecycle and execution disambiguation requirements guardrail allow/deny tool orchestration request/result/error state graph validation/violation memory updates post phase rule metadata 1.x line Use the version dropdown to switch to v1 documentation.",
    "rawContent": "## 2.0.9 2.0.9 is the prompt-control and correction-routing release line. Compared to 2.0.8, this adds Thymeleaf-backed prompt rendering, richer runtime routing for confirmations/corrections, new rule capabilities, and a consumer-friendly verbose adapter. - Shared Thymeleaf rendering path: - prompts now render through ThymeleafTemplateRenderer - ce_verbose.message / ce_verbose.error_message render through the same engine - supported prompt styles: - legacy {{var}} - #{...} - [${...}] - session-aware template variables include session , inputParams , rawInputParams , context , schema , schemaJson , promptVars , and metadata. - Prompt/session variable upgrades: - PromptTemplateContext now includes standalone_query and resolved_user_input - resolved_user_input is derived from standaloneQuery first, then user_input - Rule engine expansion: - new action: SET_INPUT_PARAM - new phases: - POST_SCHEMA_EXTRACTION - PRE_AGENT_MCP - phase/state rule lookup now uses a dedicated cache path for faster repeated evaluation - Dialogue and correction flow upgrades: - new DialogueAct : ANSWER - new CorrectionStep inserted before intent/schema resolution - confirmation routing now uses routing_decision - confirmation AFFIRM can skip reclassification/re-extraction and continue to MCP - confirmation EDIT can patch a single field in existing context without full schema extraction - Verbose and audit coverage expansion: - added LLM input/output/error verbose events across: - dialogue act - intent resolution - schema extraction - MCP planning - response generation - MCP_TOOL_CALL now emits richer metadata ( tool_code , args, action, intent, state, routing decision, observation context) - Consumer extension support: - new ConvEngineVerboseAdapter allows hooks, container transformers, response transformers, and custom beans to emit either: - DB-resolved ce_verbose events - direct UI verbose text events ## 2.0.8 2.0.8 is the runtime observability and deterministic-progress release line. Compared to 2.0.7, this adds database-driven verbose messaging, step telemetry in session context, stream envelope upgrades, and tighter MCP schema completeness behavior. - New control-plane table for runtime verbose messaging: - ce_verbose added across DDLs ( ddl.sql , ddl_postgres.sql , ddl_oracle.sql , ddl_sqlite.sql ). - seed rows added across seeds ( seed.sql , seed_postgres.sql , seed_oracle.sql , seed_sqlite.sql ). - standalone SQL assets added: - src/main/resources/sql/verbose_ddl.sql - src/main/resources/sql/verbose_seed.sql - Static cache integration for verbose table: - StaticConfigurationCacheService#getAllVerboses() with cache key ce_verbose . - preload and integrity validation wired into startup ( StaticTableCachePreloader , StaticScopeIntegrityValidator ). - validation now enforces step_match in EXACT|REGEX|JSON_PATH and non-empty step_value / determinant . - New verbose runtime transport model: - VerboseStreamPayload DTO added. - stream envelope ( AuditStreamEventResponse ) now includes: - eventType - optional verbose payload - both SSE and STOMP publish AUDIT and VERBOSE events on conversation channel. - Step telemetry model added to session: - new StepInfo model - EngineSession.stepInfos now stores per-step status/timing/outcome/error metadata - pipeline writes deterministic step markers ( STEP_ENTER , STEP_EXIT , STEP_ERROR ). - Verbose publishing across core pipeline and resolvers: - step lifecycle ( EnginePipelineFactory hook path) - intent lifecycle ( AgentIntentResolver ) - rule lifecycle ( RulesStep , RuleActionResolverFactory ) - response/output resolver selection ( ResponseTypeResolverFactory , OutputFormatResolverFactory ) - tool + MCP lifecycle ( ToolOrchestrationStep , McpToolStep ) - response resolution ( ResponseResolutionStep ) - MCP schema completeness hardening: - new stage MCP_SKIPPED_SCHEMA_INCOMPLETE - new status STATUS_SKIPPED_SCHEMA_INCOMPLETE - McpToolStep now skips MCP execution when schema-required fields are missing and writes lifecycle metadata deterministically. ## 2.0.7 2.0.7 is the MCP revamp release line. Compared to 2.0.6, this adds planner-scoped prompts, advanced tool execution modes, stricter static scope validation, richer MCP runtime metadata, and renamed rule phases. - Advanced MCP execution model: - DB handler-first path ( DbToolHandler ) with SQL-template fallback. - HTTP handler models: - HttpApiProcessorToolHandler ([api-processor](https://github.com/salilvnair/api-processor) / RestWebServiceFacade path) - HttpApiRequestingToolHandler (framework-managed request policy path) - classic HttpApiToolHandler . - HTTP policy support in framework invoker: - timeout, retry/backoff, in-memory circuit breaker, auth providers, response mapping. - MCP planner scoping table: - ce_mcp_planner with intent/state scoped prompt selection. - seed support added for Postgres/SQLite planner rows. - MCP context metadata model for rule branching: - context.mcp.lifecycle.* - context.mcp.toolExecution.* - enables deterministic ce_rule.match_pattern JSON_PATH checks. - Guardrail behavior clarity: - when planner proposes blocked next tool, fallback answer is written to context.mcp.finalAnswer . - POST_AGENT_MCP rules still run, then normal response resolution. - MCP guardrail + determinism upgrades: - planner output is validated against allowed-next-tool policy before execution. - blocked decisions emit deterministic lifecycle metadata for rule branching. - Tool execution observability upgrade: - direct tool mode writes rich metadata into context.mcp.toolExecution.* including toolCode , toolGroup , status/outcome, scope mismatch flags, and tool row metadata. - Scope consistency hardening in static config: - ce_mcp_tool / ce_mcp_planner scope values are validated at load/startup ( intent_code , state_code ) against allowed forms ( ANY , UNKNOWN , configured values). - invalid scope rows fail fast to prevent cross-intent tool leakage. - ce_intent_classifier enhancement: - state_code support (default UNKNOWN ) so classifier can set state directly without extra transition rules. - Rule phase naming update: - PRE_RESPONSE_RESOLUTION (old PIPELINE_RULES ) - POST_AGENT_INTENT (old AGENT_POST_INTENT ) - POST_AGENT_MCP (old AGENT_POST_MCP ) - POST_TOOL_EXECUTION (old TOOL_POST_EXECUTION ) - runtime normalization keeps old phase values compatible during migration. - MCP docs expansion: - advanced guide updates for metadata and rule patterns. - new dedicated [MCP Deep Dive](/docs/v2/consumer/mcp/deep-dive) with chat-by-chat flow, table impact, and step graph. ## 2.0.6 2.0.6 focused on cache reliability and diagnostics to eliminate static-table query noise in consumer environments. - **Proxy hygiene for static caches**: StaticConfigurationCacheService helper paths now resolve through the Spring proxied bean so @Cacheable consistently suppresses repeated ce_* static table SQL after warmup. - ** ConvEngineCacheAnalyzer + diagnostics endpoint**: Added GET /api/v1/cache/analyze (with optional warmup flag) to expose active CacheManager metadata, Spring cache properties, cache infrastructure beans, runtime AOP proxy/advisor diagnostics, SimpleKey.EMPTY entry visibility, native cache counts, and warmup timing deltas. - **Operational debugging uplift**: Teams can now validate cache hit/miss behavior directly in runtime and quickly detect provider/proxy misconfiguration in enterprise deployments. ## 2.0.5 Introduces massive execution path optimizations targeting latency removal, background history persistence, and static framework component caching. - **Static Configurations Cache Loader**: All static framework properties ( ce_intent , ce_rule , ce_mcp_tool , etc.) are pre-loaded entirely into memory on JVM live via StaticTableCachePreloader , dropping complex query I/O across RulesStep and InteractionPolicyStep to sub-millisecond evaluate times. - **Cache Eviction API**: Deployed /api/v1/cache/refresh endpoint natively inside ConvEngineCacheController to allow database administrators to immediately flush and reload RAM without bouncing the application. - **Async LLM Call Logging**: Integrated @Async onto LlmCallLogPersistenceService . Lengthy physical HTTP prompts/completions are recorded in background threads preserving microsecond user-facing SLA times. - **History DDL Revolution**: Hard-deprecated noisy legacy role & stage ce_conversation_history table arrays. Decoupled history updates away from the core DbAuditService pipeline loop entirely, deploying an explicit user_input + assistant_output monolithic string format that tracks asynchronously inside the final PipelineEndGuardStep . - **SQLite Timezone Idempotency**: Normalized all underlying timestamp extractions across standard JSON mapping using formal JVM jackson-datatype-jsr310 deployments and rigorous OffsetDateTime string converters preserving micro-transaction timezone stability across disparate engine host OS profiles. ## 2.0.4 Patches internal OffsetDateTime JSON serialization stability when executing audit cache inspection. - ** JavaTimeModule Jackson Integration**: Formally added the jackson-datatype-jsr310 dependency to the core engine pom.xml build matrix. - ** CacheInspectAuditStep Modularization**: Refactored the step to insulate itself from potentially unconfigured host Spring application contexts. It now natively spins up and governs a strictly private internal ObjectMapper exclusively pre-configured with the JavaTimeModule and ISO-8601 formatting to cleanly convert internal OffsetDateTime objects found inside ce_conversation . ## 2.0.3 Introduces deep cache auditing utilities and executor-level history optimization. - **Cache Inspection Audit Logging**: Added a dedicated CacheInspectAuditStep and the convengine.audit.cache-inspector boolean property. When enabled, the engine evaluates a full JSON snapshot of the hydrated EngineSession conversation cache tree and logs it to ce_audit under the CACHE_INSPECTION stage before user input audits finalize. - **Global Audit Meta Metadata**: The DbAuditService now natively intercepts convengine.audit.cache-inspector triggers to permanently append a discrete _cache analysis object map inside the _meta root node across all audit phases for continuous memory visibility. - **Optimized Executor History Provisioning**: Refactored the underlying conversational history provisioner array evaluation ( historyProvider.lastTurns(...) ) natively into the root DefaultConversationalEngine.process ingress method. This formally prevents downstream LLM nodes from executing entirely redundant ce_conversation relational database queries across consecutive lifecycle turns. ## 2.0.2 Introduces deep performance optimizations targeting conversational latency, RAG context injection, and rigid data payloads. - **Query Rewrite (Contextual RAG)**: Added convengine.flow.query-rewrite.enabled property. DialogueActStep now natively evaluates conversation history to extract a standaloneQuery into session parameters, allowing downstream RAG tools to receive explicit context without incurring secondary LLM execution penalties. - **JSON Payload Flattening**: Patched EngineSession storage logic to aggressively filter redundant structural blocks ( CONTEXT , SCHEMA_JSON , SESSION ) before database serialization, permanently resolving exponential payload bloat inside ce_conversation.input_params_json . - **Framework Caching & Async Pipelines** - Integrated standard Spring @Cacheable and @Async interfaces over all state persistence mutations to entirely decouple zero-latency edge delivery from blocking background Relational Database I/O. - Introduced explicitly managed @EnableConvEngineCaching and @EnableConvEngineAsyncConversation consumer integration decorators. - Automatically intercepts the internal engine pipeline via Spring's CacheManager to execute synchronous memory writes while offloading slow I/O Relational DB saves to background asynchronous threads. ## 2.0.1 Add audit metadata support for prompt rendering and context - Introduced new fields in PromptTemplateContext : * templateName * systemPrompt * userPrompt * session (EngineSession) - Updated all response format resolvers ( JsonOutputFormatResolver , TextOutputFormatResolver ) to build a context that includes the new metadata. - Updated intent resolution, disambiguation, schema extraction and MCP planner steps to supply the new metadata when creating PromptTemplateContext . - Enhanced PromptTemplateRenderer : * Collects metadata (selected prompt, system/user prompts, session dump, and prompt variables) into a map. * Throws ConversationEngineException with the metadata via withMetaData . - Added a metaData field and withMetaData() method to ConversationEngineException . - Updated imports across modified classes. - Adjusted the database DDL for SQLite to use strftime('%Y-%m-%d %H:%M:%f', 'now') for timestamp defaults. - Bumped project version to **2.0.1** in pom.xml . These changes provide richer audit traces for prompt usage and enable better debugging of engine behaviour. ## 2.0.0 Major runtime engine evolution focused on production-grade turn control, tool orchestration, safety, and observability. Major runtime engine evolution focused on production-grade turn control, tool orchestration, safety, and observability. Major runtime engine evolution focused on production-grade turn control, tool orchestration, safety, and observability. ### 1. Robust Pending Action & Task Execution Lifecycle - **Introduction of ce_pending_action **: A new core configuration table used to catalog multi-turn action candidates by intent, state, and action_key . Features indexed lookups idx_ce_pending_action_lookup across enabled , action_key , intent_code , and state_code . - ** PendingActionRepository **: Added Spring Data JPA queries focused on filtering eligible actions by phase, intent ( intentCode IS NULL OR ... ), state ( stateCode IS NULL OR ... ), and enabled status, ordering strictly by integer priority . - ** CePendingAction Entity**: A JPA entity mapping to ce_pending_action with bean_name , method_names , priority , intent_code , and state_code enabling highly parameterized late-binding invocations. - ** ActionLifecycleStep **: A top-level orchestration step responsible for managing the state transitions of modular pending actions within the conversation. Actions are stored in the session context as IN_PROGRESS pending definitive confirmation from the user. It evaluates configurable Time-To-Live parameters ( convengine.flow.action-lifecycle.ttl-turns and ttl-minutes ). - ** PendingActionStep **: A core execution step designed to finalize these actions. It routes the action to the corresponding bean_name and method_names if the user successfully confirms the action sequence. - ** CeTaskExecutor **: A specialized executor pattern designed to securely evaluate and invoke pending tasks synchronously within the strict temporal limits of the conversational turn. - **Context Lifecycle Persistence**: The engine tracks the holistic lifecycle of these actions ( OPEN , IN_PROGRESS , EXECUTED , REJECTED , EXPIRED ) purely in the stringified JSON memory context map ( pending_action_runtime ), meticulously decoupled from the static table definition. - **Disambiguation Matrix Controls**: Pending actions that are ambiguous or require explicit missing slot inputs before execution dynamically trigger the new disambiguation mechanisms to halt execution, stash the context, and query the user. ### 2. Deterministic Interaction Policies & Dialogue Acts - ** DialogueActStep **: A brand new classification pipeline step heavily augmenting the traditional NLP pass. Instead of relying purely on heavy LLM intent classification for simple operational conversational shifts, this step evaluates the user's raw input against fast strict Pattern Regex patterns ( AFFIRM , NEGATE , EDIT , RESET ) before triggering fallback heuristic LLM logic. - **Dialogue Act Taxonomy**: Standardized ENUM classification integrated precisely into ConvEngineInputParamKey.DIALOGUE_ACT including AFFIRM (yes, proceed), NEGATE (no, cancel), EDIT (change something), RESET (start over), QUESTION (inquiry), and NEW_REQUEST (topic switch). - ** DialogueActResolveMode Enum**: Explicit execution evaluation modes ( REGEX_ONLY , REGEX_THEN_LLM , LLM_ONLY ) allowing the system to rapidly identify acts using extremely fast regex thresholds prior to paying LLM generation costs. - ** InteractionPolicyStep & InteractionPolicyDecision **: The primary \"brain\" of the v2 matrix routing implementation. This step evaluates the DialogueAct alongside the current discrete SessionState . For instance, if a pending action is marked IN_PROGRESS in memory, and the new turn evaluates to the act AFFIRM , it makes an instantaneous deterministic policy decision EXECUTE_PENDING_ACTION . If it evaluates to NEGATE , it selects REJECT_PENDING_ACTION . If it's QUESTION , it evaluates to FILL_PENDING_SLOT . This massive enhancement completely bypasses stochastic LLM generative behaviors for discrete boolean pathing. ### 3. Strict MCP Tool Management and Orchestration Scoping - ** CeMcpTool Scope Isolation**: The intent_code and state_code columns were physically integrated into the ce_mcp_tool table architecture to formally mandate extreme compartmentalization of tool access limits. Tools are strictly bound to domains and are no longer assumed \"global by default.\" - ** McpToolRepository Refactoring**: Updated JPQL definitions in the repository ( findEnabledByIntentAndState , findByToolCodeEnabledAndIntentAndState ) leveraging the Spring Data @Param annotation to guarantee tools are flawlessly filtered. The internal McpPlanner is logically isolated from discovering tools sitting externally to the current active conversational domain intent scope. - ** McpToolRegistry Improvements**: A hardened centralized registry mechanism uniquely responsible for standardizing tool_group domains and resolving perfectly legal tools for a given conversation cycle loop, mathematically preventing hallucinations where an LLM invokes an unbound tool. - ** McpToolExecutor Interface Expansion**: Designed a formalized executor functional contract natively implemented by a vast array of specialized business adapters for standardized output structures. - **New Executor Adapter Implementations**: Delivered fully mocked execution wrappers capable of expanding to live implementations: - McpDbToolExecutor : For parsing database querying and modification parameter mapping tools. - McpHttpApiToolExecutor : For serializing outbound REST/SOAP API tool integrations. - McpWorkflowActionToolExecutor : For complex cross-system async workflow pipeline triggers. - McpDocumentRetrievalToolExecutor : For executing dynamic RAG (Retrieval-Augmented Generation) Knowledge Base queries. - McpCalculatorTransformToolExecutor : For executing deterministic programmatic mathematical transformations. - McpFileToolExecutor : For OS-level file parsing, reading, generation, and file management tools. - McpNotificationToolExecutor : For serializing logic aimed at SMS/Email/Push notification gateways. - **Early-Exit Execution Guardrails**: ToolOrchestrationStep and McpToolStep logic matrices were fortified to immediately halt and bypass tool discovery planning on simple conversational greetings (e.g., regex checks against hi , hello , good morning ) or explicit internal dialogue acts ( AFFIRM , NEGATE ) to drastically curb overhead computational latency and expensive LLM generative token expenditures. ### 4. Advanced Pipeline Governance: Memory, Guardrails, and Graphs - ** GuardrailStep Framework**: A foundational preventative pipeline step strategically positioned to screen dynamic inputs against hardcoded blocked configuration patterns or sanitize output payload injections before advancing. Generates robust metrics to soft-block or strictly hard-block the ConvEngineInputParamKey.STATE_GRAPH_VALID control parameter. - ** DisambiguationStep Integration**: An autonomous discrete evaluation system boundary. If multiple valid intents or competing multi-turn pending actions exhibit mathematically adjacent probabilities (Confidence score collisions), this step halts the internal execution state transitions and forces a deterministic query back to the end user for explicit disambiguation. - ** StateGraphStep Validation**: Built an internal compliance enforcement algorithm explicitly assessing whether the current proposed transition route from State A -> State B functionally complies with the statically mapped topologies inside the convengine.flow.state-graph.allowed-transitions logic limits. - ** MemoryStep and ConversationMemoryStore Context Modeling**: Engineered a long-term conversation compression service layer. The orchestration engine dynamically aggregates rolling conversation turns bounded by the recent-turns-for-summary threshold and compresses them into a highly compact ConvEngineInputParamKey.MEMORY_SESSION_SUMMARY . This drastically scales up context capacities, permitting the underlying LLM to seamlessly address sliding-window follow-up questions without wasting tokens continuously re-parsing huge historical payload stacks. ### 5. Deterministic Evaluation and Replay CI/CD Logics - ** ConversationReplayService Orchestration**: Wrote advanced system test capabilities modeled exclusively for deep auditing metrics and automated CI/CD gating strategies. It fundamentally enables developers to parse a target conversation_id string into the service to perfectly replay historical conversational turns sequentially across the precise state parameters to test robustness over time. - ** TraceExpectation Object Structure**: Represents the mathematical and contextual logical assertions required during a turn replay scenario (e.g., Assert Intent == X , Assert Dialogue Act == Y ). - ** TraceReplayResult & TraceTurnResult Analytics**: Deployed overarching replay evaluation metrics classes designed to empower automated pipelines with the tooling necessary to validate whether newly submitted behavior rules applied directly within ce_rule or ce_policy unexpectedly fractured long-standing static historically recorded conversation progression structures. - **SQL Initialization DDL Enhancements**: Segmented and significantly refactored database procedural seeding generation structures intended for clean, error-free automated platform tests. Explicitly divided the sprawling monolithic ddl.sql logic into dedicated dialect-specific SQL instances ( seed_sqlite.sql , seed_postgres.sql , seed_oracle.sql ). Spliced all auto-generated DBeaver boilerplate syntax elements and strategically configured dependency-oriented DROP TABLE definitions to ensure identically idempotent and stateless automated unit test deployment loops continuously without breaking consistency schemas. ### Added new steps - DialogueActStep - InteractionPolicyStep - ActionLifecycleStep - DisambiguationStep - GuardrailStep - ToolOrchestrationStep - StateGraphStep - MemoryStep - PendingActionStep enhanced for robust policy/lifecycle integration ### Added new flow configuration model - ConvEngineFlowConfig ( convengine.flow.* ) - dialogue act - interaction policy matrix - action lifecycle TTL - disambiguation options - guardrail controls - state graph settings - tool orchestration toggle - memory summary settings ### Added new control table - ce_pending_action - action catalog for pending-action execution - indexed by action key/intent/state/priority ### Added new rule phases - POST_AGENT_MCP - POST_TOOL_EXECUTION ### Added tool execution architecture - McpToolExecutor interface - group executors for: - DB - HTTP_API - WORKFLOW_ACTION - DOCUMENT_RETRIEVAL - CALCULATOR_TRANSFORM - NOTIFICATION - FILES - adapter interfaces for consumer implementations ### Added memory and replay scaffolding - ConversationMemoryStore - ConversationReplayService - replay model classes ( Trace* ) ### Added audit stage coverage Expanded audit visibility for: - dialogue act and interaction policy - dialogue-act LLM input/output/error checkpoints ( DIALOGUE_ACT_LLM_INPUT , DIALOGUE_ACT_LLM_OUTPUT , DIALOGUE_ACT_LLM_ERROR ) - post-dialogue-act override hook via POST_DIALOGUE_ACT and SET_DIALOGUE_ACT - pending action lifecycle and execution - disambiguation requirements - guardrail allow/deny - tool orchestration request/result/error - state graph validation/violation - memory updates - post-phase rule metadata ## 1.x line Use the version dropdown to switch to v1 documentation.",
    "excerpt": "2.0.9 2.0.9 is the prompt control and correction routing release line. Compared to 2.0.8, this adds Thymeleaf backed prompt rendering, richer runtime routing for confirmations/corrections, new rule capabilities, and a co…"
  }
]