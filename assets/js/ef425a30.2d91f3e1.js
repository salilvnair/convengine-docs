"use strict";(globalThis.webpackChunkconvengine_docs=globalThis.webpackChunkconvengine_docs||[]).push([[7603],{3367(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"consumer/ui-integration","title":"UI Integration","description":"This page shows end-to-end UI wiring with:","source":"@site/docs/v2/consumer/ui-integration.mdx","sourceDirName":"consumer","slug":"/consumer/ui-integration","permalink":"/docs/v2/consumer/ui-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/salilvnair/convengine-docs/tree/main/docs/v2/consumer/ui-integration.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"UI Integration","sidebar_position":2},"sidebar":"docSidebar","previous":{"title":"New Consumer Onboarding","permalink":"/docs/v2/consumer/new-consumer-onboarding"},"next":{"title":"Backend Integration","permalink":"/docs/v2/consumer/backend-integration"}}');var r=t(4848),a=t(8453),o=t(9131);const i={title:"UI Integration",sidebar_position:2},c="UI Integration",l={},d=[{value:"React Vite (JavaScript)",id:"react-vite-javascript",level:2},{value:"React Vite (TypeScript)",id:"react-vite-typescript",level:2},{value:"Angular Integration (authored sample)",id:"angular-integration-authored-sample",level:2}];function p(n){const e={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"ui-integration",children:"UI Integration"})}),"\n",(0,r.jsx)(e.p,{children:"This page shows end-to-end UI wiring with:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"React (Vite) in JS + TS"}),"\n",(0,r.jsx)(e.li,{children:"Angular (standalone) in TS"}),"\n",(0,r.jsx)(e.li,{children:"SSE now + STOMP commented for later switch"}),"\n"]}),"\n",(0,r.jsx)(o.zM,{step:"1",title:"Call message API",children:(0,r.jsxs)(e.p,{children:["POST to ",(0,r.jsx)(o.Mn,{children:"/api/v1/conversation/message"})," using ",(0,r.jsx)(o.pu,{children:"conversationId"})," and ",(0,r.jsx)(o.pu,{children:"message"}),"."]})}),"\n",(0,r.jsx)(o.zM,{step:"2",title:"Subscribe to stream",children:(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(o.pu,{children:"EventSource"})," on ",(0,r.jsxs)(o.Mn,{children:["/api/v1/conversation/stream/","{conversationId}"]}),"."]})}),"\n",(0,r.jsx)(o.zM,{step:"3",title:"Refresh timeline",children:(0,r.jsxs)(e.p,{children:["On each stream event, refresh ",(0,r.jsxs)(o.Mn,{children:["/audit/","{conversationId}"]})," or trace endpoint."]})}),"\n",(0,r.jsx)(e.h2,{id:"react-vite-javascript",children:"React Vite (JavaScript)"}),"\n",(0,r.jsx)(o.vl,{title:"convengine.api.js",language:"js",packagePath:"src/api",filePath:"src/api/convengine.api.js",children:'const API_BASE = "http://localhost:8080/api/v1/conversation";\n\nexport async function sendMessage(conversationId, message, inputParams = {}, reset = false) {\nconst res = await fetch(API_BASE + "/message", {\n  method: "POST",\n  headers: { "Content-Type": "application/json" },\n  body: JSON.stringify({ conversationId, message, reset, inputParams }),\n});\nif (!res.ok) throw new Error("Backend error: " + res.status);\nreturn res.json();\n}\n\nexport async function fetchAudits(conversationId) {\nconst res = await fetch(API_BASE + "/audit/" + conversationId);\nif (!res.ok) throw new Error("Backend error: " + res.status);\nreturn res.json();\n}\n\nexport function subscribeConversationSse(conversationId, handlers = {}) {\nconst source = new EventSource(API_BASE + "/stream/" + conversationId);\n\nsource.onopen = () => handlers.onConnected?.();\nsource.onerror = (error) => handlers.onError?.(error);\n\n["CONNECTED", "USER_INPUT", "STEP_ENTER", "STEP_EXIT", "STEP_ERROR", "ASSISTANT_OUTPUT", "ENGINE_RETURN"]\n  .forEach((stage) => {\n    source.addEventListener(stage, (event) => {\n      let data = null;\n      try { data = event.data ? JSON.parse(event.data) : null; } catch {}\n      handlers.onEvent?.({ stage, data, raw: event });\n    });\n  });\n\nreturn { close() { source.close(); handlers.onClosed?.(); } };\n}\n\n// STOMP scaffold (optional)\n// npm install @stomp/stompjs sockjs-client\n// import { Client } from "@stomp/stompjs";\n// import SockJS from "sockjs-client";\n// export function subscribeConversationStomp(conversationId, handlers = {}) {\n//   const client = new Client({\n//     webSocketFactory: () => new SockJS("http://localhost:8080/ws-convengine"),\n//     reconnectDelay: 5000,\n//     onConnect: () => {\n//       handlers.onConnected?.();\n//       client.subscribe("/topic/convengine/audit/" + conversationId, (msg) => {\n//         try { handlers.onEvent?.(JSON.parse(msg.body)); }\n//         catch { handlers.onEvent?.(msg.body); }\n//       });\n//     },\n//     onStompError: (frame) => handlers.onError?.(frame),\n//   });\n//   client.activate();\n//   return { close() { client.deactivate(); handlers.onClosed?.(); } };\n// }'}),"\n",(0,r.jsx)(o.vl,{title:"App.jsx",language:"jsx",packagePath:"src",filePath:"src/App.jsx",children:'import { useEffect, useState } from "react";\nimport { subscribeConversationSse } from "./api/convengine.api.js";\n\nexport default function App() {\nconst [conversationId] = useState(crypto.randomUUID());\nconst [auditVersion, setAuditVersion] = useState(0);\n\nuseEffect(() => {\n  const stream = subscribeConversationSse(conversationId, {\n    onConnected: () => setAuditVersion((v) => v + 1),\n    onEvent: () => setAuditVersion((v) => v + 1),\n  });\n\n  // STOMP alternate:\n  // const stream = subscribeConversationStomp(conversationId, { ... });\n\n  return () => stream.close();\n}, [conversationId]);\n\nreturn <div>conversationId={conversationId} auditVersion={auditVersion}</div>;\n}'}),"\n",(0,r.jsx)(e.h2,{id:"react-vite-typescript",children:"React Vite (TypeScript)"}),"\n",(0,r.jsx)(o.vl,{title:"convengine.api.ts",language:"ts",packagePath:"src/api",filePath:"src/api/convengine.api.ts",children:'const API_BASE = "http://localhost:8080/api/v1/conversation";\n\nexport type SseStage =\n| "CONNECTED"\n| "USER_INPUT"\n| "STEP_ENTER"\n| "STEP_EXIT"\n| "STEP_ERROR"\n| "ASSISTANT_OUTPUT"\n| "ENGINE_RETURN"\n| "MESSAGE";\n\nexport interface StreamEvent<T = unknown> {\nstage: SseStage;\ndata: T | null;\nraw: MessageEvent;\n}\n\nexport interface StreamHandlers<T = unknown> {\nonConnected?: () => void;\nonEvent?: (event: StreamEvent<T>) => void;\nonError?: (event: Event) => void;\nonClosed?: () => void;\n}\n\nexport async function sendMessage(\nconversationId: string,\nmessage: string,\ninputParams: Record<string, unknown> = {},\nreset = false\n) {\nconst res = await fetch(API_BASE + "/message", {\n  method: "POST",\n  headers: { "Content-Type": "application/json" },\n  body: JSON.stringify({ conversationId, message, inputParams, reset }),\n});\nif (!res.ok) throw new Error("Backend error: " + res.status);\nreturn res.json();\n}\n\nexport function subscribeConversationSse<T = unknown>(\nconversationId: string,\nhandlers: StreamHandlers<T> = {}\n) {\nconst source = new EventSource(API_BASE + "/stream/" + conversationId);\n\nsource.onopen = () => handlers.onConnected?.();\nsource.onerror = (event) => handlers.onError?.(event);\n\n["CONNECTED", "USER_INPUT", "STEP_ENTER", "STEP_EXIT", "STEP_ERROR", "ASSISTANT_OUTPUT", "ENGINE_RETURN"]\n  .forEach((stage) => {\n    source.addEventListener(stage, (event) => {\n      let data: T | null = null;\n      try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) as T : null; }\n      catch { data = null; }\n      handlers.onEvent?.({ stage: stage as SseStage, data, raw: event as MessageEvent });\n    });\n  });\n\nreturn { close() { source.close(); handlers.onClosed?.(); } };\n}'}),"\n",(0,r.jsx)(o.vl,{title:"App.tsx",language:"tsx",packagePath:"src",filePath:"src/App.tsx",children:'import { useEffect, useState } from "react";\nimport { subscribeConversationSse } from "./api/convengine.api";\n\nexport default function App() {\nconst [conversationId] = useState<string>(crypto.randomUUID());\nconst [auditVersion, setAuditVersion] = useState<number>(0);\n\nuseEffect(() => {\n  const stream = subscribeConversationSse(conversationId, {\n    onConnected: () => setAuditVersion((v) => v + 1),\n    onEvent: () => setAuditVersion((v) => v + 1),\n    onError: () => {},\n  });\n\n  return () => stream.close();\n}, [conversationId]);\n\nreturn <main>auditVersion={auditVersion}</main>;\n}'}),"\n",(0,r.jsx)(e.h2,{id:"angular-integration-authored-sample",children:"Angular Integration (authored sample)"}),"\n",(0,r.jsx)(o.vl,{title:"convengine-api.service.ts",language:"ts",packagePath:"src/app/core",filePath:"src/app/core/convengine-api.service.ts",children:"import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\nexport interface ConversationEvent<T = unknown> {\nstage: string;\ndata: T | null;\nraw: MessageEvent;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ConvengineApiService {\nprivate readonly apiBase = 'http://localhost:8080/api/v1/conversation';\n\nconstructor(private readonly http: HttpClient) {}\n\nsendMessage(payload: {\n  conversationId: string;\n  message: string;\n  reset?: boolean;\n  inputParams?: Record<string, unknown>;\n}): Observable<any> {\n  return this.http.post(this.apiBase + '/message', payload);\n}\n\nfetchAudits(conversationId: string): Observable<any[]> {\n  return this.http.get<any[]>(this.apiBase + '/audit/' + conversationId);\n}\n\nsubscribeConversationSse(\n  conversationId: string,\n  handlers: {\n    onConnected?: () => void;\n    onEvent?: (event: ConversationEvent) => void;\n    onError?: (event: Event) => void;\n    onClosed?: () => void;\n  } = {}\n) {\n  const source = new EventSource(this.apiBase + '/stream/' + conversationId);\n\n  source.onopen = () => handlers.onConnected?.();\n  source.onerror = (event) => handlers.onError?.(event);\n\n  [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"]\n    .forEach((stage) => {\n      source.addEventListener(stage, (event) => {\n        let data: unknown = null;\n        try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) : null; }\n        catch { data = null; }\n        handlers.onEvent?.({ stage, data, raw: event as MessageEvent });\n      });\n    });\n\n  return {\n    close: () => {\n      source.close();\n      handlers.onClosed?.();\n    }\n  };\n}\n\n// STOMP scaffold (optional)\n// npm i @stomp/stompjs sockjs-client\n// connect ws://localhost:8080/ws-convengine\n// subscribe /topic/convengine/audit/{conversationId}\n}"}),"\n",(0,r.jsx)(o.vl,{title:"chat.component.ts",language:"ts",packagePath:"src/app/features/chat",filePath:"src/app/features/chat/chat.component.ts",children:"import { Component, OnDestroy, OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { ConvengineApiService } from '../../core/convengine-api.service';\n\n@Component({\nstandalone: true,\nselector: 'app-chat',\nimports: [CommonModule, FormsModule],\ntemplateUrl: './chat.component.html'\n})\nexport class ChatComponent implements OnInit, OnDestroy {\nconversationId = crypto.randomUUID();\nmessage = '';\nmessages: Array<{ role: 'user' | 'assistant'; text: string }> = [];\ntyping = false;\n\nprivate streamCloser: { close: () => void } | null = null;\n\nconstructor(private readonly api: ConvengineApiService) {}\n\nngOnInit(): void {\n  this.streamCloser = this.api.subscribeConversationSse(this.conversationId, {\n    onEvent: () => {\n      // optionally refresh audit panel\n    }\n  });\n}\n\nsend(): void {\n  const text = this.message.trim();\n  if (!text || this.typing) return;\n\n  this.messages.push({ role: 'user', text });\n  this.message = '';\n  this.typing = true;\n\n  this.api.sendMessage({ conversationId: this.conversationId, message: text }).subscribe({\n    next: (res) => {\n      const value = res?.payload?.value ?? '';\n      this.messages.push({ role: 'assistant', text: String(value) });\n      this.typing = false;\n    },\n    error: () => {\n      this.typing = false;\n    }\n  });\n}\n\nngOnDestroy(): void {\n  this.streamCloser?.close();\n}\n}"}),"\n",(0,r.jsx)(o.vl,{title:"chat.component.html",language:"html",packagePath:"src/app/features/chat",filePath:"src/app/features/chat/chat.component.html",children:'<section class="chat-shell">\n<div class="messages">\n  <div *ngFor="let m of messages" [class.user]="m.role === \'user\'" [class.assistant]="m.role === \'assistant\'">\n    {{ m.text }}\n  </div>\n  <div *ngIf="typing" class="assistant typing">Agent is typing...</div>\n</div>\n\n<div class="composer">\n  <input [(ngModel)]="message" placeholder="Type message" />\n  <button (click)="send()" [disabled]="typing">Send</button>\n</div>\n</section>'}),"\n",(0,r.jsx)(o.f4,{type:"tip",title:"React + Angular parity",children:(0,r.jsxs)(e.p,{children:["Keep one shared backend contract for ",(0,r.jsx)(o.pu,{children:"conversationId"}),", ",(0,r.jsx)(o.pu,{children:"payload.type"}),", and audit stage names. Only transport/client wrappers should differ per framework."]})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}}}]);