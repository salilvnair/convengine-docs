"use strict";(globalThis.webpackChunkconvengine_docs=globalThis.webpackChunkconvengine_docs||[]).push([[2294],{2851(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"deep-dive/intent-and-schema","title":"Intent & Schema","description":"Dialogue act resolution","source":"@site/docs/v2/deep-dive/intent-and-schema.mdx","sourceDirName":"deep-dive","slug":"/deep-dive/intent-and-schema","permalink":"/docs/v2/deep-dive/intent-and-schema","draft":false,"unlisted":false,"editUrl":"https://github.com/salilvnair/convengine-docs/tree/main/docs/v2/deep-dive/intent-and-schema.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Intent & Schema","sidebar_position":5,"hide_table_of_contents":true},"sidebar":"docSidebar","previous":{"title":"Pipeline & Steps","permalink":"/docs/v2/deep-dive/pipeline-steps"},"next":{"title":"Rules & Responses","permalink":"/docs/v2/deep-dive/rules-responses"}}');var s=i(4848),o=i(8453),c=i(7555);const r={title:"Intent & Schema",sidebar_position:5,hide_table_of_contents:!0},l="Intent and Schema Internals",a={},d=[{value:"Dialogue act resolution",id:"dialogue-act-resolution",level:2},{value:"Interaction policy decision",id:"interaction-policy-decision",level:2},{value:"Confirmation routing and correction",id:"confirmation-routing-and-correction",level:2},{value:"Intent resolver behavior",id:"intent-resolver-behavior",level:2},{value:"Schema extraction",id:"schema-extraction",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"intent-and-schema-internals",children:"Intent and Schema Internals"})}),"\n",(0,s.jsx)(n.h2,{id:"dialogue-act-resolution",children:"Dialogue act resolution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DialogueActStep"})," handles linguistic classification before intent resolution even begins. It supports three configuration modes via ",(0,s.jsx)(n.code,{children:"convengine.flow.dialogue-act.resolute"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"REGEX_ONLY"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"REGEX_THEN_LLM"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"LLM_ONLY"})}),"\n"]}),"\n",(0,s.jsx)(c.p,{title:"Core Dialogue Acts",columns:["Act","Meaning","Regex Sample"],rows:[["AFFIRM","User agrees or confirms","(?i)^\\\\s*(yes|yep|yeah|sure)\\\\s*$"],["NEGATE","User disagrees or cancels","(?i)^\\\\s*(no|nope|cancel)\\\\s*$"],["ANSWER","User answers an active clarification or slot question","short direct answer in active flow"],["EDIT","User requests a correction","(?i)^\\\\s*(edit|change|modify)\\\\s*$"],["RESET","User requests a fresh start","(?i)^\\\\s*(reset|start over)\\\\s*$"],["QUESTION","User asks a clarifying question","text ending in '?'"],["NEW_REQUEST","(Fallback) User begins a new topic","default fallback"]]}),"\n",(0,s.jsxs)(n.p,{children:["When the LLM path is engaged (confidence below ",(0,s.jsx)(n.code,{children:"llm-threshold"}),"), it must return a strict JSON payload containing the act and confidence to be parsed by the engine. It can also derive ",(0,s.jsx)(n.code,{children:"standaloneQuery"}),", which becomes ",(0,s.jsx)(n.code,{children:"resolved_user_input"})," when present."]}),"\n",(0,s.jsx)(n.h2,{id:"interaction-policy-decision",children:"Interaction policy decision"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"InteractionPolicyStep"})," derives the routing policy for the current turn based on existing context."]}),"\n",(0,s.jsx)(c.p,{title:"Engine Routing Policies",columns:["Policy Decision","Trigger Context","Pipeline Impact"],rows:[["EXECUTE_PENDING_ACTION","DialogueAct=AFFIRM + hasPendingAction","Triggers PendingActionStep; Skips Intent Resolution"],["REJECT_PENDING_ACTION","DialogueAct=NEGATE + hasPendingAction","Marks Pending task REJECTED; Skips Intent Resolution"],["FILL_PENDING_SLOT","DialogueAct!=NEW_REQUEST + hasPendingSlot","Passes input to SchemaExtractionStep; Skips Intent Resolution"],["RECLASSIFY_INTENT","DialogueAct=NEW_REQUEST (or no pending state)","Forces standard Intent Resolution"]]}),"\n",(0,s.jsx)(n.h2,{id:"confirmation-routing-and-correction",children:"Confirmation routing and correction"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"CorrectionStep"})," runs after ",(0,s.jsx)(n.code,{children:"InteractionPolicyStep"})," and before intent/schema rework. It handles confirmation-state turns without forcing full re-extraction:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AFFIRM"})," in confirmation state can set ",(0,s.jsx)(n.code,{children:"routing_decision=PROCEED_CONFIRMED"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EDIT"})," in confirmation state can patch a single field in-place and keep the flow in ",(0,s.jsx)(n.code,{children:"CONFIRMATION"})]}),"\n",(0,s.jsxs)(n.li,{children:["downstream rules can use ",(0,s.jsx)(n.code,{children:"POST_SCHEMA_EXTRACTION"})," and ",(0,s.jsx)(n.code,{children:"PRE_AGENT_MCP"})," to route the next state deterministically"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"intent-resolver-behavior",children:"Intent resolver behavior"}),"\n",(0,s.jsxs)(n.p,{children:["The pipeline resolves intent in order of priority via ",(0,s.jsx)(n.code,{children:"CompositeIntentResolver"}),"."]}),"\n",(0,s.jsxs)(c.f4,{type:"info",title:"Lock and Skip Behaviors",children:[(0,s.jsx)(n.p,{children:"The engine prevents intent drift during active schema collection automatically. You will see these audit signals in the trace when intent resolution is intentionally bypassed:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"INTENT_RESOLVE_SKIPPED_POLICY"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"INTENT_RESOLVE_SKIPPED_SCHEMA_COLLECTION"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"INTENT_RESOLVE_SKIPPED_STICKY_INTENT"})}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"schema-extraction",children:"Schema extraction"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"SchemaExtractionStep"})," drives missing-field follow-up flows and automatically formats prompt templates utilizing ",(0,s.jsx)(n.code,{children:"ce_prompt_template"}),"."]}),"\n",(0,s.jsx)(c.vl,{title:"Schema LLM Injection Template",language:"json",defaultOpen:!1,children:'{\n"type": "object",\n"required": ["customerId", "email"],\n"properties": {\n  "customerId": {"type": "string"},\n  "email": {"type": "string"}\n}\n}'}),"\n",(0,s.jsxs)(n.p,{children:["Runtime facts are evaluated and written into the ",(0,s.jsx)(n.code,{children:"EngineSession"})," context by ",(0,s.jsx)(n.code,{children:"AutoAdvanceStep"}),", making them available for ",(0,s.jsx)(n.code,{children:"ce_rule"})," evaluation:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"missing_fields"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"missing_field_options"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"schema_json"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"schema_complete"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Once extraction is complete, ",(0,s.jsx)(n.code,{children:"POST_SCHEMA_EXTRACTION"})," rules can move the flow into confirmation without waiting for MCP execution."]}),"\n",(0,s.jsx)(c.f4,{type:"success",title:"Practical design rule",children:(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.strong,{children:"schema extraction"})," for required slot collection, and use ",(0,s.jsx)(n.strong,{children:"dialogue acts + interaction policies"}),' for short confirmations (like replying "yes" to "Are you sure?"). This ensures intent reclassification does not disrupt your active multi-turn flows.']})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);