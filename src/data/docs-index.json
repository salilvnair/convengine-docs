[
  {
    "id": "api/audit-trace.mdx",
    "title": "audit trace",
    "permalink": "/docs/api/audit-trace",
    "content": "Audit Trace API Endpoint GET /api/v1/conversation/audit/ /trace Response shape ], \"stages\": [ } ] } } Why this endpoint exists separates timeline from raw audit payload parsing easier UI rendering for runbooks and debug tools preserves both domain and technical stages Use both endpoints together: /audit/ for raw forensic payload, /audit/ /trace for step flow visualization.",
    "rawContent": "# Audit Trace API ## Endpoint GET /api/v1/conversation/audit/{conversationId}/trace ## Response shape <CodeBlockToggle title=\"Trace response\" language=\"json\" defaultOpen={true}> { { \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"steps\": [ { \"step\": \"IntentResolutionStep\", \"stepClass\": \"com.github.salilvnair.convengine.engine.steps.IntentResolutionStep\", \"status\": \"OK\", \"startedAt\": \"2026-02-14T10:22:01.102Z\", \"endedAt\": \"2026-02-14T10:22:01.147Z\", \"durationMs\": 45, \"error\": null, \"stages\": [] } ], \"stages\": [ { \"auditId\": 12031, \"stage\": \"STEP_ENTER\", \"createdAt\": \"2026-02-14T10:22:01.102Z\", \"payload\": { \"step\": \"IntentResolutionStep\" } } ] } } </CodeBlockToggle> ## Why this endpoint exists - separates timeline from raw audit payload parsing - easier UI rendering for runbooks and debug tools - preserves both domain and technical stages <Highlight type=\"tip\" title=\"Best practice\"> Use both endpoints together: /audit/{id} for raw forensic payload, /audit/{id}/trace for step-flow visualization. </Highlight>",
    "excerpt": "Audit Trace API Endpoint GET /api/v1/conversation/audit/ /trace Response shape ], \"stages\": [ } ] } } Why this endpoint exists separates timeline from raw audit payload parsing easier UI rendering for runbooks and debug …"
  },
  {
    "id": "api/java-api.mdx",
    "title": "java api",
    "permalink": "/docs/api/java-api",
    "content": "Java API (Core Contracts) Entry points } } default void beforeStep(EngineStep.Name stepName, EngineSession session) default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) } } public boolean matches(String stepName) } } } Extension contracts ResponseTransformerHandler ContainerDataTransformerHandler container interceptors rule task execution pathway via SET_TASK",
    "rawContent": "# Java API (Core Contracts) ## Entry points <DbTable title=\"Primary interfaces\" columns={[\"Type\", \"Package\", \"Role\"]} rows={[ [\"ConversationalEngine\", \"engine.core\", \"Main process method\"], [\"LlmClient\", \"llm.core\", \"LLM adapter contract\"], [\"EngineStep\", \"engine.pipeline\", \"Step unit contract\"], [\"EngineStepHook\", \"engine.hook\", \"Step interception contract\"], ]} /> <CodeBlockToggle title=\"ConversationalEngine\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.core\"> { public interface ConversationalEngine { EngineResult process(EngineContext engineContext); } } </CodeBlockToggle> <CodeBlockToggle title=\"LlmClient\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.llm.core\"> { public interface LlmClient { String generateText(String hint, String contextJson); String generateJson(String hint, String jsonSchema, String contextJson); float[] generateEmbedding(String input); } } </CodeBlockToggle> <CodeBlockToggle title=\"EngineStepHook\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.hook\"> { public interface EngineStepHook { default boolean supports(EngineStep.Name stepName, EngineSession session) { return true; } default void beforeStep(EngineStep.Name stepName, EngineSession session) {} default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) {} default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) {} } } </CodeBlockToggle> <CodeBlockToggle title=\"EngineStep.Name enum (hook-safe matching)\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\"> { public interface EngineStep { enum Name { AuditUserInputStep, IntentResolutionStep, AddContainerDataStep, SchemaExtractionStep, ResponseResolutionStep, AutoAdvanceStep, McpToolStep, LoadOrCreateConversationStep, FallbackIntentStateStep, PersistConversationBootstrapStep, ResetConversationStep, PersistConversationStep, PipelineEndGuardStep, ResetResolvedIntentStep, PolicyEnforcementStep, RulesStep, Unknown; public static Name fromStepName(String stepName) { /* ... */ } public boolean matches(String stepName) { /* ... */ } } } } </CodeBlockToggle> ## Extension contracts - <MethodRef>ResponseTransformerHandler</MethodRef> - <MethodRef>ContainerDataTransformerHandler</MethodRef> - container interceptors - rule task execution pathway via <MethodRef>SET_TASK</MethodRef>",
    "excerpt": "Java API (Core Contracts) Entry points } } default void beforeStep(EngineStep.Name stepName, EngineSession session) default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) default void …"
  },
  {
    "id": "api/rest-api.mdx",
    "title": "rest api",
    "permalink": "/docs/api/rest-api",
    "content": "REST API Base /api/v1/conversation Endpoints POST /message } } , \"context\": \" \" } } Experimental endpoint (feature flagged) Base: /api/v1/conversation/experimental POST /generate sql Enable with: } ' } } generate sql is designed for non transactional configuration tables ( ce_config , ce_intent , ce_rule , ce_prompt_template , ce_response , ce_output_schema , ce_container_config , optional MCP tables). It does not generate runtime conversation/audit data. Generated SQL should be reviewed before use. The endpoint applies safety checks but does not replace human review.",
    "rawContent": "# REST API ## Base <FileRef>/api/v1/conversation</FileRef> ## Endpoints <DbTable title=\"Conversation endpoints\" columns={[\"Method\", \"Path\", \"Purpose\"]} rows={[ [\"POST\", \"/message\", \"Process one turn and return payload\"], [\"GET\", \"/audit/{conversationId}\", \"Raw audit rows for conversation\"], [\"GET\", \"/audit/{conversationId}/trace\", \"Normalized step+stage timeline\"], ]} /> ## POST <FileRef>/message</FileRef> <CodeBlockToggle title=\"Request body\" language=\"json\" defaultOpen={true}> { { \"conversationId\": \"uuid-optional\", \"message\": \"Track request REQ-778102\", \"reset\": false, \"inputParams\": { \"tenant\": \"acme\" } } } </CodeBlockToggle> <CodeBlockToggle title=\"Success response\" language=\"json\" defaultOpen={true}> { { \"success\": true, \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"intent\": \"REQUEST_TRACKER\", \"state\": \"IDLE\", \"payload\": { \"type\": \"TEXT\", \"value\": \"Request REQ-778102 is IN_REVIEW.\" }, \"context\": \"{...}\" } } </CodeBlockToggle> ## Experimental endpoint (feature-flagged) Base: <FileRef>/api/v1/conversation/experimental</FileRef> - <MethodRef>POST /generate-sql</MethodRef> Enable with: <CodeBlockToggle title=\"application.yml (feature flag)\" language=\"yaml\"> { convengine: experimental: enabled: true } </CodeBlockToggle> <Tabs groupId=\"experimental-generate-sql\"> <TabItem value=\"postman\" label=\"Postman\" default> <DbTable title=\"Postman setup\" columns={[\"Field\", \"Value\"]} rows={[ [\"Method\", \"POST\"], [\"URL\", \"http://localhost:8080/api/v1/conversation/experimental/generate-sql\"], [\"Headers\", \"Content-Type: application/json\"], [\"Body Mode\", \"raw (JSON)\"], ]} /> <CodeBlockToggle title=\"Postman body (JSON)\" language=\"json\"> { { \"scenario\": \"Build disconnect electricity workflow\", \"domain\": \"utilities\", \"constraints\": \"Collect account number before action\", \"includeMcp\": true } } </CodeBlockToggle> </TabItem> <TabItem value=\"curl\" label=\"curl\"> <CodeBlockToggle title=\"curl request\" language=\"bash\"> { curl -X POST \"http://localhost:8080/api/v1/conversation/experimental/generate-sql\" \\\\ -H \"Content-Type: application/json\" \\\\ -d '{ \"scenario\": \"Build disconnect electricity workflow\", \"domain\": \"utilities\", \"constraints\": \"Collect account number before action\", \"includeMcp\": true }' } </CodeBlockToggle> </TabItem> </Tabs> <CodeBlockToggle title=\"/experimental/generate-sql success response\" language=\"json\"> { { \"success\": true, \"sql\": \"INSERT INTO ce_config ...;\\\\nINSERT INTO ce_intent ...;\", \"warnings\": [], \"note\": \"Experimental output: review before applying in production.\" } } </CodeBlockToggle> <Highlight type=\"info\" title=\"Generation scope\"> generate-sql is designed for non-transactional configuration tables ( ce_config , ce_intent , ce_rule , ce_prompt_template , ce_response , ce_output_schema , ce_container_config , optional MCP tables). It does not generate runtime conversation/audit data. </Highlight> <Highlight type=\"warning\" title=\"Experimental output\"> Generated SQL should be reviewed before use. The endpoint applies safety checks but does not replace human review. </Highlight>",
    "excerpt": "REST API Base /api/v1/conversation Endpoints POST /message } } , \"context\": \" \" } } Experimental endpoint (feature flagged) Base: /api/v1/conversation/experimental POST /generate sql Enable with: } ' } } generate sql is …"
  },
  {
    "id": "api/stream-api.mdx",
    "title": "stream api",
    "permalink": "/docs/api/stream-api",
    "content": "Stream API (Socket) Base transport endpoints Conversation turns are submitted through POST /api/v1/conversation/message . Socket/SSE channels stream audit stages for that same conversationId . SSE subscription ; source.addEventListener(\"STEP_ENTER\", (event) = ); source.addEventListener(\"ASSISTANT_OUTPUT\", (event) = ); } STOMP subscription , }); client.activate(); } Socket audit payload contract } } } Socket + Audit API usage 1. Call POST /api/v1/conversation/message with conversationId . 2. Subscribe to SSE/STOMP for live stages. 3. Query GET /api/v1/conversation/audit/ '} for raw events. 4. Query GET /api/v1/conversation/audit/ '}/trace for normalized step timeline. Use REST endpoints for deterministic request/response behavior, and use streaming endpoints for observability UX.",
    "rawContent": "# Stream API (Socket) ## Base transport endpoints <DbTable title=\"Streaming endpoints\" columns={[\"Transport\", \"Endpoint / Destination\", \"Purpose\"]} rows={[ [\"SSE\", \"GET /api/v1/conversation/stream/{conversationId}\", \"Server-sent live audit events for one conversation\"], [\"STOMP WS\", \"WS handshake: /ws-convengine\", \"WebSocket endpoint for STOMP clients\"], [\"STOMP topic\", \"/topic/convengine/audit/{conversationId}\", \"Conversation-scoped audit stream destination\"], ]} /> <Highlight type=\"info\" title=\"Flow contract\"> Conversation turns are submitted through <MethodRef>POST /api/v1/conversation/message</MethodRef>. Socket/SSE channels stream audit stages for that same <MethodRef>conversationId</MethodRef>. </Highlight> ## SSE subscription <CodeBlockToggle title=\"SSE client (browser)\" language=\"javascript\"> { const conversationId = \"9bf7540a-b129-4685-a120-730e8a0cb94b\"; const source = new EventSource( \"/api/v1/conversation/stream/\" + conversationId ); source.onmessage = (event) => { // fallback event channel console.log(\"SSE message:\", event.data); }; source.addEventListener(\"STEP_ENTER\", (event) => { console.log(\"STEP_ENTER:\", JSON.parse(event.data)); }); source.addEventListener(\"ASSISTANT_OUTPUT\", (event) => { console.log(\"ASSISTANT_OUTPUT:\", JSON.parse(event.data)); }); } </CodeBlockToggle> ## STOMP subscription <CodeBlockToggle title=\"STOMP client (JS)\" language=\"javascript\"> { // npm i @stomp/stompjs sockjs-client const conversationId = \"9bf7540a-b129-4685-a120-730e8a0cb94b\"; const client = new Client({ webSocketFactory: () => new SockJS(\"/ws-convengine\"), reconnectDelay: 5000, onConnect: () => { client.subscribe( \"/topic/convengine/audit/\" + conversationId, (message) => console.log(\"STOMP audit:\", JSON.parse(message.body)) ); }, }); client.activate(); } </CodeBlockToggle> ## Socket audit payload contract <CodeBlockToggle title=\"SSE/STOMP audit event payload\" language=\"json\"> { { \"auditId\": 12031, \"stage\": \"STEP_ENTER\", \"createdAt\": \"2026-02-14T10:22:01.102Z\", \"payload\": { \"_meta\": { \"stage\": \"STEP_ENTER\", \"conversationId\": \"9bf7540a-b129-4685-a120-730e8a0cb94b\", \"intent\": \"FAQ\", \"state\": \"IDLE\" } } } } </CodeBlockToggle> ## Socket + Audit API usage 1. Call <FileRef>POST /api/v1/conversation/message</FileRef> with conversationId . 2. Subscribe to SSE/STOMP for live stages. 3. Query <FileRef>GET /api/v1/conversation/audit/{'{conversationId}'}</FileRef> for raw events. 4. Query <FileRef>GET /api/v1/conversation/audit/{'{conversationId}'}/trace</FileRef> for normalized step timeline. <Highlight type=\"tip\" title=\"Operational recommendation\"> Use REST endpoints for deterministic request/response behavior, and use streaming endpoints for observability UX. </Highlight>",
    "excerpt": "Stream API (Socket) Base transport endpoints Conversation turns are submitted through POST /api/v1/conversation/message . Socket/SSE channels stream audit stages for that same conversationId . SSE subscription ; source.a…"
  },
  {
    "id": "architecture.mdx",
    "title": "architecture",
    "permalink": "/docs/architecture",
    "content": "Architecture Layers API Layer ConversationController request DTO: ConversationRequest response DTO: ConversationResponse Engine Layer DefaultConversationalEngine EnginePipelineFactory (DAG sort + wrappers + timing + step hooks) EngineSession (per turn mutable state) Resolver Layer intent: classifier + agent + collision resolver rules: type/action factories response: response type + output format factories MCP: planner + registry + DB executor Persistence Layer JPA repositories on ce_ ce_conversation and ce_audit write path Transport Layer (configurable) SSE stream endpoint STOMP/WebSocket publisher Request Path (high level) Builds EngineContext from conversationId , message , inputParams , optional reset flag. EngineSessionFactory creates session and history provider injects last turns. Each step receives same session instance and may mutate intent/state/context/payload. Final payload is persisted and returned as TEXT/JSON response. Code references } } } :::tip Intervention point You can intercept any step via EngineStepHook ( beforeStep , afterStep , onStepError ) without forking the engine. ::: Step order is never hardcoded as a list. It is computed from annotations and validated for cycles/missing dependencies.",
    "rawContent": "# Architecture ## Layers ### API Layer - <MethodRef>ConversationController</MethodRef> - request DTO: <MethodRef>ConversationRequest</MethodRef> - response DTO: <MethodRef>ConversationResponse</MethodRef> ### Engine Layer - <MethodRef>DefaultConversationalEngine</MethodRef> - <MethodRef>EnginePipelineFactory</MethodRef> (DAG sort + wrappers + timing + step hooks) - <MethodRef>EngineSession</MethodRef> (per-turn mutable state) ### Resolver Layer - intent: classifier + agent + collision resolver - rules: type/action factories - response: response type + output format factories - MCP: planner + registry + DB executor ### Persistence Layer - JPA repositories on <FileRef>ce_*</FileRef> - <FileRef>ce_conversation</FileRef> and <FileRef>ce_audit</FileRef> write path ### Transport Layer (configurable) - SSE stream endpoint - STOMP/WebSocket publisher ## Request Path (high-level) <FlowStep step=\"1\" title=\"Controller receives request\"> Builds <MethodRef>EngineContext</MethodRef> from <MethodRef>conversationId</MethodRef>, <MethodRef>message</MethodRef>, <MethodRef>inputParams</MethodRef>, optional <MethodRef>reset</MethodRef> flag. </FlowStep> <FlowStep step=\"2\" title=\"Engine opens session\"> <MethodRef>EngineSessionFactory</MethodRef> creates session and history provider injects last turns. </FlowStep> <FlowStep step=\"3\" title=\"Pipeline runs ordered steps\"> Each step receives same session instance and may mutate intent/state/context/payload. </FlowStep> <FlowStep step=\"4\" title=\"Persist + return result\"> Final payload is persisted and returned as TEXT/JSON response. </FlowStep> ## Code references <CodeBlockToggle title=\"Engine entrypoint\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" defaultOpen={false} > { @Override public EngineResult process(EngineContext engineContext) { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } } </CodeBlockToggle> <CodeBlockToggle title=\"Pipeline execution loop\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java\" > { for (EngineStep step : steps) { StepResult r = step.execute(session); if (r instanceof StepResult.Stop(EngineResult result)) { return result; } } } </CodeBlockToggle> :::tip Intervention point You can intercept any step via <MethodRef>EngineStepHook</MethodRef> (<MethodRef>beforeStep</MethodRef>, <MethodRef>afterStep</MethodRef>, <MethodRef>onStepError</MethodRef>) without forking the engine. ::: <Highlight type=\"warning\" title=\"DAG-ordering model\"> Step order is never hardcoded as a list. It is computed from annotations and validated for cycles/missing dependencies. </Highlight>",
    "excerpt": "Architecture Layers API Layer ConversationController request DTO: ConversationRequest response DTO: ConversationResponse Engine Layer DefaultConversationalEngine EnginePipelineFactory (DAG sort + wrappers + timing + step…"
  },
  {
    "id": "consumer/annotations-reference.mdx",
    "title": "annotations reference",
    "permalink": "/docs/consumer/annotations-reference",
    "content": "Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. Consumer entry annotations } } } stream is an annotation parameter on @EnableConvEngine , not a YAML key. Keep it aligned with convengine.transport.sse.enabled and convengine.transport.stomp.enabled . Extension annotations (consumer customization) } } } } @Override public ContainerComponentResponse intercept(ContainerComponentResponse response, EngineSession session) } } If a class uses @ResponseTransformer or @ContainerDataTransformer but does not implement the required handler interface, startup fails. Internal pipeline annotations (advanced / framework contributors) } } Pipeline requires exactly one @ConversationBootstrapStep and one @TerminalStep . Misuse can break startup DAG validation. Quick recommendations for consumers 1. Use only @EnableConvEngine initially. 2. Add @ResponseTransformer or container annotations only when you have a concrete customization need. 3. Avoid pipeline DAG annotations unless you are intentionally adding custom engine steps and can test full ordering. 4. Keep annotation usage paired with integration tests for one real conversation flow. See , , and for end to end integration context.",
    "rawContent": "# Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. ## Consumer entry annotations <DbTable title=\"Use these in your consumer app\" columns={[\"Annotation\", \"Target\", \"Purpose\", \"Typical usage\"]} rows={[ [\" @EnableConvEngine(stream = true|false) \", \"Spring Boot app class\", \"Bootstraps ConvEngine auto-configuration and stream setting.\", \"Always required to activate framework.\"], [\" @EnableConvEngineAsyncAuditDispatch \", \"Spring config/app class\", \"Forces async audit dispatch marker mode.\", \"Use when you intentionally want async listener dispatch.\"], [\" @EnableConvEngineStompBrokerRelay \", \"Spring config/app class\", \"Forces STOMP broker relay marker mode.\", \"Use when deploying with external STOMP broker relay.\"], ]} /> <CodeBlockToggle title=\"Basic enablement\" language=\"java\"> { @SpringBootApplication @EnableConvEngine(stream = true) public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> <CodeBlockToggle title=\"Optional relay + async markers\" language=\"java\"> { @Configuration @EnableConvEngineAsyncAuditDispatch @EnableConvEngineStompBrokerRelay public class ConvEngineFeatureFlags { } } </CodeBlockToggle> <Highlight type=\"info\" title=\"How stream mode works\"> stream is an annotation parameter on @EnableConvEngine , not a YAML key. Keep it aligned with convengine.transport.sse.enabled and convengine.transport.stomp.enabled . </Highlight> ## Extension annotations (consumer customization) <DbTable title=\"Extension points\" columns={[\"Annotation\", \"Must implement\", \"Purpose\", \"Key parameters\"]} rows={[ [\" @ResponseTransformer \", \" ResponseTransformerHandler \", \"Last-mile payload shaping by intent/state.\", \" intent , state \"], [\" @ContainerDataTransformer \", \" ContainerDataTransformerHandler \", \"Transforms CCF container data before session attach.\", \" intent , state \"], [\" @ContainerDataInterceptor \", \" ContainerDataRequestInterceptor and/or ContainerDataResponseInterceptor \", \"Intercepts CCF request/response around execution.\", \" intent , state , order \"], ]} /> <CodeBlockToggle title=\"Response transformer example\" language=\"java\"> { @Component @ResponseTransformer(intent = \"REQUEST_TRACKER\", state = \"IDLE\") public class TrackerResponseTransformer implements ResponseTransformerHandler { @Override public OutputPayload transform(OutputPayload responsePayload, EngineSession session, Map<String, Object> inputParams) { return responsePayload; } } } </CodeBlockToggle> <CodeBlockToggle title=\"Container transformer example\" language=\"java\"> { @Component @ContainerDataTransformer(intent = \"DISCONNECT_ELECTRICITY\", state = \"COLLECTING\") public class DisconnectContainerTransformer implements ContainerDataTransformerHandler { @Override public Map<String, Object> transform(ContainerComponentResponse response, EngineSession session, Map<String, Object> inputParams) { return Map.of(\"normalized\", response); } } } </CodeBlockToggle> <CodeBlockToggle title=\"Container interceptor example\" language=\"java\"> { @Component @ContainerDataInterceptor(intent = \"*\", state = \"*\", order = 10) public class TraceContainerInterceptor implements ContainerDataRequestInterceptor, ContainerDataResponseInterceptor { @Override public void intercept(ContainerComponentRequest request, EngineSession session) { // mutate request if needed } @Override public ContainerComponentResponse intercept(ContainerComponentResponse response, EngineSession session) { return response; } } } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Transformer/interceptor registration rules\"> If a class uses @ResponseTransformer or @ContainerDataTransformer but does not implement the required handler interface, startup fails. </Highlight> ## Internal pipeline annotations (advanced / framework contributors) <DbTable title=\"Engine DAG annotations\" columns={[\"Annotation\", \"Role\", \"Who should use it\"]} rows={[ [\" @MustRunAfter(...) \", \"Declares DAG dependency: step runs after listed steps.\", \"Framework contributors adding new EngineStep beans.\"], [\" @MustRunBefore(...) \", \"Declares DAG dependency: step runs before listed steps.\", \"Framework contributors adding new EngineStep beans.\"], [\" @RequiresConversationPersisted \", \"Forces ordering after bootstrap persistence step.\", \"Framework/internal step authors.\"], [\" @ConversationBootstrapStep \", \"Marks the single bootstrap step in pipeline.\", \"Framework internals only.\"], [\" @TerminalStep \", \"Marks the single terminal step in pipeline.\", \"Framework internals only.\"], [\" @PromptVar \", \"Maps fields in internal prompt context models to template aliases.\", \"Framework internals only; not for consumer app classes.\"], ]} /> <CodeBlockToggle title=\"Custom step with ordering\" language=\"java\"> { @Component @RequiresConversationPersisted @MustRunAfter(IntentResolutionStep.class) @MustRunBefore(ResponseResolutionStep.class) public class CustomValidationStep implements EngineStep { @Override public StepResult execute(EngineSession session) { return new StepResult.Continue(); } } } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Important constraints\"> Pipeline requires exactly one @ConversationBootstrapStep and one @TerminalStep . Misuse can break startup DAG validation. </Highlight> ## Quick recommendations for consumers 1. Use only @EnableConvEngine initially. 2. Add @ResponseTransformer or container annotations only when you have a concrete customization need. 3. Avoid pipeline DAG annotations unless you are intentionally adding custom engine steps and can test full ordering. 4. Keep annotation usage paired with integration tests for one real conversation flow. <Highlight type=\"info\" title=\"Related pages\"> See [Consumer Guide](/docs/consumer/), [New Consumer Onboarding](/docs/consumer/new-consumer-onboarding), and [Extensions](/docs/consumer/extensions) for end-to-end integration context. </Highlight>",
    "excerpt": "Annotations Reference This page lists all annotation types currently present in ConvEngine and how consumers should use them. Consumer entry annotations } } } stream is an annotation parameter on @EnableConvEngine , not …"
  },
  {
    "id": "consumer/backend-integration.mdx",
    "title": "backend integration",
    "permalink": "/docs/consumer/backend-integration",
    "content": "Backend Integration This page uses your demo repos directly: backend reference: convengine demo UI reference: zapper ui What each demo proves convengine demo : Spring Boot consumer setup, transport mode config, step hooks, LLM wiring. zapper ui : conversation client, SSE subscription, audit timeline UI. Add @EnableConvEngine and provide required beans. Use profile yaml ( sse , stomp , both ) to switch runtime behavior. Frontend posts to message endpoint and listens to SSE/STOMP for audit updates. convengine demo: Core app bootstrap ) @EntityScan(basePackages = ) @EnableJpaRepositories(basePackages = ) public class ConvengineDemoApplication } } @Bean public ObjectMapper objectMapper() } } convengine demo: Runtime config model: gpt 4.1 base url: https://api.openai.com lmstudio: api key: \\$ model: openai/gpt oss 20b base url: http://localhost:1234 transport: sse: enabled: true emitter timeout ms: 1800000 stomp: enabled: false endpoint: /ws convengine app destination prefix: /app topic prefix: /topic audit destination base: /topic/convengine/audit allowed origin pattern: \" \" sock js: true broker: mode: SIMPLE relay destination prefixes: /topic,/queue relay host: localhost relay port: 61613 client login: \"\" client passcode: \"\" system login: \"\" system passcode: \"\" virtual host: \"\" system heartbeat send interval ms: 10000 system heartbeat receive interval ms: 10000 audit: enabled: true level: ALL include stages: [] exclude stages: [] persistence: mode: IMMEDIATE jdbc batch size: 200 max buffered events: 5000 flush stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final step names: PipelineEndGuardStep flush on stop outcome: true dispatch: async enabled: false worker threads: 2 queue capacity: 2000 rejection policy: CALLER_RUNS keep alive seconds: 60 rate limit: enabled: false max events: 200 window ms: 1000 per conversation: true per stage: true max tracked buckets: 20000 } Keep broker.mode: SIMPLE and audit.dispatch.async enabled: false for baseline. Enable relay and async in non prod first, then tune queue capacity , rejection policy , and rate limit using audit volume. convengine demo: Transport + Hook diagnostics public static class StepHook } } } } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) @Override public void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) @Override public void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) } } zapper ui: How frontend consumes backend ); return () = stream.close(); }, [conversationId]); } ]); // Typing indicator shown while request is in flight } 1. Start backend ( convengine demo ) with profile sse , stomp , or both . 2. Start zapper ui and point API base to backend URL. 3. Send message, verify live timeline from stream + detailed payloads from audit API.",
    "rawContent": "# Backend Integration This page uses your demo repos directly: - backend reference: <FileRef>convengine-demo</FileRef> - UI reference: <FileRef>zapper-ui</FileRef> ## What each demo proves - <FileRef>convengine-demo</FileRef>: Spring Boot consumer setup, transport mode config, step hooks, LLM wiring. - <FileRef>zapper-ui</FileRef>: conversation client, SSE subscription, audit timeline UI. <FlowStep step=\"1\" title=\"Enable ConvEngine in backend\"> Add <MethodRef>@EnableConvEngine</MethodRef> and provide required beans. </FlowStep> <FlowStep step=\"2\" title=\"Configure transport mode\"> Use profile yaml ( sse , stomp , both ) to switch runtime behavior. </FlowStep> <FlowStep step=\"3\" title=\"Connect frontend\"> Frontend posts to message endpoint and listens to SSE/STOMP for audit updates. </FlowStep> ## convengine-demo: Core app bootstrap <CodeBlockToggle title=\"ConvengineDemoApplication.java\" language=\"java\" packagePath=\"com.github.salilvnair\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/ConvengineDemoApplication.java\" > { @SpringBootApplication @ComponentScan(basePackages = {\"com.github.salilvnair.convengdemo\"}) @EntityScan(basePackages = {\"com.github.salilvnair.convengdemo.entity\"}) @EnableJpaRepositories(basePackages = {\"com.github.salilvnair.convengdemo.repo\"}) public class ConvengineDemoApplication { public static void main(String[] args) { SpringApplication.run(ConvengineDemoApplication.class, args); } } } </CodeBlockToggle> <CodeBlockToggle title=\"ConvEngineConfig.java\" language=\"java\" packagePath=\"com.github.salilvnair.convengdemo.config\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/ConvEngineConfig.java\" > { @Configuration @EnableConvEngine @EnableConvEngineAsyncAuditDispatch // optional @EnableConvEngineStompBrokerRelay // optional @EnableCcfCore public class ConvEngineConfig { @Bean public RestWebServiceFacade restWebServiceFacade() { return new RestWebServiceFacade(); } @Bean public ObjectMapper objectMapper() { return new ObjectMapper(); } } } </CodeBlockToggle> ## convengine-demo: Runtime config <CodeBlockToggle title=\"application.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application.yml\" > { server: port: 8080 spring: datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd convengine: demo: stream-mode: SSE step-hook: enabled: true tables: AUDIT: CE_AUDIT CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE VALIDATION_SNAPSHOT: CE_VALIDATION_SNAPSHOT llm: provider: openai temperature: 0.3 openai: api-key: \\${OPENAI_API_KEY\\} model: gpt-4.1 base-url: https://api.openai.com lmstudio: api-key: \\${LMSTUDIO_API_KEY\\} model: openai/gpt-oss-20b base-url: http://localhost:1234 transport: sse: enabled: true emitter-timeout-ms: 1800000 stomp: enabled: false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 } </CodeBlockToggle> <CodeBlockToggle title=\"application-sse.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-sse.yml\"> { convengine: demo: stream-mode: SSE transport: sse: enabled: true stomp: enabled: false } </CodeBlockToggle> <CodeBlockToggle title=\"application-stomp.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-stomp.yml\"> { convengine: demo: stream-mode: STOMP transport: sse: enabled: false stomp: enabled: true } </CodeBlockToggle> <CodeBlockToggle title=\"application-both.yml\" language=\"yaml\" filePath=\"convengine-demo/src/main/resources/application-both.yml\"> { convengine: demo: stream-mode: BOTH transport: sse: enabled: true stomp: enabled: true } </CodeBlockToggle> <Highlight type=\"tip\" title=\"Relay + async audit rollout\"> Keep broker.mode: SIMPLE and audit.dispatch.async-enabled: false for baseline. Enable relay and async in non-prod first, then tune queue-capacity , rejection-policy , and rate-limit using audit volume. </Highlight> ## convengine-demo: Transport + Hook diagnostics <CodeBlockToggle title=\"DemoTransportProperties.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/DemoTransportProperties.java\" > { @Component @ConfigurationProperties(prefix = \"convengine.demo\") public class DemoTransportProperties { private StreamMode streamMode = StreamMode.SSE; private StepHook stepHook = new StepHook(); public enum StreamMode { SSE, STOMP, BOTH } public static class StepHook { private boolean enabled = true; } } } </CodeBlockToggle> <CodeBlockToggle title=\"ConvEngineTransportStartupLogger.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/ConvEngineTransportStartupLogger.java\" > { @Component @RequiredArgsConstructor public class ConvEngineTransportStartupLogger { private final DemoTransportProperties demoTransportProperties; private final ConvEngineTransportConfig transportConfig; private final Environment environment; @EventListener(ApplicationReadyEvent.class) public void logTransportConfiguration() { boolean sseEnabled = transportConfig.getSse().isEnabled(); boolean stompEnabled = transportConfig.getStomp().isEnabled(); // validates mode and prints endpoints } } } </CodeBlockToggle> <CodeBlockToggle title=\"DemoEngineStepHook.java\" language=\"java\" filePath=\"convengine-demo/src/main/java/com/github/salilvnair/convengdemo/config/DemoEngineStepHook.java\" > { @Component @RequiredArgsConstructor public class DemoEngineStepHook implements EngineStepHook { private static final Set<EngineStep.Name> TRACKED_STEPS = Set.of( EngineStep.Name.IntentResolutionStep, EngineStep.Name.SchemaExtractionStep, EngineStep.Name.RulesStep, EngineStep.Name.ResponseResolutionStep ); @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return demoTransportProperties.getStepHook().isEnabled() && TRACKED_STEPS.contains(stepName); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { /* logs */ } @Override public void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) { /* logs */ } @Override public void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) { /* logs */ } } } </CodeBlockToggle> ## zapper-ui: How frontend consumes backend <CodeBlockToggle title=\"convengine.api.js (zapper-ui)\" language=\"js\" filePath=\"zapper-ui/src/api/convengine.api.js\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; // STOMP scaffold commented for optional enablement } </CodeBlockToggle> <CodeBlockToggle title=\"App.jsx (zapper-ui)\" language=\"jsx\" filePath=\"zapper-ui/src/App.jsx\" > { useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion(v => v + 1), onEvent: () => setAuditVersion(v => v + 1), }); return () => stream.close(); }, [conversationId]); } </CodeBlockToggle> <CodeBlockToggle title=\"ChatPanel.jsx (zapper-ui)\" language=\"jsx\" filePath=\"zapper-ui/src/components/ChatPanel.jsx\" > { const res = await sendMessage(conversationId, userText); setMessages(m => [...m, { role: \"assistant\", text: assistantText }]); // Typing indicator shown while request is in-flight } </CodeBlockToggle> <Highlight type=\"info\" title=\"Backend + UI runbook\"> 1. Start backend ( convengine-demo ) with profile <MethodRef>sse</MethodRef>, <MethodRef>stomp</MethodRef>, or <MethodRef>both</MethodRef>. 2. Start <FileRef>zapper-ui</FileRef> and point API base to backend URL. 3. Send message, verify live timeline from stream + detailed payloads from audit API. </Highlight> <CodeBlockToggle title=\"Run commands\" language=\"bash\" defaultOpen={false}> { # backend (convengine-demo) ./mvnw spring-boot:run -Dspring-boot.run.profiles=sse # or ./mvnw spring-boot:run -Dspring-boot.run.profiles=stomp # or ./mvnw spring-boot:run -Dspring-boot.run.profiles=both # frontend (zapper-ui) npm install npm run dev } </CodeBlockToggle>",
    "excerpt": "Backend Integration This page uses your demo repos directly: backend reference: convengine demo UI reference: zapper ui What each demo proves convengine demo : Spring Boot consumer setup, transport mode config, step hook…"
  },
  {
    "id": "consumer/configuration.mdx",
    "title": "configuration",
    "permalink": "/docs/consumer/configuration",
    "content": "Configuration Deep Guide Table mapping in application.yml (ConvEngine + CCF Core) Use this when your physical table names differ from defaults. ConvEngine reads convengine.tables. ; CCF Core reads ccf.core.tables. . If you override table names, keep mappings consistent across environments and apply the same naming strategy in JPA config. Complete application.yml reference (demo + full ConvEngine options) This is a complete starter reference combining convengine demo style settings and all configurable convengine. properties currently present in the framework. model: gpt 4.1 base url: https://api.openai.com lmstudio: api key: \\$ model: openai/gpt oss 20b base url: http://localhost:1234 ccf: core: tables: PAGE_COMMON_QUERY: ZP_PAGE_COMMON_QUERY SECTION_INFO: ZP_SECTION_INFO CONTAINER_INFO: ZP_CONTAINER_INFO CONTAINER_FIELD_INFO: ZP_CONTAINER_FIELD_INFO CONTAINER_QUERY_INFO: ZP_CONTAINER_QUERY_INFO } @EnableConvEngine(stream = true|false) is annotation driven. It is not a YAML property; keep transport flags aligned with the annotation mode. ce_prompt_template in detail ce_prompt_template holds reusable prompt text for both schema extraction and derived response generation. Use response_type to route templates: SCHEMA_JSON for schema extraction prompts TEXT for derived text response prompts JSON for derived json response prompts }\\nContext: }\\nSchema: }', true); Derived text response template INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, enabled) VALUES ('REQUEST_TRACKER', 'IDLE', 'TEXT', 'You are a concise status assistant. Keep response under 3 lines.', 'User: }\\nContext: }\\nSession: }', true); } ce_config in detail ce_config stores runtime tunables keyed by component class. Common keys: AgentIntentResolver.MIN_CONFIDENCE AgentIntentResolver.COLLISION_GAP_THRESHOLD AgentIntentResolver.SYSTEM_PROMPT AgentIntentResolver.USER_PROMPT McpPlanner.SYSTEM_PROMPT McpPlanner.USER_PROMPT ResetResolvedIntentStep.RESET_INTENT_CODES IntentResolutionStep.STICKY_INTENT }\\nTools: }\\nContext: }', true); } ce_output_schema in detail ce_output_schema defines extraction contract per intent/state. SchemaExtractionStep uses this JSON schema to detect missing fields and drive clarification flow. , \"reason\": , \"requestedDate\": } }'::jsonb, true ); } ce_response in detail ce_response maps resolved intent/state to response strategy. EXACT : static response body from DB. DERIVED : runtime generated response (LLM), optionally using ce_prompt_template . '::jsonb, true); } ce_rule in detail ce_rule is the conditional transition/action layer executed in RulesStep . rule_type : EXACT , REGEX , JSON_PATH phase : PIPELINE_RULES , AGENT_POST_INTENT action : SET_INTENT , SET_STATE , SET_JSON , GET_CONTEXT , GET_SCHEMA_JSON , GET_SESSION , SET_TASK ce_rule.phase execution semantics Use phase to control where a rule executes. EngineSession/inputParams include phase metadata: postIntentRule / post_intent_rule rule_phase rule_execution_source rule_execution_origin Prompt variable guidance Common variables used in templates: } } } } } schema helpers: } , } , } Prompt template extra now includes all keys present in inputParams , including runtime/system derived keys written through session.putInputParam(...) . Keep key naming and values controlled in consumer task/rule code. Runtime transport/audit properties } } New 1.0.8+ runtime controls explained 1. Async audit dispatch: Moves transport fan out off request thread when enabled. Configure with convengine.audit.dispatch. or @EnableConvEngineAsyncAuditDispatch . 2. Backpressure policy: Queue capacity + rejection policy control behavior under burst. CALLER_RUNS is safest default; DROP_ favors latency; ABORT is strict. 3. Stage level audit controls: level , include stages , exclude stages , and rate limit reduce noisy audit traffic. 4. Deferred bulk persistence: convengine.audit.persistence.mode=DEFERRED_BULK buffers events and writes batch inserts. Flushes on terminal step/error (configurable), plus request end safety flush. 5. STOMP broker mode: SIMPLE (default): in memory broker. RELAY : external STOMP broker (RabbitMQ/other relay supporting STOMP). RabbitMQ relay example Redis example (via STOMP gateway/bridge) ConvEngine STOMP relay requires a STOMP compatible broker endpoint. Redis alone is not a native STOMP broker; use a STOMP gateway/bridge in front of Redis.",
    "rawContent": "# Configuration Deep Guide ## Table mapping in application.yml (ConvEngine + CCF Core) Use this when your physical table names differ from defaults. ConvEngine reads convengine.tables.* ; CCF Core reads ccf.core.tables.* . <CodeBlockToggle title=\"application.yml table mappings\" language=\"yaml\"> { convengine: tables: AUDIT: CE_AUDIT CONFIG: CE_CONFIG CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA POLICY: CE_POLICY PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE VALIDATION_SNAPSHOT: CE_VALIDATION_SNAPSHOT ccf: core: tables: PAGE_COMMON_QUERY: ZP_PAGE_COMMON_QUERY SECTION_INFO: ZP_SECTION_INFO CONTAINER_INFO: ZP_CONTAINER_INFO CONTAINER_FIELD_INFO: ZP_CONTAINER_FIELD_INFO CONTAINER_QUERY_INFO: ZP_CONTAINER_QUERY_INFO } </CodeBlockToggle> <Highlight type=\"info\" title=\"Important\"> If you override table names, keep mappings consistent across environments and apply the same naming strategy in JPA config. </Highlight> ## Complete application.yml reference (demo + full ConvEngine options) This is a complete starter reference combining convengine-demo style settings and all configurable convengine.* properties currently present in the framework. <CodeBlockToggle title=\"Complete application.yml reference\" language=\"yaml\"> { server: port: 8080 spring: application: name: convengine datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd driver-class-name: org.postgresql.Driver jpa: open-in-view: false hibernate: ddl-auto: none naming: # Use the physical strategy your app needs (demo uses CCF strategy) physical-strategy: com.github.salilvnair.ccf.config.hibernate.CcfPhysicalNamingStrategy show-sql: true properties: hibernate: format_sql: true jdbc: lob: non_contextual_creation: true jackson: serialization: indent_output: true logging: level: root: INFO org.hibernate.SQL: DEBUG org.hibernate.type.descriptor.sql.BasicBinder: TRACE convengine: # Demo app-only block (optional, not framework-required) demo: stream-mode: SSE # SSE | STOMP | BOTH step-hook: enabled: true # Framework flags experimental: enabled: false # Dynamic table mapping for CE_* entities tables: AUDIT: CE_AUDIT CONFIG: CE_CONFIG CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA POLICY: CE_POLICY PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE VALIDATION_SNAPSHOT: CE_VALIDATION_SNAPSHOT transport: sse: enabled: true emitter-timeout-ms: 1800000 stomp: enabled: false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE # SIMPLE | RELAY relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL # ALL | STANDARD | ERROR_ONLY | NONE include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE # IMMEDIATE | DEFERRED_BULK jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS # CALLER_RUNS | DROP_NEWEST | DROP_OLDEST | ABORT keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 # Example consumer-specific LLM block (optional, used by demo-style adapters) # llm: # provider: openai # temperature: 0.3 # openai: # api-key: \\${OPENAI_API_KEY} # model: gpt-4.1 # base-url: https://api.openai.com # lmstudio: # api-key: \\${LMSTUDIO_API_KEY} # model: openai/gpt-oss-20b # base-url: http://localhost:1234 ccf: core: tables: PAGE_COMMON_QUERY: ZP_PAGE_COMMON_QUERY SECTION_INFO: ZP_SECTION_INFO CONTAINER_INFO: ZP_CONTAINER_INFO CONTAINER_FIELD_INFO: ZP_CONTAINER_FIELD_INFO CONTAINER_QUERY_INFO: ZP_CONTAINER_QUERY_INFO } </CodeBlockToggle> <Highlight type=\"tip\" title=\"Stream enablement note\"> @EnableConvEngine(stream = true|false) is annotation-driven. It is not a YAML property; keep transport flags aligned with the annotation mode. </Highlight> ## ce_prompt_template in detail ce_prompt_template holds reusable prompt text for both schema extraction and derived response generation. Use response_type to route templates: - SCHEMA_JSON for schema extraction prompts - TEXT for derived text response prompts - JSON for derived json response prompts <CodeBlockToggle title=\"Example ce_prompt_template rows\" language=\"sql\"> { -- Schema extraction template INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, enabled) VALUES ('DISCONNECT_ELECTRICITY', 'COLLECTING', 'SCHEMA_JSON', 'Extract required fields strictly as JSON. No commentary.', 'User: {{user_input}}\\nContext: {{context}}\\nSchema: {{schema}}', true); -- Derived text response template INSERT INTO ce_prompt_template (intent_code, state_code, response_type, system_prompt, user_prompt, enabled) VALUES ('REQUEST_TRACKER', 'IDLE', 'TEXT', 'You are a concise status assistant. Keep response under 3 lines.', 'User: {{user_input}}\\nContext: {{context}}\\nSession: {{session}}', true); } </CodeBlockToggle> ## ce_config in detail ce_config stores runtime tunables keyed by component class. Common keys: - AgentIntentResolver.MIN_CONFIDENCE - AgentIntentResolver.COLLISION_GAP_THRESHOLD - AgentIntentResolver.SYSTEM_PROMPT - AgentIntentResolver.USER_PROMPT - McpPlanner.SYSTEM_PROMPT - McpPlanner.USER_PROMPT - ResetResolvedIntentStep.RESET_INTENT_CODES - IntentResolutionStep.STICKY_INTENT <CodeBlockToggle title=\"Example ce_config rows\" language=\"sql\"> { INSERT INTO ce_config (config_type, config_key, config_value, enabled) VALUES ('AgentIntentResolver', 'MIN_CONFIDENCE', '0.60', true), ('AgentIntentResolver', 'COLLISION_GAP_THRESHOLD', '0.15', true), ('ResetResolvedIntentStep', 'RESET_INTENT_CODES', 'RESET_SESSION,START_OVER', true), ('IntentResolutionStep', 'STICKY_INTENT', 'true', true), ('McpPlanner', 'SYSTEM_PROMPT', 'You are an MCP planner. Prefer safe calls and minimal arguments.', true), ('McpPlanner', 'USER_PROMPT', 'User: {{user_input}}\\nTools: {{mcp_tools}}\\nContext: {{context}}', true); } </CodeBlockToggle> <DbTable title=\"Implemented type/action values\" columns={[\"Field\", \"Allowed values\", \"Notes\"]} rows={[ [\"ce_response.response_type\", \"EXACT, DERIVED\", \"EXACT bypasses LLM generation\"], [\"ce_response.output_format\", \"TEXT, JSON\", \"Used by output format resolver\"], [\"ce_rule.rule_type\", \"EXACT, REGEX, JSON_PATH\", \"Must match installed rule type resolvers\"], [\"ce_rule.phase\", \"PIPELINE_RULES, AGENT_POST_INTENT\", \"Controls whether rule runs in RulesStep or AgentIntentResolver post-intent pass\"], [\"ce_rule.action\", \"SET_INTENT, SET_STATE, SET_JSON, GET_CONTEXT, GET_SCHEMA_JSON, GET_SESSION, SET_TASK\", \"Must match installed action resolvers\"], ]} /> ## ce_output_schema in detail ce_output_schema defines extraction contract per intent/state. SchemaExtractionStep uses this JSON schema to detect missing fields and drive clarification flow. <CodeBlockToggle title=\"ce_output_schema shape (DDL-style)\" language=\"sql\"> { -- Core columns (simplified) CREATE TABLE ce_output_schema ( schema_id BIGSERIAL PRIMARY KEY, intent_code TEXT NOT NULL, state_code TEXT NOT NULL, schema_name TEXT, schema_description TEXT, json_schema JSONB NOT NULL, enabled BOOLEAN NOT NULL DEFAULT TRUE, created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW() ); } </CodeBlockToggle> <CodeBlockToggle title=\"Example ce_output_schema row\" language=\"sql\"> { INSERT INTO ce_output_schema (intent_code, state_code, schema_name, schema_description, json_schema, enabled) VALUES ( 'DISCONNECT_ELECTRICITY', 'COLLECTING', 'disconnect_request', 'Required data to process electricity disconnect request.', '{ \"type\":\"object\", \"required\":[\"accountNumber\",\"reason\"], \"properties\":{ \"accountNumber\":{\"type\":\"string\"}, \"reason\":{\"type\":\"string\",\"enum\":[\"MOVE_OUT\",\"TEMP_CLOSE\",\"PERMANENT_CLOSE\"]}, \"requestedDate\":{\"type\":\"string\",\"format\":\"date\"} } }'::jsonb, true ); } </CodeBlockToggle> ## ce_response in detail ce_response maps resolved intent/state to response strategy. - EXACT : static response body from DB. - DERIVED : runtime generated response (LLM), optionally using ce_prompt_template . <CodeBlockToggle title=\"ce_response shape (DDL-style)\" language=\"sql\"> { CREATE TABLE ce_response ( response_id BIGSERIAL PRIMARY KEY, intent_code TEXT NOT NULL, state_code TEXT NOT NULL, response_type TEXT NOT NULL, -- EXACT | DERIVED output_format TEXT NOT NULL, -- TEXT | JSON response_text TEXT, response_json JSONB, enabled BOOLEAN NOT NULL DEFAULT TRUE, created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW() ); } </CodeBlockToggle> <CodeBlockToggle title=\"Example ce_response rows\" language=\"sql\"> { -- EXACT TEXT response INSERT INTO ce_response (intent_code, state_code, response_type, output_format, response_text, enabled) VALUES ('FAQ', 'IDLE', 'EXACT', 'TEXT', 'Yes, you can move your connection using Zapper app.', true); -- DERIVED JSON response INSERT INTO ce_response (intent_code, state_code, response_type, output_format, response_json, enabled) VALUES ('REQUEST_TRACKER', 'IDLE', 'DERIVED', 'JSON', '{\"template\":\"status-card\"}'::jsonb, true); } </CodeBlockToggle> ## ce_rule in detail ce_rule is the conditional transition/action layer executed in RulesStep . - rule_type : EXACT , REGEX , JSON_PATH - phase : PIPELINE_RULES , AGENT_POST_INTENT - action : SET_INTENT , SET_STATE , SET_JSON , GET_CONTEXT , GET_SCHEMA_JSON , GET_SESSION , SET_TASK <CodeBlockToggle title=\"ce_rule shape (DDL-style)\" language=\"sql\"> { CREATE TABLE ce_rule ( rule_id BIGSERIAL PRIMARY KEY, phase TEXT NOT NULL DEFAULT 'PIPELINE_RULES', intent_code TEXT NULL, rule_type TEXT NOT NULL, match_pattern TEXT NOT NULL, action TEXT NOT NULL, action_value TEXT NULL, priority INT NOT NULL DEFAULT 100, enabled BOOLEAN NOT NULL DEFAULT TRUE, description TEXT NULL, created_at TIMESTAMPTZ NOT NULL DEFAULT NOW() ); } </CodeBlockToggle> <CodeBlockToggle title=\"Example ce_rule rows\" language=\"sql\"> { -- If user says reset keywords, set reset intent INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'FAQ', 'REGEX', '(?i)^(reset|restart)$', 'SET_INTENT', 'RESET_SESSION', 10, true, 'Reset intent switch'); -- Agent post-intent bootstrap INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('AGENT_POST_INTENT', 'MAPPING_STUDIO', 'JSON_PATH', '$[?(@.intent == ''MAPPING_STUDIO'' && (@.state == ''UNKNOWN'' || @.state == ''IDLE''))]', 'SET_STATE', 'COLLECT_INPUTS', 5, true, 'Bootstrap mapping state during post-intent pass'); } </CodeBlockToggle> ### ce_rule.phase execution semantics Use phase to control where a rule executes. <DbTable title=\"Rule Phase Execution Matrix\" columns={[\"phase\", \"Executed by\", \"When it runs\", \"Typical usage\"]} rows={[ [\"PIPELINE_RULES\", \"RulesStep\", \"Normal pipeline pass after schema/auto-advance\", \"Business transitions, context actions, SET_TASK in standard flow\"], [\"AGENT_POST_INTENT\", \"AgentIntentResolver post-intent pass\", \"Immediately after agent accepts intent\", \"Bootstrap state from UNKNOWN/IDLE based on resolved intent\"], ]} /> <CodeBlockToggle title=\"Phase-targeted bootstrap example\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('AGENT_POST_INTENT', 'MAPPING_STUDIO', 'JSON_PATH', '$[?(@.intent == ''MAPPING_STUDIO'' && (@.state == ''UNKNOWN'' || @.state == ''IDLE''))]', 'SET_STATE', 'COLLECT_INPUTS', 5, true, 'Bootstrap Mapping Studio state right after agent intent resolution'); } </CodeBlockToggle> <Highlight type=\"info\" title=\"Runtime metadata exposed during rule execution\"> EngineSession/inputParams include phase metadata: - postIntentRule / post_intent_rule - rule_phase - rule_execution_source - rule_execution_origin </Highlight> ## Prompt variable guidance Common variables used in templates: - {{user_input}} - {{context}} - {{session}} - {{schema}} - {{conversation_history}} - schema helpers: {{missing_fields}} , {{missing_field_options}} , {{schema_description}} <Highlight type=\"warning\" title=\"Prompt variable exposure\"> Prompt template extra now includes all keys present in inputParams , including runtime/system-derived keys written through session.putInputParam(...) . Keep key naming and values controlled in consumer task/rule code. </Highlight> ## Runtime transport/audit properties <CodeBlockToggle title=\"application.yml (feature toggles)\" language=\"yaml\"> { convengine: transport: stomp: enabled: true broker: mode: SIMPLE # SIMPLE | RELAY relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL # ALL | STANDARD | ERROR_ONLY | NONE include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE # IMMEDIATE | DEFERRED_BULK jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS # CALLER_RUNS | DROP_NEWEST | DROP_OLDEST | ABORT keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 } </CodeBlockToggle> <CodeBlockToggle title=\"Optional annotations\" language=\"java\"> { @EnableConvEngine(stream = true) @EnableConvEngineAsyncAuditDispatch @EnableConvEngineStompBrokerRelay @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> ## New 1.0.8+ runtime controls explained 1. Async audit dispatch: - Moves transport fan-out off request thread when enabled. - Configure with convengine.audit.dispatch.* or @EnableConvEngineAsyncAuditDispatch . 2. Backpressure policy: - Queue capacity + rejection policy control behavior under burst. - CALLER_RUNS is safest default; DROP_* favors latency; ABORT is strict. 3. Stage-level audit controls: - level , include-stages , exclude-stages , and rate-limit reduce noisy audit traffic. 4. Deferred bulk persistence: - convengine.audit.persistence.mode=DEFERRED_BULK buffers events and writes batch inserts. - Flushes on terminal step/error (configurable), plus request-end safety flush. 5. STOMP broker mode: - SIMPLE (default): in-memory broker. - RELAY : external STOMP broker (RabbitMQ/other relay supporting STOMP). ## RabbitMQ relay example <CodeBlockToggle title=\"application-rabbitmq-relay.yml\" language=\"yaml\"> { convengine: transport: stomp: enabled: true endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit broker: mode: RELAY relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: guest client-passcode: guest system-login: guest system-passcode: guest virtual-host: / system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 } </CodeBlockToggle> ## Redis example (via STOMP gateway/bridge) <Highlight type=\"warning\" title=\"Redis note\"> ConvEngine STOMP relay requires a STOMP-compatible broker endpoint. Redis alone is not a native STOMP broker; use a STOMP gateway/bridge in front of Redis. </Highlight> <CodeBlockToggle title=\"application-redis-bridge-relay.yml\" language=\"yaml\"> { convengine: transport: stomp: enabled: true broker: mode: RELAY relay-destination-prefixes: /topic,/queue relay-host: redis-stomp-bridge.local relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" } </CodeBlockToggle>",
    "excerpt": "Configuration Deep Guide Table mapping in application.yml (ConvEngine + CCF Core) Use this when your physical table names differ from defaults. ConvEngine reads convengine.tables. ; CCF Core reads ccf.core.tables. . If y…"
  },
  {
    "id": "consumer/extensions.mdx",
    "title": "extensions",
    "permalink": "/docs/consumer/extensions",
    "content": "Extension Points and Intervention Scenarios EngineStepHook intervene between any steps Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } :::tip Where to use this Use hooks when you need low friction runtime intervention without forking framework steps. ::: ContainerDataTransformer reshape container response Real scenario: CCF returns nested payload; you flatten to schema friendly map. } } ResponseTransformer post process final payload Real scenario: Add support team escalation footer for high severity disconnect failures. return responsePayload; } } } ContainerDataInterceptor intercept request/response around CCF Real scenario: add tenant metadata and redact a field before persistence. Rule Action Playbook ( SET_TASK , SET_JSON , GET_CONTEXT , GET_SESSION ) These actions execute inside RulesStep.execute(...) and mutate the live EngineSession . Set ce_rule.phase based on where you want the action to run: PIPELINE_RULES : normal RulesStep pass. AGENT_POST_INTENT : post intent pass inside AgentIntentResolver . SET_TASK execute consumer Java methods from rule Use this when a rule match must trigger consumer side business logic (incident raise, tracker lookup, eligibility fetch, etc). Set ce_rule.action to SET_TASK and provide bean/method mapping in action_value . Bean must be a Spring bean with the configured bean name and implement CeRuleTask . Methods are invoked with (EngineSession session, CeRule rule) . public void attachEta(EngineSession session, CeRule rule) } } Downstream prompt/response can read new context/inputParams (for example requestStatus , lastUpdated , eta_hours ). SET_JSON move JSONPath value into input params Use this to extract one value from runtime session JSON into a flat prompt var. SET_JSON writes to session.putInputParam(\"error_code\", value) . It does not change session.contextJson unless your subsequent task/hook updates context explicitly. GET_CONTEXT snapshot context into input params Use this when prompt templates or tasks need full context as a single variable. If action_value is blank, engine uses default key context . GET_SESSION snapshot session facts into input params Use this for advanced derived responses that need runtime flags ( schemaComplete , intentLocked , missingRequiredFields , etc). If action_value is blank, engine uses default key session . SET_TASK methods run during rule execution. Keep methods deterministic and idempotent. For side effecting calls (ticket creation, webhook dispatch), guard with strict rule conditions and add idempotency keys from conversationId . Resolvers engine/rule/type/provider/SetTaskActionResolver.java engine/rule/type/provider/SetJsonActionResolver.java engine/rule/type/provider/GetContextActionResolver.java engine/rule/type/provider/GetSessionActionResolver.java Task invocation engine/rule/task/CeRuleTaskExecutor.java Execution loop engine/steps/RulesStep.java Custom action resolver ( RuleActionResolver ) Consumer can define a brand new rule action without changing framework core. Implement RuleActionResolver and return your action name from action() . @Override public void resolve(EngineSession session, CeRule rule) } } Set ce_rule.action to your custom token (case insensitive lookup), for example ENRICH_TIER . No manual factory config is needed. RuleActionResolverFactory auto registration behavior auto discovers all Spring beans implementing RuleActionResolver and maps by action().toUpperCase() .",
    "rawContent": "# Extension Points and Intervention Scenarios <div className=\"ce-extensions-page\"> ## EngineStepHook - intervene between any steps {#1-enginestephook---intervene-between-any-steps} Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. <CodeBlockToggle title=\"EngineStepHook example\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\"> { @Component public class LogAnalysisHintHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName && \"LOG_ANALYSIS\".equalsIgnoreCase(session.getIntent()); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"log_source_priority\", \"APM_FIRST\"); } } } </CodeBlockToggle> :::tip Where to use this Use hooks when you need low-friction runtime intervention without forking framework steps. ::: ## ContainerDataTransformer - reshape container response {#2-containerdatatransformer---reshape-container-response} Real scenario: CCF returns nested payload; you flatten to schema-friendly map. <CodeBlockToggle title=\"ContainerDataTransformer example\" language=\"java\" packagePath=\"com.zapper.convengine.transformers\"> { @Component @ContainerDataTransformer(intent = \"REQUEST_TRACKER\", state = \"IDLE\") public class RequestTrackerContainerTransformer implements ContainerDataTransformerHandler { @Override public Map<String, Object> transform(ContainerComponentResponse response, EngineSession session, Map<String, Object> inputParams) { Map<String, Object> out = new LinkedHashMap<>(); out.put(\"ticket_id\", inputParams.get(\"ticketId\")); out.put(\"status\", \"IN_REVIEW\"); return out; } } } </CodeBlockToggle> ## ResponseTransformer - post-process final payload {#3-responsetransformer---post-process-final-payload} Real scenario: Add support-team escalation footer for high-severity disconnect failures. <CodeBlockToggle title=\"ResponseTransformer example\" language=\"java\" packagePath=\"com.zapper.convengine.transformers\"> { @Component @ResponseTransformer(intent = \"DISCONNECT_ELECTRICITY\", state = \"FAILED\") public class DisconnectFailureResponseTransformer implements ResponseTransformerHandler { @Override public OutputPayload transform(OutputPayload responsePayload, EngineSession session, Map<String, Object> inputParams) { if (responsePayload instanceof TextPayload(String text)) { return new TextPayload(text + \"\\\\nIf this is urgent, call support at +1-800-000-0000.\"); } return responsePayload; } } } </CodeBlockToggle> ## ContainerDataInterceptor - intercept request/response around CCF {#4-containerdatainterceptor---intercept-requestresponse-around-ccf} Real scenario: add tenant metadata and redact a field before persistence. <CodeBlockToggle title=\"Interceptor scenario (concept)\" language=\"text\"> { Before Execute: - inject tenantId/requestId - attach observability headers After Execute: - redact sensitive node from raw container payload - enrich session input params for downstream rule checks } </CodeBlockToggle> ## Rule Action Playbook ( SET_TASK , SET_JSON , GET_CONTEXT , GET_SESSION ) {#5-rule-action-playbook-set_task-set_json-get_context-get_session} These actions execute inside <MethodRef>RulesStep.execute(...)</MethodRef> and mutate the live <MethodRef>EngineSession</MethodRef>. Set <MethodRef>ce_rule.phase</MethodRef> based on where you want the action to run: - <MethodRef>PIPELINE_RULES</MethodRef>: normal <MethodRef>RulesStep</MethodRef> pass. - <MethodRef>AGENT_POST_INTENT</MethodRef>: post-intent pass inside <MethodRef>AgentIntentResolver</MethodRef>. <DbTable title=\"Action value format (exact runtime behavior)\" columns={[\"Action\", \"action_value format\", \"Engine behavior\"]} rows={[ [\"SET_TASK\", \"beanName:methodName or beanName:methodA,methodB\", \"Invokes Spring bean methods via CeRuleTaskExecutor\"], [\"SET_JSON\", \"targetKey:jsonPath\", \"Extracts JSONPath from session eject and stores into inputParams[targetKey]\"], [\"GET_CONTEXT\", \"targetKey (optional)\", \"Stores session.contextDict() into inputParams[targetKey] (default key=context)\"], [\"GET_SESSION\", \"targetKey (optional)\", \"Stores session.sessionDict() into inputParams[targetKey] (default key=session)\"], ]} /> ### SET_TASK - execute consumer Java methods from rule {#51-set_task---execute-consumer-java-methods-from-rule} Use this when a rule match must trigger consumer-side business logic (incident raise, tracker lookup, eligibility fetch, etc). <FlowStep step=\"1\" title=\"Create ce_rule row\"> Set <MethodRef>ce_rule.action</MethodRef> to <MethodRef>SET_TASK</MethodRef> and provide bean/method mapping in <MethodRef>action_value</MethodRef>. </FlowStep> <CodeBlockToggle title=\"SET_TASK rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'REGEX', '(?i).*track.*request.*', 'SET_TASK', 'requestTrackerTask:loadStatus,attachEta', 10, true, 'Load tracker status + ETA from consumer service'); } </CodeBlockToggle> <FlowStep step=\"2\" title=\"Implement task bean\"> Bean must be a Spring bean with the configured bean name and implement <MethodRef>CeRuleTask</MethodRef>. Methods are invoked with <MethodRef>(EngineSession session, CeRule rule)</MethodRef>. </FlowStep> <CodeBlockToggle title=\"Consumer task bean (Java)\" language=\"java\" packagePath=\"com.zapper.convengine.tasks\" filePath=\"src/main/java/com/acme/convengine/tasks/RequestTrackerTask.java\" > { @Component(\"requestTrackerTask\") public class RequestTrackerTask implements CeRuleTask { public void loadStatus(EngineSession session, CeRule rule) { String requestId = String.valueOf(session.getInputParams().getOrDefault(\"requestId\", \"\")); // fetch from your DB/service session.putInputParam(\"requestStatus\", \"APPROVAL_PENDING\"); session.putInputParam(\"lastUpdated\", \"2026-02-10T11:40:00Z\"); } public void attachEta(EngineSession session, CeRule rule) { session.putInputParam(\"eta_hours\", 12); } } } </CodeBlockToggle> <FlowStep step=\"3\" title=\"Use in response generation\"> Downstream prompt/response can read new context/inputParams (for example requestStatus , lastUpdated , eta_hours ). </FlowStep> ### SET_JSON - move JSONPath value into input params {#52-set_json---move-jsonpath-value-into-input-params} Use this to extract one value from runtime session JSON into a flat prompt var. <CodeBlockToggle title=\"SET_JSON rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'LOG_ANALYSIS', 'JSON_PATH', '$.schemaJson.errorCode != null', 'SET_JSON', 'error_code:$.schemaJson.errorCode', 20, true, 'Expose extracted errorCode as prompt var'); } </CodeBlockToggle> <Highlight type=\"info\" title=\"What exactly gets updated\"> SET_JSON writes to <MethodRef>session.putInputParam(\"error_code\", value)</MethodRef>. It does not change session.contextJson unless your subsequent task/hook updates context explicitly. </Highlight> ### GET_CONTEXT - snapshot context into input params {#53-get_context---snapshot-context-into-input-params} Use this when prompt templates or tasks need full context as a single variable. <CodeBlockToggle title=\"GET_CONTEXT rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'REGEX', '(?i).*status.*', 'GET_CONTEXT', 'ctx_snapshot', 30, true, 'Expose full context to prompt/task layer'); } </CodeBlockToggle> If action_value is blank, engine uses default key context . ### GET_SESSION - snapshot session facts into input params {#54-get_session---snapshot-session-facts-into-input-params} Use this for advanced derived responses that need runtime flags ( schemaComplete , intentLocked , missingRequiredFields , etc). <CodeBlockToggle title=\"GET_SESSION rule example (SQL)\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'DISCONNECT_ELECTRICITY', 'JSON_PATH', '$.schemaComplete == false', 'GET_SESSION', 'session_snapshot', 40, true, 'Expose full runtime session facts for follow-up prompt decisions'); } </CodeBlockToggle> If action_value is blank, engine uses default key session . <Highlight type=\"warning\" title=\"Operational guardrails\"> SET_TASK methods run during rule execution. Keep methods deterministic and idempotent. For side-effecting calls (ticket creation, webhook dispatch), guard with strict rule conditions and add idempotency keys from <MethodRef>conversationId</MethodRef>. </Highlight> <Highlight type=\"tip\" title=\"Where to trace this in code\"> <div className=\"ce-chip-groups\"> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Resolvers</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/SetTaskActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/SetJsonActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/GetContextActionResolver.java</FileRef></span> <span className=\"ce-chip-item\"><FileRef>engine/rule/type/provider/GetSessionActionResolver.java</FileRef></span> </div> </div> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Task invocation</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/rule/task/CeRuleTaskExecutor.java</FileRef></span> </div> </div> <div className=\"ce-chip-group\"> <span className=\"ce-chip-group-label\">Execution loop</span> <div className=\"ce-chip-list\"> <span className=\"ce-chip-item\"><FileRef>engine/steps/RulesStep.java</FileRef></span> </div> </div> </div> </Highlight> ### Custom action resolver ( RuleActionResolver ) {#55-custom-action-resolver-ruleactionresolver} Consumer can define a brand-new rule action without changing framework core. <FlowStep step=\"1\" title=\"Create custom resolver bean\"> Implement <MethodRef>RuleActionResolver</MethodRef> and return your action name from <MethodRef>action()</MethodRef>. </FlowStep> <CodeBlockToggle title=\"Custom RuleActionResolver example\" language=\"java\" packagePath=\"com.zapper.convengine.rules\" filePath=\"src/main/java/com/acme/convengine/rules/EnrichCustomerTierActionResolver.java\" > { @Component public class EnrichCustomerTierActionResolver implements RuleActionResolver { @Override public String action() { return \"ENRICH_TIER\"; } @Override public void resolve(EngineSession session, CeRule rule) { // action_value example: customerTier:PREMIUM String raw = rule.getActionValue() == null ? \"\" : rule.getActionValue(); String[] parts = raw.split(\":\", 2); String key = parts.length > 0 && !parts[0].isBlank() ? parts[0] : \"customerTier\"; String value = parts.length > 1 ? parts[1] : \"STANDARD\"; session.putInputParam(key, value); } } } </CodeBlockToggle> <FlowStep step=\"2\" title=\"Use action in ce_rule\"> Set <MethodRef>ce_rule.action</MethodRef> to your custom token (case-insensitive lookup), for example <MethodRef>ENRICH_TIER</MethodRef>. </FlowStep> <CodeBlockToggle title=\"ce_rule row for custom action\" language=\"sql\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'REGEX', '(?i).*vip.*', 'ENRICH_TIER', 'customerTier:PREMIUM', 5, true, 'Mark VIP tier for downstream response logic'); } </CodeBlockToggle> <Highlight type=\"tip\" title=\"Auto-registration behavior\"> No manual factory config is needed. <DocTermPopup term=\"Auto-registration behavior\">RuleActionResolverFactory auto-registration behavior</DocTermPopup> auto-discovers all Spring beans implementing <MethodRef>RuleActionResolver</MethodRef> and maps by <MethodRef>action().toUpperCase()</MethodRef>. </Highlight> </div>",
    "excerpt": "Extension Points and Intervention Scenarios EngineStepHook intervene between any steps Real scenario: For LOG_ANALYSIS , inject additional retrieval hint before schema extraction. @Override public void beforeStep(EngineS…"
  },
  {
    "id": "consumer/index.mdx",
    "title": "index",
    "permalink": "/docs/consumer",
    "content": "Consumer Guide ConvEngine consumer integration is about wiring three things correctly: framework bootstrapping ( @EnableConvEngine ) LLM adapter ( LlmClient ) DB driven behavior ( ce_ control plane rows) 10 Minute Starter Use @EnableConvEngine on your Spring Boot entry point. Register a concrete LlmClient bean for intent/schema/derived flows. Apply DDL and seed minimum rows in ce_intent , ce_intent_classifier , ce_response , ce_prompt_template . Run a real turn and validate with /api/v1/conversation/audit/ '} and /api/v1/conversation/audit/ '}/trace . Dependency Core Contracts } } } } }. Answer as FAQ in 1 2 lines.', true ); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } } } Rollout Plan Treat ce_audit as mandatory observability. Promote behavior changes only after reviewing multi turn traces for each key intent.",
    "rawContent": "# Consumer Guide ConvEngine consumer integration is about wiring three things correctly: - framework bootstrapping ( @EnableConvEngine ) - LLM adapter ( LlmClient ) - DB-driven behavior ( ce_* control-plane rows) ## 10-Minute Starter <FlowStep step=\"1\" title=\"Enable framework\"> Use <MethodRef>@EnableConvEngine</MethodRef> on your Spring Boot entry point. </FlowStep> <FlowStep step=\"2\" title=\"Provide LlmClient\"> Register a concrete <MethodRef>LlmClient</MethodRef> bean for intent/schema/derived flows. </FlowStep> <FlowStep step=\"3\" title=\"Apply ce_* schema\"> Apply DDL and seed minimum rows in <FileRef>ce_intent</FileRef>, <FileRef>ce_intent_classifier</FileRef>, <FileRef>ce_response</FileRef>, <FileRef>ce_prompt_template</FileRef>. </FlowStep> <FlowStep step=\"4\" title=\"Validate with audit trace\"> Run a real turn and validate with <FileRef>/api/v1/conversation/audit/{'{conversationId}'}</FileRef> and <FileRef>/api/v1/conversation/audit/{'{conversationId}'}/trace</FileRef>. </FlowStep> ## Dependency <Tabs groupId=\"consumer-dependency\"> <TabItem value=\"maven\" label=\"Maven\" default> <CodeBlockToggle title=\"pom.xml dependency\" language=\"xml\" packagePath=\"project build\"> { <dependency> <groupId>com.github.salilvnair</groupId> <artifactId>convengine</artifactId> <version>1.0.9</version> </dependency> } </CodeBlockToggle> </TabItem> <TabItem value=\"gradle\" label=\"Gradle\"> <CodeBlockToggle title=\"build.gradle.kts dependency\" language=\"kotlin\" packagePath=\"project build\"> { implementation(\"com.github.salilvnair:convengine:1.0.9\") } </CodeBlockToggle> </TabItem> </Tabs> ## Core Contracts <DbTable title=\"Consumer-side contracts\" columns={[\"Contract\", \"Why it matters\", \"Where it plugs in\"]} rows={[ [\"@EnableConvEngine\", \"Bootstraps engine + pipeline + transport wiring\", \"Spring Boot application class\"], [\"LlmClient\", \"Provides text/json generation backend\", \"Consumer config bean\"], [\"ce_* tables\", \"Defines behavior as data, not hardcoded Java\", \"Consumer database\"], [\"EngineStepHook\", \"Allows pre/post step intervention\", \"Consumer extension bean\"], [\"ResponseTransformer\", \"Last-mile payload normalization\", \"Consumer extension bean\"], ]} /> <Tabs groupId=\"consumer-setup\"> <TabItem value=\"boot\" label=\"Bootstrapping\" default> <CodeBlockToggle title=\"Spring Boot entry point\" language=\"java\" packagePath=\"com.zapper.demo\" filePath=\"src/main/java/com/acme/demo/DemoApplication.java\"> { @SpringBootApplication @EnableConvEngine(stream = true) public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } } </CodeBlockToggle> <CodeBlockToggle title=\"LlmClient bean\" language=\"java\" packagePath=\"com.zapper.demo.config\" filePath=\"src/main/java/com/acme/demo/config/LlmConfig.java\"> { @Configuration public class LlmConfig { @Bean public LlmClient llmClient(OpenAiClient openAiClient) { return new OpenAiLlmClient(openAiClient); } } } </CodeBlockToggle> </TabItem> <TabItem value=\"seed\" label=\"Minimum Seed SQL\"> <CodeBlockToggle title=\"Minimum FAQ seed (consumer DB)\" language=\"sql\"> { insert into ce_intent(intent_code, enabled) values ('FAQ', true); insert into ce_intent_classifier(intent_code, match_pattern, priority, enabled) values ('FAQ', '(?i).*(office|location|address).*', 10, true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('FAQ', null, 'EXACT', 'TEXT', 'Yes. You can request relocation from the support portal.', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ( 'FAQ', null, 'TEXT', 'You are a support assistant. Keep answers concise and clear.', 'User asked: {{user_input}}. Answer as FAQ in 1-2 lines.', true ); } </CodeBlockToggle> </TabItem> <TabItem value=\"intervene\" label=\"Intervention Points\"> <CodeBlockToggle title=\"EngineStepHook (typed step matching)\" language=\"java\" packagePath=\"com.zapper.demo.hooks\" filePath=\"src/main/java/com/acme/demo/hooks/SchemaHintHook.java\"> { @Component public class SchemaHintHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName && \"DISCONNECT_ELECTRICITY\".equalsIgnoreCase(session.getIntent()); } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"consumer_hint\", \"compact\"); } } } </CodeBlockToggle> <CodeBlockToggle title=\"ResponseTransformer (last-mile output shaping)\" language=\"java\" packagePath=\"com.zapper.demo.transform\" filePath=\"src/main/java/com/acme/demo/transform/ApiResponseTransformer.java\"> { @Component public class ApiResponseTransformer implements ResponseTransformer { @Override public EngineResult transform(EngineResult result, EngineSession session) { // Example: add consumer-side envelope metadata return result.withMeta(Map.of(\"conversationId\", session.getConversationId())); } } } </CodeBlockToggle> </TabItem> </Tabs> ## Rollout Plan <DbTable title=\"Recommended rollout path\" columns={[\"Phase\", \"Scope\", \"Exit criteria\"]} rows={[ [\"Phase A\", \"EXACT responses + deterministic rules\", \"No unresolved intent collisions in audit\"], [\"Phase B\", \"Schema extraction + clarification flow\", \"Missing-field loop converges in <= 2 turns\"], [\"Phase C\", \"MCP + DERIVED output\", \"Stable tool-call traces and bounded token usage\"], ]} /> <Highlight type=\"warning\" title=\"Do not skip audit validation\"> Treat <FileRef>ce_audit</FileRef> as mandatory observability. Promote behavior changes only after reviewing multi-turn traces for each key intent. </Highlight>",
    "excerpt": "Consumer Guide ConvEngine consumer integration is about wiring three things correctly: framework bootstrapping ( @EnableConvEngine ) LLM adapter ( LlmClient ) DB driven behavior ( ce_ control plane rows) 10 Minute Starte…"
  },
  {
    "id": "consumer/new-consumer-onboarding.mdx",
    "title": "new consumer onboarding",
    "permalink": "/docs/consumer/new-consumer-onboarding",
    "content": "New Consumer Onboarding This is the practical playbook for teams integrating ConvEngine for the first time. Follow this sequence to avoid the common mistakes: wrong data routing, stale intent carry over, unsafe prompt exposure, and concurrency drift. What a new consumer must decide first Step by step onboarding Enable @EnableConvEngine , provide one production grade LlmClient bean with strict timeout and retry policy. Seed minimum rows for intents, classifiers, responses, prompt templates, and required ce_config flags. Apply conservative defaults for reset behavior, sticky intent, rule phases, MCP safety, and prompt variable exposure. Validate multi turn transitions, reset continuity, missing field loops, and same conversation concurrency behavior. Move from non prod to prod only after all correctness/security/scalability gates pass. Minimum integration checklist Recommended baseline config (new consumers) Do not begin with broad MCP usage, many DERIVED intents, and aggressive rule chains together. Start deterministic, then expand one capability at a time. Correctness focused test pack (required) Production readiness gates New intent rollout template (repeatable) 1. Add ce_intent and classifiers for the new intent. 2. Add response mapping ( EXACT first). 3. Add schema + prompt template only if extraction is needed. 4. Add minimal rules with explicit phase and priority. 5. Run scenario tests for this intent (normal, reset, switch, collision, concurrent). 6. Promote with rollback snapshot. Common new consumer mistakes After this page, continue with for table level setup, for all annotation usage, and for implementation roadmap.",
    "rawContent": "# New Consumer Onboarding This is the practical playbook for teams integrating ConvEngine for the first time. Follow this sequence to avoid the common mistakes: wrong data routing, stale intent carry-over, unsafe prompt exposure, and concurrency drift. ## What a new consumer must decide first <DbTable title=\"Day-0 decisions\" columns={[\"Decision\", \"Why it matters\", \"Recommended default\"]} rows={[ [\"Transport\", \"Determines runtime event delivery and operational complexity.\", \"Start with SSE only; enable STOMP relay later.\"], [\"Intent continuity\", \"Controls whether intent re-resolves each turn.\", \"Start with STICKY_INTENT=true , but add explicit switch UX.\"], [\"Response mode\", \"Defines determinism vs model flexibility.\", \"Start with EXACT for critical intents; add DERIVED gradually.\"], [\"Concurrency policy\", \"Prevents same-conversation race corruption.\", \"Serialize by conversationId at API layer from day one.\"], [\"Prompt exposure policy\", \"Controls data leakage and prompt contamination risk.\", \"Use allowlist of prompt vars; do not expose raw input maps.\"], ]} /> ## Step-by-step onboarding <FlowStep step=\"1\" title=\"Bootstrap framework and LLM adapter\"> Enable <MethodRef>@EnableConvEngine</MethodRef>, provide one production-grade <MethodRef>LlmClient</MethodRef> bean with strict timeout and retry policy. </FlowStep> <FlowStep step=\"2\" title=\"Create baseline control-plane data\"> Seed minimum rows for intents, classifiers, responses, prompt templates, and required ce_config flags. </FlowStep> <FlowStep step=\"3\" title=\"Lock down safety defaults\"> Apply conservative defaults for reset behavior, sticky-intent, rule phases, MCP safety, and prompt-variable exposure. </FlowStep> <FlowStep step=\"4\" title=\"Run correctness tests before UI rollout\"> Validate multi-turn transitions, reset continuity, missing-field loops, and same-conversation concurrency behavior. </FlowStep> <FlowStep step=\"5\" title=\"Promote with release gates\"> Move from non-prod to prod only after all correctness/security/scalability gates pass. </FlowStep> ## Minimum integration checklist <DbTable title=\"Must-have implementation tasks\" columns={[\"Area\", \"Task\", \"Done when\"]} rows={[ [\"Spring wiring\", \"Enable ConvEngine + define LlmClient bean.\", \" /message works and returns payload for seeded FAQ intent.\"], [\"Schema\", \"Apply DDL and create indexes from ConvEngine schema.\", \"All ce_* tables present and writable.\"], [\"Seed data\", \"Insert minimal rows for one end-to-end intent.\", \"One deterministic turn passes with expected intent/state.\"], [\"Audit usage\", \"Wire audit API/stream into debugging workflow.\", \"Every test case is verified against trace timeline.\"], [\"Concurrency guard\", \"Prevent parallel writes for same conversation.\", \"Load test shows no state drift under concurrent same-ID requests.\"], [\"Prompt hygiene\", \"Allowlist exposed template vars.\", \"No sensitive/internal keys appear in rendered prompts.\"], ]} /> ## Recommended baseline config (new consumers) <CodeBlockToggle title=\"Safe starter config (ConvEngine + CCF mappings)\" language=\"yaml\"> { convengine: transport: sse: enabled: true stomp: enabled: false audit: enabled: true level: STANDARD dispatch: async-enabled: false # ConvEngine dynamic table mapping tables: AUDIT: CE_AUDIT CONTAINER_CONFIG: CE_CONTAINER_CONFIG CONVERSATION: CE_CONVERSATION INTENT: CE_INTENT INTENT_CLASSIFIER: CE_INTENT_CLASSIFIER LLM_CALL_LOG: CE_LLM_CALL_LOG MCP_DB_TOOL: CE_MCP_DB_TOOL MCP_TOOL: CE_MCP_TOOL OUTPUT_SCHEMA: CE_OUTPUT_SCHEMA PROMPT_TEMPLATE: CE_PROMPT_TEMPLATE RESPONSE: CE_RESPONSE RULE: CE_RULE VALIDATION_SNAPSHOT: CE_VALIDATION_SNAPSHOT ccf: core: # CCF Core dynamic table mapping tables: PAGE_COMMON_QUERY: ZP_PAGE_COMMON_QUERY SECTION_INFO: ZP_SECTION_INFO CONTAINER_INFO: ZP_CONTAINER_INFO CONTAINER_FIELD_INFO: ZP_CONTAINER_FIELD_INFO CONTAINER_QUERY_INFO: ZP_CONTAINER_QUERY_INFO # In ce_config # IntentResolutionStep.STICKY_INTENT=true # ResetResolvedIntentStep.RESET_INTENT_CODES=RESET_SESSION,START_OVER # AgentIntentResolver.MIN_CONFIDENCE=0.60 } </CodeBlockToggle> <Highlight type=\"warning\" title=\"Do not start with max flexibility\"> Do not begin with broad MCP usage, many DERIVED intents, and aggressive rule chains together. Start deterministic, then expand one capability at a time. </Highlight> ## Correctness-focused test pack (required) <DbTable title=\"Pre-production test scenarios\" columns={[\"Scenario\", \"What to verify\", \"Failure signal\"]} rows={[ [\"Sticky intent shift\", \"New-topic user input triggers expected re-resolution/switch behavior.\", \"Repeated wrong-intent responses with skip stages.\"], [\"Reset semantics\", \"All reset paths clear context/intent/state consistently.\", \"Old fields survive after reset turn.\"], [\"Rule collisions\", \"Only intended rule wins for same turn.\", \"Unexpected multi-pass intent/state mutation.\"], [\"Schema loop\", \"Missing fields converge in bounded turns.\", \"Infinite clarification or inconsistent required field set.\"], [\"Concurrent same ID\", \"No last-write-wins drift under parallel requests.\", \"Contradictory final state for same conversation timeline.\"], [\"Model bad JSON\", \"Invalid model output fails safely and deterministically.\", \"Silent state corruption or unbounded fallback noise.\"], ]} /> ## Production readiness gates <DbTable title=\"Go-live gates\" columns={[\"Gate\", \"Requirement\"]} rows={[ [\"Data correctness\", \"Illegal intent/state transitions are blocked or quarantined.\"], [\"Security\", \"Prompt var allowlist and secret redaction enabled.\"], [\"Concurrency\", \"Same-conversation serialization or optimistic locking in place.\"], [\"Observability\", \"Team can reconstruct one bad turn end-to-end from trace.\"], [\"Scalability\", \"P95 stable under target QPS with production-like config volume.\"], [\"Rollback\", \"Config rollback procedure tested for bad rule/prompt deployment.\"], ]} /> ## New intent rollout template (repeatable) 1. Add ce_intent and classifiers for the new intent. 2. Add response mapping ( EXACT first). 3. Add schema + prompt template only if extraction is needed. 4. Add minimal rules with explicit phase and priority. 5. Run scenario tests for this intent (normal, reset, switch, collision, concurrent). 6. Promote with rollback snapshot. ## Common new-consumer mistakes <DbTable title=\"Avoid these early mistakes\" columns={[\"Mistake\", \"Impact\", \"Fix\"]} rows={[ [\"Using DERIVED everywhere from day one\", \"Higher variance and harder debugging.\", \"Use EXACT for critical flows first.\"], [\"No conversation-level concurrency control\", \"State drift and non-deterministic results.\", \"Serialize by conversation ID or add optimistic locking.\"], [\"Treating prompt vars as free-form\", \"Data leakage and unintended model behavior.\", \"Explicit prompt-var allowlist and validation.\"], [\"Shipping config changes without tests\", \"Production regressions from rule/template misconfig.\", \"Introduce lint + fixture tests + staged promotion.\"], [\"Skipping trace review\", \"Root cause unclear when output is wrong.\", \"Make trace review mandatory in QA signoff.\"], ]} /> <Highlight type=\"info\" title=\"Where to read next\"> After this page, continue with [Configuration](/docs/consumer/configuration) for table-level setup, [Annotations Reference](/docs/consumer/annotations-reference) for all annotation usage, and [Improvement Backlog](/docs/deep-dive/improvement-backlog) for implementation roadmap. </Highlight>",
    "excerpt": "New Consumer Onboarding This is the practical playbook for teams integrating ConvEngine for the first time. Follow this sequence to avoid the common mistakes: wrong data routing, stale intent carry over, unsafe prompt ex…"
  },
  {
    "id": "consumer/session-reset-and-continuity.mdx",
    "title": "session reset and continuity",
    "permalink": "/docs/consumer/session-reset-and-continuity",
    "content": "Session, Reset, and Continuity What is restored per turn From ce_conversation , session restores: intent_code state_code context_json input_params_json From context branch values, session also restores cross turn values such as clarification and intent lock metadata. Intent lock lifecycle Intent lock is used for incomplete schema collection to avoid drift. lock set when required schema fields are still missing intent resolver skip logic respects lock lock removed when schema is complete or schema path is absent Sticky intent lifecycle ( ce_config ) Even after schema lock is released, you can keep intent stable across turns with IntentResolutionStep.STICKY_INTENT . when enabled, IntentResolutionStep skips re resolution if current intent/state are already resolved skip emits audit stage: INTENT_RESOLVE_SKIPPED_STICKY_INTENT re resolution still runs for explicit switch/reset/force signals Force re resolution signals: reset commands: reset , restart , /reset , /restart switch phrases: switch to ... , switch intent , change intent/flow/mode input params: force_intent_resolution=true , resolve_intent=true , switch_intent=true , switch_flow=true , switch_mode=true active clarification flow Reset triggers request body reset=true input params reset , restart , conversation_reset text commands reset , restart , /reset , /restart intent based reset via ResetResolvedIntentStep ( ce_config ) Practical advice Keep reset intent names explicit and reserved ( RESET_SESSION style) Avoid mixing business intents with reset intents Audit CONVERSATION_RESET stages in pre production tests If reset logic is custom coded only in controller, multi turn state may still leak from existing conversation context. Use pipeline reset steps, not ad hoc request branching.",
    "rawContent": "# Session, Reset, and Continuity ## What is restored per turn From ce_conversation , session restores: - intent_code - state_code - context_json - input_params_json From context branch values, session also restores cross-turn values such as clarification and intent lock metadata. ## Intent lock lifecycle Intent lock is used for incomplete schema collection to avoid drift. - lock set when required schema fields are still missing - intent resolver skip logic respects lock - lock removed when schema is complete or schema path is absent ## Sticky intent lifecycle ( ce_config ) Even after schema lock is released, you can keep intent stable across turns with IntentResolutionStep.STICKY_INTENT . - when enabled, IntentResolutionStep skips re-resolution if current intent/state are already resolved - skip emits audit stage: INTENT_RESOLVE_SKIPPED_STICKY_INTENT - re-resolution still runs for explicit switch/reset/force signals <CodeBlockToggle title=\"Sticky intent config\" language=\"sql\"> { INSERT INTO ce_config (config_type, config_key, config_value, enabled) VALUES ('IntentResolutionStep', 'STICKY_INTENT', 'true', true); } </CodeBlockToggle> Force re-resolution signals: - reset commands: reset , restart , /reset , /restart - switch phrases: switch to ... , switch intent , change intent/flow/mode - input params: force_intent_resolution=true , resolve_intent=true , switch_intent=true , switch_flow=true , switch_mode=true - active clarification flow ## Reset triggers - request body reset=true - input params reset , restart , conversation_reset - text commands reset , restart , /reset , /restart - intent-based reset via ResetResolvedIntentStep ( ce_config ) <CodeBlockToggle title=\"Reset intent config\" language=\"sql\"> { INSERT INTO ce_config (config_type, config_key, config_value, enabled) VALUES ('ResetResolvedIntentStep', 'RESET_INTENT_CODES', 'RESET_SESSION,START_OVER', true); } </CodeBlockToggle> ## Practical advice - Keep reset intent names explicit and reserved ( RESET_SESSION style) - Avoid mixing business intents with reset intents - Audit CONVERSATION_RESET stages in pre-production tests <Highlight type=\"warning\" title=\"Common failure mode\"> If reset logic is custom-coded only in controller, multi-turn state may still leak from existing conversation context. Use pipeline reset steps, not ad-hoc request branching. </Highlight>",
    "excerpt": "Session, Reset, and Continuity What is restored per turn From ce_conversation , session restores: intent_code state_code context_json input_params_json From context branch values, session also restores cross turn values …"
  },
  {
    "id": "consumer/ui-integration.mdx",
    "title": "ui integration",
    "permalink": "/docs/consumer/ui-integration",
    "content": "UI Integration This page shows end to end UI wiring with: React (Vite) in JS + TS Angular (standalone) in TS SSE now + STOMP commented for later switch POST to /api/v1/conversation/message using conversationId and message . Use EventSource on /api/v1/conversation/stream/ '} . On each stream event, refresh /audit/ '} or trace endpoint. React Vite (JavaScript) , body: JSON.stringify( ), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const res = await fetch(API_BASE + \"/audit/\" + conversationId); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () = handlers.onConnected?.(); source.onerror = (error) = handlers.onError?.(error); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) = catch handlers.onEvent?.( ); }); }); return }; } // STOMP scaffold (optional) // npm install @stomp/stompjs sockjs client // import from \"@stomp/stompjs\"; // import SockJS from \"sockjs client\"; // export function subscribeConversationStomp(conversationId, handlers = ) // catch // }); // }, // onStompError: (frame) = handlers.onError?.(frame), // }); // client.activate(); // return }; // } } from \"react\"; const [conversationId] = useState(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState(0); useEffect(() = ); // STOMP alternate: // const stream = subscribeConversationStomp(conversationId, ); return () = stream.close(); }, [conversationId]); return conversationId= auditVersion= ; } } React Vite (TypeScript) onConnected?: () = void; onEvent?: (event: StreamEvent ) = void; onError?: (event: Event) = void; onClosed?: () = void; } conversationId: string, message: string, inputParams: Record = , reset = false ) , body: JSON.stringify( ), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } conversationId: string, handlers: StreamHandlers = ) catch handlers.onEvent?.( ); }); }); return }; } } from \"react\"; const [conversationId] = useState (crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState (0); useEffect(() = , }); return () = stream.close(); }, [conversationId]); return auditVersion= ; } } Angular Integration (authored sample) from '@angular/core'; stage: string; data: T | null; raw: MessageEvent; } @Injectable( ) private readonly apiBase = 'http://localhost:8080/api/v1/conversation'; constructor(private readonly http: HttpClient) sendMessage(payload: ): Observable fetchAudits(conversationId: string): Observable subscribeConversationSse( conversationId: string, handlers: = ) catch handlers.onEvent?.( ); }); }); return }; } // STOMP scaffold (optional) // npm i @stomp/stompjs sockjs client // connect ws://localhost:8080/ws convengine // subscribe /topic/convengine/audit/ } } from '@angular/core'; @Component( ) conversationId = crypto.randomUUID(); message = ''; messages: Array = []; typing = false; private streamCloser: | null = null; constructor(private readonly api: ConvengineApiService) ngOnInit(): void }); } send(): void ); this.message = ''; this.typing = true; this.api.sendMessage( ).subscribe( ); this.typing = false; }, error: () = }); } ngOnDestroy(): void } } } Agent is typing... Send } Keep one shared backend contract for conversationId , payload.type , and audit stage names. Only transport/client wrappers should differ per framework.",
    "rawContent": "# UI Integration This page shows end-to-end UI wiring with: - React (Vite) in JS + TS - Angular (standalone) in TS - SSE now + STOMP commented for later switch <FlowStep step=\"1\" title=\"Call message API\"> POST to <FileRef>/api/v1/conversation/message</FileRef> using <MethodRef>conversationId</MethodRef> and <MethodRef>message</MethodRef>. </FlowStep> <FlowStep step=\"2\" title=\"Subscribe to stream\"> Use <MethodRef>EventSource</MethodRef> on <FileRef>/api/v1/conversation/stream/{'{conversationId}'}</FileRef>. </FlowStep> <FlowStep step=\"3\" title=\"Refresh timeline\"> On each stream event, refresh <FileRef>/audit/{'{conversationId}'}</FileRef> or trace endpoint. </FlowStep> ## React Vite (JavaScript) <CodeBlockToggle title=\"convengine.api.js\" language=\"js\" packagePath=\"src/api\" filePath=\"src/api/convengine.api.js\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; const res = await fetch(API_BASE + \"/message\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ conversationId, message, reset, inputParams }), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const res = await fetch(API_BASE + \"/audit/\" + conversationId); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (error) => handlers.onError?.(error); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data = null; try { data = event.data ? JSON.parse(event.data) : null; } catch {} handlers.onEvent?.({ stage, data, raw: event }); }); }); return { close() { source.close(); handlers.onClosed?.(); } }; } // STOMP scaffold (optional) // npm install @stomp/stompjs sockjs-client // import { Client } from \"@stomp/stompjs\"; // import SockJS from \"sockjs-client\"; // export function subscribeConversationStomp(conversationId, handlers = {}) { // const client = new Client({ // webSocketFactory: () => new SockJS(\"http://localhost:8080/ws-convengine\"), // reconnectDelay: 5000, // onConnect: () => { // handlers.onConnected?.(); // client.subscribe(\"/topic/convengine/audit/\" + conversationId, (msg) => { // try { handlers.onEvent?.(JSON.parse(msg.body)); } // catch { handlers.onEvent?.(msg.body); } // }); // }, // onStompError: (frame) => handlers.onError?.(frame), // }); // client.activate(); // return { close() { client.deactivate(); handlers.onClosed?.(); } }; // } } </CodeBlockToggle> <CodeBlockToggle title=\"App.jsx\" language=\"jsx\" packagePath=\"src\" filePath=\"src/App.jsx\" > { import { useEffect, useState } from \"react\"; const [conversationId] = useState(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState(0); useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion((v) => v + 1), onEvent: () => setAuditVersion((v) => v + 1), }); // STOMP alternate: // const stream = subscribeConversationStomp(conversationId, { ... }); return () => stream.close(); }, [conversationId]); return <div>conversationId={conversationId} auditVersion={auditVersion}</div>; } } </CodeBlockToggle> ## React Vite (TypeScript) <CodeBlockToggle title=\"convengine.api.ts\" language=\"ts\" packagePath=\"src/api\" filePath=\"src/api/convengine.api.ts\" > { const API_BASE = \"http://localhost:8080/api/v1/conversation\"; | \"CONNECTED\" | \"USER_INPUT\" | \"STEP_ENTER\" | \"STEP_EXIT\" | \"STEP_ERROR\" | \"ASSISTANT_OUTPUT\" | \"ENGINE_RETURN\" | \"MESSAGE\"; stage: SseStage; data: T | null; raw: MessageEvent; } onConnected?: () => void; onEvent?: (event: StreamEvent<T>) => void; onError?: (event: Event) => void; onClosed?: () => void; } conversationId: string, message: string, inputParams: Record<string, unknown> = {}, reset = false ) { const res = await fetch(API_BASE + \"/message\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ conversationId, message, inputParams, reset }), }); if (!res.ok) throw new Error(\"Backend error: \" + res.status); return res.json(); } conversationId: string, handlers: StreamHandlers<T> = {} ) { const source = new EventSource(API_BASE + \"/stream/\" + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (event) => handlers.onError?.(event); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data: T | null = null; try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) as T : null; } catch { data = null; } handlers.onEvent?.({ stage: stage as SseStage, data, raw: event as MessageEvent }); }); }); return { close() { source.close(); handlers.onClosed?.(); } }; } } </CodeBlockToggle> <CodeBlockToggle title=\"App.tsx\" language=\"tsx\" packagePath=\"src\" filePath=\"src/App.tsx\" > { import { useEffect, useState } from \"react\"; const [conversationId] = useState<string>(crypto.randomUUID()); const [auditVersion, setAuditVersion] = useState<number>(0); useEffect(() => { const stream = subscribeConversationSse(conversationId, { onConnected: () => setAuditVersion((v) => v + 1), onEvent: () => setAuditVersion((v) => v + 1), onError: () => {}, }); return () => stream.close(); }, [conversationId]); return <main>auditVersion={auditVersion}</main>; } } </CodeBlockToggle> ## Angular Integration (authored sample) <CodeBlockToggle title=\"convengine-api.service.ts\" language=\"ts\" packagePath=\"src/app/core\" filePath=\"src/app/core/convengine-api.service.ts\" > { import { Injectable } from '@angular/core'; stage: string; data: T | null; raw: MessageEvent; } @Injectable({ providedIn: 'root' }) private readonly apiBase = 'http://localhost:8080/api/v1/conversation'; constructor(private readonly http: HttpClient) {} sendMessage(payload: { conversationId: string; message: string; reset?: boolean; inputParams?: Record<string, unknown>; }): Observable<any> { return this.http.post(this.apiBase + '/message', payload); } fetchAudits(conversationId: string): Observable<any[]> { return this.http.get<any[]>(this.apiBase + '/audit/' + conversationId); } subscribeConversationSse( conversationId: string, handlers: { onConnected?: () => void; onEvent?: (event: ConversationEvent) => void; onError?: (event: Event) => void; onClosed?: () => void; } = {} ) { const source = new EventSource(this.apiBase + '/stream/' + conversationId); source.onopen = () => handlers.onConnected?.(); source.onerror = (event) => handlers.onError?.(event); [\"CONNECTED\", \"USER_INPUT\", \"STEP_ENTER\", \"STEP_EXIT\", \"STEP_ERROR\", \"ASSISTANT_OUTPUT\", \"ENGINE_RETURN\"] .forEach((stage) => { source.addEventListener(stage, (event) => { let data: unknown = null; try { data = (event as MessageEvent).data ? JSON.parse((event as MessageEvent).data) : null; } catch { data = null; } handlers.onEvent?.({ stage, data, raw: event as MessageEvent }); }); }); return { close: () => { source.close(); handlers.onClosed?.(); } }; } // STOMP scaffold (optional) // npm i @stomp/stompjs sockjs-client // connect ws://localhost:8080/ws-convengine // subscribe /topic/convengine/audit/{conversationId} } } </CodeBlockToggle> <CodeBlockToggle title=\"chat.component.ts\" language=\"ts\" packagePath=\"src/app/features/chat\" filePath=\"src/app/features/chat/chat.component.ts\" > { import { Component, OnDestroy, OnInit } from '@angular/core'; @Component({ standalone: true, selector: 'app-chat', imports: [CommonModule, FormsModule], templateUrl: './chat.component.html' }) conversationId = crypto.randomUUID(); message = ''; messages: Array<{ role: 'user' | 'assistant'; text: string }> = []; typing = false; private streamCloser: { close: () => void } | null = null; constructor(private readonly api: ConvengineApiService) {} ngOnInit(): void { this.streamCloser = this.api.subscribeConversationSse(this.conversationId, { onEvent: () => { // optionally refresh audit panel } }); } send(): void { const text = this.message.trim(); if (!text || this.typing) return; this.messages.push({ role: 'user', text }); this.message = ''; this.typing = true; this.api.sendMessage({ conversationId: this.conversationId, message: text }).subscribe({ next: (res) => { const value = res?.payload?.value ?? ''; this.messages.push({ role: 'assistant', text: String(value) }); this.typing = false; }, error: () => { this.typing = false; } }); } ngOnDestroy(): void { this.streamCloser?.close(); } } } </CodeBlockToggle> <CodeBlockToggle title=\"chat.component.html\" language=\"html\" packagePath=\"src/app/features/chat\" filePath=\"src/app/features/chat/chat.component.html\" > { <section class=\"chat-shell\"> <div class=\"messages\"> <div *ngFor=\"let m of messages\" [class.user]=\"m.role === 'user'\" [class.assistant]=\"m.role === 'assistant'\"> {{ m.text }} </div> <div *ngIf=\"typing\" class=\"assistant typing\">Agent is typing...</div> </div> <div class=\"composer\"> <input [(ngModel)]=\"message\" placeholder=\"Type message\" /> <button (click)=\"send()\" [disabled]=\"typing\">Send</button> </div> </section> } </CodeBlockToggle> <Highlight type=\"tip\" title=\"React + Angular parity\"> Keep one shared backend contract for <MethodRef>conversationId</MethodRef>, <MethodRef>payload.type</MethodRef>, and audit stage names. Only transport/client wrappers should differ per framework. </Highlight>",
    "excerpt": "UI Integration This page shows end to end UI wiring with: React (Vite) in JS + TS Angular (standalone) in TS SSE now + STOMP commented for later switch POST to /api/v1/conversation/message using conversationId and messag…"
  },
  {
    "id": "deep-dive/data-model.mdx",
    "title": "data model",
    "permalink": "/docs/deep-dive/data-model",
    "content": "Data Model ConvEngine is configuration driven. Behavior is defined in the following tables. Configuration Tables Runtime Tables Session API When writing Java extensions (Interceptors, Transformers), you interact with EngineSession . Common Operations Setting a Task ( SET_TASK action) Tasks are triggered through rule action resolution, not by writing arbitrary task keys in context. Configure ce_rule.action=SET_TASK and map action_value to a Spring task bean method. } } Getting Extracted Data Access data extracted by the Schema Extraction step.",
    "rawContent": "# Data Model ConvEngine is configuration-driven. Behavior is defined in the following tables. ## Configuration Tables <DbTable title=\"Core Tables\" columns={[\"Table\", \"Purpose\", \"Key Columns\"]} rows={[ [\"ce_intent\", \"Defines business intents\", \"intent_code, description, enabled\"], [\"ce_intent_classifier\", \"Regex patterns for intents\", \"match_pattern, priority\"], [\"ce_rule\", \"Logic & State Transitions\", \"phase, rule_type, action, match_pattern\"], [\"ce_response\", \"Output mapping\", \"response_type, output_format, exact_text\"], [\"ce_output_schema\", \"Data extraction definition\", \"json_schema, priority\"], [\"ce_prompt_template\", \"LLM Prompts\", \"system_prompt, user_prompt\"], ]} /> ## Runtime Tables <DbTable title=\"Runtime Persistence\" columns={[\"Table\", \"Purpose\"]} rows={[ [\"ce_conversation\", \"Current state of active conversations\"], [\"ce_audit\", \"Append-only log of every step execution\"], ]} /> --- # Session API When writing Java extensions (Interceptors, Transformers), you interact with EngineSession . <CodeBlockToggle title=\"EngineSession.java (key methods)\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.session\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/session/EngineSession.java\" > { // State Management void setIntent(String intent); void setState(String state); // Extras/Input params used by steps, prompts and rules Map<String, Object> getInputParams(); void putInputParam(String key, Object value); // Persisted Entity CeConversation getConversation(); // Flow Control void setFinalResult(EngineResult result); // Stop pipeline immediately } </CodeBlockToggle> ## Common Operations ### Setting a Task ( SET_TASK action) Tasks are triggered through rule action resolution, not by writing arbitrary task keys in context. Configure ce_rule.action=SET_TASK and map action_value to a Spring task bean method. <CodeBlockToggle title=\"SET_TASK rule row\" language=\"sql\" packagePath=\"consumer DB\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'REGEX', '(?i).*track.*request.*', 'SET_TASK', 'requestTrackerTask:loadStatus', 10, true, 'Invoke consumer task bean during rule execution'); } </CodeBlockToggle> <CodeBlockToggle title=\"Consumer task bean method\" language=\"java\" packagePath=\"consumer logic\"> { @Component(\"requestTrackerTask\") public class RequestTrackerTask implements CeRuleTask { public void loadStatus(EngineSession session, CeRule rule) { // Populate context/input params for downstream response session.putInputParam(\"requestStatus\", \"IN_REVIEW\"); } } } </CodeBlockToggle> ### Getting Extracted Data Access data extracted by the Schema Extraction step. <CodeBlockToggle title=\"Read extracted value\" language=\"java\" packagePath=\"consumer logic\"> { String accountId = (String) session.getInputParams().get(\"accountId\"); } </CodeBlockToggle>",
    "excerpt": "Data Model ConvEngine is configuration driven. Behavior is defined in the following tables. Configuration Tables Runtime Tables Session API When writing Java extensions (Interceptors, Transformers), you interact with Eng…"
  },
  {
    "id": "deep-dive/developer-guide.mdx",
    "title": "developer guide",
    "permalink": "/docs/deep-dive/developer-guide",
    "content": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , , , , ]; x1: , x2: , x3: , x4: , x5: , x6: , x7: , x8: , x9: , x10: , x11: , }; Developer Guide This page is the full implementation starter for consumers integrating ConvEngine into a Spring Boot service. 1. Start a Spring Boot project } } 2. Required schema (DDL) '::jsonb NOT NULL, input_params_json jsonb DEFAULT ' '::jsonb NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, updated_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_conversation_pkey PRIMARY KEY (conversation_id) ); CREATE INDEX idx_ce_conversation_status ON ce_conversation USING btree (status); CREATE INDEX idx_ce_conversation_updated ON ce_conversation USING btree (updated_at); CREATE TABLE ce_intent ( intent_code text NOT NULL, description text NOT NULL, priority int4 DEFAULT 100 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, display_name text NULL, llm_hint text NULL, CONSTRAINT ce_intent_pkey PRIMARY KEY (intent_code) ); CREATE INDEX ix_ce_intent_enabled_priority ON ce_intent USING btree (enabled, priority, intent_code); CREATE TABLE ce_output_schema ( schema_id bigserial NOT NULL, intent_code text NOT NULL, state_code text NOT NULL, json_schema jsonb NOT NULL, enabled bool DEFAULT true NULL, priority int4 NOT NULL, CONSTRAINT ce_output_schema_pkey PRIMARY KEY (schema_id) ); CREATE INDEX idx_ce_output_schema_lookup ON ce_output_schema USING btree (intent_code, state_code, enabled, priority); CREATE TABLE ce_prompt_template ( template_id bigserial NOT NULL, intent_code text NULL, state_code text NULL, response_type text NOT NULL, system_prompt text NOT NULL, user_prompt text NOT NULL, temperature numeric(3,2) DEFAULT 0.0 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_prompt_template_pkey PRIMARY KEY (template_id) ); CREATE INDEX idx_ce_prompt_template_lookup ON ce_prompt_template USING btree (response_type, intent_code, state_code, enabled); CREATE TABLE ce_response ( response_id bigserial NOT NULL, intent_code text NULL, state_code text NOT NULL, output_format text NOT NULL, response_type text NOT NULL, exact_text text NULL, derivation_hint text NULL, json_schema jsonb NULL, priority int4 DEFAULT 100 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_response_pkey PRIMARY KEY (response_id) ); CREATE INDEX idx_ce_response_intent_state ON ce_response USING btree (intent_code, state_code, enabled, priority); CREATE INDEX idx_ce_response_lookup ON ce_response USING btree (state_code, enabled, priority); CREATE TABLE ce_rule ( rule_id bigserial NOT NULL, phase text DEFAULT 'PIPELINE_RULES' NOT NULL, intent_code text NULL, rule_type text NOT NULL, match_pattern text NOT NULL, action text NOT NULL, action_value text NULL, priority int4 DEFAULT 100 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_rule_pkey PRIMARY KEY (rule_id) ); CREATE INDEX idx_ce_rule_priority ON ce_rule USING btree (enabled, phase, priority); CREATE TABLE ce_audit ( audit_id bigserial NOT NULL, conversation_id uuid NOT NULL, stage text NOT NULL, payload_json jsonb NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_audit_pkey PRIMARY KEY (audit_id), CONSTRAINT ce_audit_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES ce_conversation(conversation_id) ON DELETE CASCADE ); CREATE INDEX idx_ce_audit_conversation ON ce_audit USING btree (conversation_id, created_at DESC); } Run the complete DDL from src/main/resources/sql/ddl.sql in the ConvEngine library. The snippet above is onboarding focused. 3. Minimal DML for FAQ scenario 4. application.yml (full consumer starter) application.yml tag reference = 1\", \"Default 2\"], [\"convengine.audit.dispatch.queue capacity\", \"Dispatch queue size\", \"integer = 1\", \"Default 2000\"], [\"convengine.audit.dispatch.rejection policy\", \"Backpressure behavior\", \"CALLER_RUNS | DROP_NEWEST | DROP_OLDEST | ABORT\", \"Default CALLER_RUNS\"], [\"convengine.audit.dispatch.keep alive seconds\", \"Thread keep alive\", \"seconds\", \"Default 60\"], [\"convengine.audit.rate limit.enabled\", \"Enable per window throttling\", \"true | false\", \"Default false\"], [\"convengine.audit.rate limit.max events\", \"Events allowed per window\", \"integer\", \"Default 200\"], [\"convengine.audit.rate limit.window ms\", \"Rate limit window\", \"milliseconds\", \"Default 1000\"], [\"convengine.audit.rate limit.per conversation\", \"Bucket by conversation\", \"true | false\", \"Default true\"], [\"convengine.audit.rate limit.per stage\", \"Bucket by stage\", \"true | false\", \"Default true\"], [\"convengine.audit.rate limit.max tracked buckets\", \"Bucket cardinality cap\", \"integer\", \"Default 20000\"], [\"convengine.audit.persistence.mode\", \"DB persistence mode\", \"IMMEDIATE | DEFERRED_BULK\", \"Default IMMEDIATE\"], [\"convengine.audit.persistence.jdbc batch size\", \"Batch insert chunk size\", \"integer\", \"Default 200\"], [\"convengine.audit.persistence.max buffered events\", \"Deferred buffer cap\", \"integer\", \"Default 5000\"], [\"convengine.audit.persistence.flush stages\", \"Stages forcing flush\", \"list of stages\", \"Defaults include engine failure stages\"], [\"convengine.audit.persistence.final step names\", \"Final steps that flush\", \"list of step names\", \"Default includes PipelineEndGuardStep\"], [\"convengine.audit.persistence.flush on stop outcome\", \"Flush on STOP step outcome\", \"true | false\", \"Default true\"], ]} / If @EnableConvEngine(stream=true) is set, startup fails when both convengine.transport.sse.enabled=false and convengine.transport.stomp.enabled=false . 5. API entry and session contracts } 6. Extension examples @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } } } } @Component public class MyContainerTransformer implements ContainerDataTransformer } @Component public class MyResponseTransformer implements ResponseTransformer } } 7. Persistence, audit and streaming tuning Start with direct HTTP + IMMEDIATE audit. Then enable async dispatch and bounded queue. Move to DEFERRED_BULK only after validating final step flush behavior for your trace requirements.",
    "rawContent": "{ id: \"x1\", position: { x: 20, y: 60 }, data: { label: \"ConversationController.message\" } }, { id: \"x2\", position: { x: 260, y: 60 }, data: { label: \"ContainerDataInterceptor\" } }, { id: \"x3\", position: { x: 500, y: 60 }, data: { label: \"EngineSessionFactory.open\" } }, { id: \"x4\", position: { x: 740, y: 60 }, data: { label: \"EnginePipeline.execute\" } }, { id: \"x5\", position: { x: 20, y: 230 }, data: { label: \"EngineStepHook.beforeStep\" } }, { id: \"x6\", position: { x: 260, y: 230 }, data: { label: \"Step.execute\" } }, { id: \"x7\", position: { x: 500, y: 230 }, data: { label: \"EngineStepHook.afterStep/onStepError\" } }, { id: \"x8\", position: { x: 740, y: 230 }, data: { label: \"ContainerDataTransformer\" } }, { id: \"x9\", position: { x: 260, y: 400 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"x10\", position: { x: 500, y: 400 }, data: { label: \"ResponseTransformer\" } }, { id: \"x11\", position: { x: 740, y: 400 }, data: { label: \"HTTP/SSE/STOMP output\" } }, ]; { id: \"xe1\", source: \"x1\", target: \"x2\" }, { id: \"xe2\", source: \"x2\", target: \"x3\" }, { id: \"xe3\", source: \"x3\", target: \"x4\" }, { id: \"xe4\", source: \"x4\", target: \"x5\" }, { id: \"xe5\", source: \"x5\", target: \"x6\" }, { id: \"xe6\", source: \"x6\", target: \"x7\" }, { id: \"xe7\", source: \"x7\", target: \"x8\" }, { id: \"xe8\", source: \"x8\", target: \"x9\" }, { id: \"xe9\", source: \"x9\", target: \"x10\" }, { id: \"xe10\", source: \"x10\", target: \"x11\" }, ]; x1: { title: \"API Entry\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Builds EngineContext and delegates to engine.\", session: [\"userText, conversationId, inputParams\"], tables: [\"none\"] }, x2: { title: \"Input interception\", file: \"engine/interceptor/ContainerDataInterceptor.java\", method: \"intercept(...) \", stage: \"INPUT_INTERCEPT\", summary: \"Mutate input params before session start.\", session: [\"inputParams can be enriched\"], tables: [\"none\"] }, x3: { title: \"Session bootstrap\", file: \"engine/factory/EngineSessionFactory.java\", method: \"open(...) \", stage: \"SESSION_BOOTSTRAP\", summary: \"Loads persisted conversation facts.\", session: [\"intent/state/context hydrated\"], tables: [\"ce_conversation (R/W bootstrap)\"] }, x4: { title: \"DAG execution\", file: \"engine/pipeline/EnginePipeline.java\", method: \"execute(...) \", stage: \"STEP_LOOP\", summary: \"Runs step chain with wrappers.\", session: [\"STEP_ENTER/EXIT tracked\"], tables: [\"ce_audit (W)\"] }, x5: { title: \"Pre-step hook\", file: \"engine/hook/EngineStepHook.java\", method: \"beforeStep(...) \", stage: \"STEP_ENTER\", summary: \"Consumer mutates session before target step.\", session: [\"set hints/context/params\"], tables: [\"none\"] }, x6: { title: \"Core step\", file: \"engine/steps/*\", method: \"execute(EngineSession)\", stage: \"STEP_CORE\", summary: \"Intent/state/schema/rules/response handling.\", session: [\"major mutations happen here\"], tables: [\"ce_intent, ce_rule, ce_response, ...\"] }, x7: { title: \"Post-step hook\", file: \"engine/hook/EngineStepHook.java\", method: \"afterStep(...) / onStepError(...) \", stage: \"STEP_EXIT/STEP_ERROR\", summary: \"Consumer gets outcome and can append diagnostics.\", session: [\"read and augment session\"], tables: [\"none\"] }, x8: { title: \"Container transform\", file: \"engine/transformer/ContainerDataTransformer.java\", method: \"transform(...) \", stage: \"CONTAINER_TRANSFORM\", summary: \"Transforms intermediate container payload.\", session: [\"container rewritten\"], tables: [\"none\"] }, x9: { title: \"Response resolve\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Selects EXACT/DERIVED mapping.\", session: [\"output payload generated\"], tables: [\"ce_response (R), ce_prompt_template (R)\"] }, x10: { title: \"Response transform\", file: \"engine/transformer/ResponseTransformer.java\", method: \"transform(...) \", stage: \"RESPONSE_TRANSFORM\", summary: \"Last-mile normalization/redaction.\", session: [\"final payload rewrite\"], tables: [\"none\"] }, x11: { title: \"Transport\", file: \"transport/sse/* + transport/stomp/*\", method: \"emit/publish\", stage: \"HTTP_RESPONSE or STREAM_EVENT\", summary: \"Returns direct response or emits stream events.\", session: [\"conversationId routing key\"], tables: [\"none\"] }, }; # Developer Guide This page is the full implementation starter for consumers integrating ConvEngine into a Spring Boot service. <EngineDebugFlow title=\"Consumer Extension Map\" subtitle=\"Click each node to inspect extension timing, file, method and expected session state.\" nodes={extNodes} edges={extEdges} detailsById={extDetails} defaultSelectedId=\"x5\" /> ## 1. Start a Spring Boot project <Tabs groupId=\"bootstrap\"> <TabItem value=\"maven\" label=\"pom.xml\" default> <CodeBlockToggle title=\"Maven dependency\" language=\"xml\" packagePath=\"project build\"> { <dependency> <groupId>com.github.salilvnair</groupId> <artifactId>convengine</artifactId> <version>1.0.9</version> </dependency> } </CodeBlockToggle> </TabItem> <TabItem value=\"gradle\" label=\"build.gradle.kts\"> <CodeBlockToggle title=\"Gradle dependency\" language=\"kotlin\" packagePath=\"project build\"> { implementation(\"com.github.salilvnair:convengine:1.0.9\") } </CodeBlockToggle> </TabItem> <TabItem value=\"app\" label=\"Application class\"> <CodeBlockToggle title=\"Enable ConvEngine\" language=\"java\" packagePath=\"com.zapper.demo\" filePath=\"src/main/java/com/acme/demo/DemoApplication.java\"> { @SpringBootApplication @EnableConvEngine(stream = true) public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } } </CodeBlockToggle> </TabItem> </Tabs> ## 2. Required schema (DDL) <CodeBlockToggle title=\"Core tables + indexes\" language=\"sql\" packagePath=\"db\" defaultOpen={true}> { CREATE TABLE ce_config ( config_id int4 NOT NULL, config_type text NOT NULL, config_key text NOT NULL, config_value text NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL, CONSTRAINT ce_config_pkey PRIMARY KEY (config_id) ); CREATE UNIQUE INDEX ux_ce_config_type_key ON ce_config USING btree (config_type, config_key); CREATE TABLE ce_conversation ( conversation_id uuid DEFAULT uuid_generate_v4() NOT NULL, status text NOT NULL, intent_code text NULL, state_code text NOT NULL, context_json jsonb DEFAULT '{}'::jsonb NOT NULL, input_params_json jsonb DEFAULT '{}'::jsonb NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, updated_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_conversation_pkey PRIMARY KEY (conversation_id) ); CREATE INDEX idx_ce_conversation_status ON ce_conversation USING btree (status); CREATE INDEX idx_ce_conversation_updated ON ce_conversation USING btree (updated_at); CREATE TABLE ce_intent ( intent_code text NOT NULL, description text NOT NULL, priority int4 DEFAULT 100 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, display_name text NULL, llm_hint text NULL, CONSTRAINT ce_intent_pkey PRIMARY KEY (intent_code) ); CREATE INDEX ix_ce_intent_enabled_priority ON ce_intent USING btree (enabled, priority, intent_code); CREATE TABLE ce_output_schema ( schema_id bigserial NOT NULL, intent_code text NOT NULL, state_code text NOT NULL, json_schema jsonb NOT NULL, enabled bool DEFAULT true NULL, priority int4 NOT NULL, CONSTRAINT ce_output_schema_pkey PRIMARY KEY (schema_id) ); CREATE INDEX idx_ce_output_schema_lookup ON ce_output_schema USING btree (intent_code, state_code, enabled, priority); CREATE TABLE ce_prompt_template ( template_id bigserial NOT NULL, intent_code text NULL, state_code text NULL, response_type text NOT NULL, system_prompt text NOT NULL, user_prompt text NOT NULL, temperature numeric(3,2) DEFAULT 0.0 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_prompt_template_pkey PRIMARY KEY (template_id) ); CREATE INDEX idx_ce_prompt_template_lookup ON ce_prompt_template USING btree (response_type, intent_code, state_code, enabled); CREATE TABLE ce_response ( response_id bigserial NOT NULL, intent_code text NULL, state_code text NOT NULL, output_format text NOT NULL, response_type text NOT NULL, exact_text text NULL, derivation_hint text NULL, json_schema jsonb NULL, priority int4 DEFAULT 100 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_response_pkey PRIMARY KEY (response_id) ); CREATE INDEX idx_ce_response_intent_state ON ce_response USING btree (intent_code, state_code, enabled, priority); CREATE INDEX idx_ce_response_lookup ON ce_response USING btree (state_code, enabled, priority); CREATE TABLE ce_rule ( rule_id bigserial NOT NULL, phase text DEFAULT 'PIPELINE_RULES' NOT NULL, intent_code text NULL, rule_type text NOT NULL, match_pattern text NOT NULL, action text NOT NULL, action_value text NULL, priority int4 DEFAULT 100 NOT NULL, enabled bool DEFAULT true NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_rule_pkey PRIMARY KEY (rule_id) ); CREATE INDEX idx_ce_rule_priority ON ce_rule USING btree (enabled, phase, priority); CREATE TABLE ce_audit ( audit_id bigserial NOT NULL, conversation_id uuid NOT NULL, stage text NOT NULL, payload_json jsonb NOT NULL, created_at timestamptz DEFAULT now() NOT NULL, CONSTRAINT ce_audit_pkey PRIMARY KEY (audit_id), CONSTRAINT ce_audit_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES ce_conversation(conversation_id) ON DELETE CASCADE ); CREATE INDEX idx_ce_audit_conversation ON ce_audit USING btree (conversation_id, created_at DESC); } </CodeBlockToggle> <Highlight type=\"info\" title=\"Source of truth\"> Run the complete DDL from <FileRef>src/main/resources/sql/ddl.sql</FileRef> in the ConvEngine library. The snippet above is onboarding-focused. </Highlight> ## 3. Minimal DML for FAQ scenario <CodeBlockToggle title=\"FAQ DML example\" language=\"sql\" packagePath=\"db/seed\"> { insert into ce_intent(intent_code, state_code, enabled) values ('FAQ', null, true); insert into ce_intent_classifier(intent_code, pattern, priority, enabled) values ('FAQ', '(?i).*(office|location|address).*', 10, true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('FAQ', null, 'EXACT', 'TEXT', 'Our office is at 123 Tech Park, Silicon Valley.', true); insert into ce_config(config_key, config_value, enabled) values ('RESET_COMMAND', 'RESET_SESSION', true); } </CodeBlockToggle> <DbTable title=\"FAQ seed preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=FAQ\"], [\"ce_intent_classifier\", \"pattern=(?i).*(office|location|address).*\"], [\"ce_response\", \"response_type=EXACT, output_format=TEXT\"], [\"ce_config\", \"RESET_COMMAND=RESET_SESSION\"], ]} /> ## 4. application.yml (full consumer starter) <CodeBlockToggle title=\"application.yml\" language=\"yaml\" packagePath=\"src/main/resources\"> { server: port: 8080 spring: datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd convengine: transport: sse: enabled: true emitter-timeout-ms: 1800000 stomp: enabled: false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE # SIMPLE | RELAY relay-destination-prefixes: [\"/topic\", \"/queue\"] relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL # ALL | STANDARD | ERROR_ONLY | NONE include-stages: [] exclude-stages: [] dispatch: async-enabled: true worker-threads: 2 queue-capacity: 2000 rejection-policy: DROP_OLDEST # CALLER_RUNS | DROP_NEWEST | DROP_OLDEST | ABORT keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 persistence: mode: DEFERRED_BULK # IMMEDIATE | DEFERRED_BULK jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: [\"ENGINE_KNOWN_FAILURE\", \"ENGINE_UNKNOWN_FAILURE\"] final-step-names: [\"PipelineEndGuardStep\"] flush-on-stop-outcome: true } </CodeBlockToggle> ### application.yml tag reference <DbTable title=\"server + datasource\" className=\"ce-config-ref-table\" columns={[\"Tag\", \"What it controls\", \"Expected values\", \"Default/notes\"]} rows={[ [\"server.port\", \"HTTP port for your app\", \"integer\", \"8080 in sample\"], [\"spring.datasource.url\", \"DB connection URL\", \"jdbc URL\", \"Must point to DB with ce_* tables\"], [\"spring.datasource.username\", \"DB username\", \"string\", \"DB user with read/write on ce_*\"], [\"spring.datasource.password\", \"DB password\", \"string\", \"Use secret manager/env var in prod\"], ]} /> <DbTable title=\"convengine.transport.sse\" className=\"ce-config-ref-table\" columns={[\"Tag\", \"What it controls\", \"Expected values\", \"Default/notes\"]} rows={[ [\"convengine.transport.sse.enabled\", \"Enable SSE endpoints/publishers\", \"true | false\", \"Default true\"], [\"convengine.transport.sse.emitter-timeout-ms\", \"SSE emitter timeout\", \"milliseconds\", \"Default 1800000 (30 min)\"], ]} /> <DbTable title=\"convengine.transport.stomp\" className=\"ce-config-ref-table\" columns={[\"Tag\", \"What it controls\", \"Expected values\", \"Default/notes\"]} rows={[ [\"convengine.transport.stomp.enabled\", \"Enable STOMP websocket transport\", \"true | false\", \"Default false\"], [\"convengine.transport.stomp.endpoint\", \"WebSocket handshake endpoint\", \"path\", \"Default /ws-convengine\"], [\"convengine.transport.stomp.app-destination-prefix\", \"Client send prefix\", \"path prefix\", \"Default /app\"], [\"convengine.transport.stomp.topic-prefix\", \"Server publish topic prefix\", \"path prefix\", \"Default /topic\"], [\"convengine.transport.stomp.audit-destination-base\", \"Audit topic base path\", \"path\", \"Default /topic/convengine/audit\"], [\"convengine.transport.stomp.allowed-origin-pattern\", \"CORS origin pattern\", \"origin pattern\", \"Default *\"], [\"convengine.transport.stomp.sock-js\", \"SockJS fallback toggle\", \"true | false\", \"Default true\"], ]} /> <DbTable title=\"convengine.transport.stomp.broker\" className=\"ce-config-ref-table\" columns={[\"Tag\", \"What it controls\", \"Expected values\", \"Default/notes\"]} rows={[ [\"convengine.transport.stomp.broker.mode\", \"Broker mode selection\", \"SIMPLE | RELAY\", \"SIMPLE uses in-memory broker\"], [\"convengine.transport.stomp.broker.relay-destination-prefixes\", \"Relay destinations to enable\", \"list of prefixes\", \"Default [/topic, /queue]\"], [\"convengine.transport.stomp.broker.relay-host\", \"Relay broker host\", \"hostname\", \"Used when mode=RELAY\"], [\"convengine.transport.stomp.broker.relay-port\", \"Relay broker port\", \"integer\", \"Default 61613\"], [\"convengine.transport.stomp.broker.client-login\", \"Client login to relay\", \"string\", \"Optional\"], [\"convengine.transport.stomp.broker.client-passcode\", \"Client passcode to relay\", \"string\", \"Optional\"], [\"convengine.transport.stomp.broker.system-login\", \"System login to relay\", \"string\", \"Optional\"], [\"convengine.transport.stomp.broker.system-passcode\", \"System passcode to relay\", \"string\", \"Optional\"], [\"convengine.transport.stomp.broker.virtual-host\", \"Relay vhost\", \"string\", \"Optional\"], [\"convengine.transport.stomp.broker.system-heartbeat-send-interval-ms\", \"Outbound heartbeat\", \"milliseconds\", \"Default 10000\"], [\"convengine.transport.stomp.broker.system-heartbeat-receive-interval-ms\", \"Inbound heartbeat\", \"milliseconds\", \"Default 10000\"], ]} /> <DbTable title=\"convengine.audit (root)\" className=\"ce-config-ref-table\" columns={[\"Tag\", \"What it controls\", \"Expected values\", \"Default/notes\"]} rows={[ [\"convengine.audit.enabled\", \"Master audit enable switch\", \"true | false\", \"Default true\"], [\"convengine.audit.level\", \"Audit verbosity\", \"ALL | STANDARD | ERROR_ONLY | NONE\", \"STANDARD suppresses STEP_ENTER/STEP_EXIT\"], [\"convengine.audit.include-stages\", \"Allowlist stages\", \"list of stage patterns\", \"Empty = no allowlist filter\"], [\"convengine.audit.exclude-stages\", \"Blocklist stages\", \"list of stage patterns\", \"Applied after include filter\"], ]} /> <DbTable title=\"convengine.audit.dispatch + rate-limit + persistence\" className=\"ce-config-ref-table\" columns={[\"Tag\", \"What it controls\", \"Expected values\", \"Default/notes\"]} rows={[ [\"convengine.audit.dispatch.async-enabled\", \"Async listener dispatch\", \"true | false\", \"Default false unless enabled\"], [\"convengine.audit.dispatch.worker-threads\", \"Async worker count\", \"integer >= 1\", \"Default 2\"], [\"convengine.audit.dispatch.queue-capacity\", \"Dispatch queue size\", \"integer >= 1\", \"Default 2000\"], [\"convengine.audit.dispatch.rejection-policy\", \"Backpressure behavior\", \"CALLER_RUNS | DROP_NEWEST | DROP_OLDEST | ABORT\", \"Default CALLER_RUNS\"], [\"convengine.audit.dispatch.keep-alive-seconds\", \"Thread keep-alive\", \"seconds\", \"Default 60\"], [\"convengine.audit.rate-limit.enabled\", \"Enable per-window throttling\", \"true | false\", \"Default false\"], [\"convengine.audit.rate-limit.max-events\", \"Events allowed per window\", \"integer\", \"Default 200\"], [\"convengine.audit.rate-limit.window-ms\", \"Rate-limit window\", \"milliseconds\", \"Default 1000\"], [\"convengine.audit.rate-limit.per-conversation\", \"Bucket by conversation\", \"true | false\", \"Default true\"], [\"convengine.audit.rate-limit.per-stage\", \"Bucket by stage\", \"true | false\", \"Default true\"], [\"convengine.audit.rate-limit.max-tracked-buckets\", \"Bucket cardinality cap\", \"integer\", \"Default 20000\"], [\"convengine.audit.persistence.mode\", \"DB persistence mode\", \"IMMEDIATE | DEFERRED_BULK\", \"Default IMMEDIATE\"], [\"convengine.audit.persistence.jdbc-batch-size\", \"Batch insert chunk size\", \"integer\", \"Default 200\"], [\"convengine.audit.persistence.max-buffered-events\", \"Deferred buffer cap\", \"integer\", \"Default 5000\"], [\"convengine.audit.persistence.flush-stages\", \"Stages forcing flush\", \"list of stages\", \"Defaults include engine failure stages\"], [\"convengine.audit.persistence.final-step-names\", \"Final steps that flush\", \"list of step names\", \"Default includes PipelineEndGuardStep\"], [\"convengine.audit.persistence.flush-on-stop-outcome\", \"Flush on STOP step outcome\", \"true | false\", \"Default true\"], ]} /> <Highlight type=\"warning\" title=\"Streaming startup rule\"> If <MethodRef>@EnableConvEngine(stream=true)</MethodRef> is set, startup fails when both <MethodRef>convengine.transport.sse.enabled=false</MethodRef> and <MethodRef>convengine.transport.stomp.enabled=false</MethodRef>. </Highlight> ## 5. API entry and session contracts <Tabs groupId=\"api-session\"> <TabItem value=\"api\" label=\"API Entry Point\" default> <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.api.controller\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\"> { @PostMapping(\"/message\") public ConversationResponse message(@RequestBody ConversationRequest request) { EngineContext engineContext = EngineContext .builder() .conversationId(request.getConversationId()) .userText(request.getMessage()) .inputParams(request.getInputParams()) .build(); EngineResult result = engine.process(engineContext); return mapToResponse(result); } } </CodeBlockToggle> </TabItem> <TabItem value=\"session\" label=\"Session API\"> <CodeBlockToggle title=\"EngineSession.java (key methods)\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.session\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/session/EngineSession.java\"> { // state management void setIntent(String intent); void setState(String state); // extras/input params Map<String, Object> getInputParams(); void putInputParam(String key, Object value); // persisted conversation row CeConversation getConversation(); // stop pipeline with final result void setFinalResult(EngineResult result); } </CodeBlockToggle> </TabItem> </Tabs> ## 6. Extension examples <Tabs groupId=\"extensions\"> <TabItem value=\"hooks\" label=\"EngineStepHook\" default> <CodeBlockToggle title=\"Step hook with enum-safe matching\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\"> { @Component public class SchemaHintHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName; } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"consumer_hint\", \"compact\"); } } } </CodeBlockToggle> </TabItem> <TabItem value=\"task\" label=\"SET_TASK Action\"> <CodeBlockToggle title=\"SET_TASK via ce_rule\" language=\"sql\" packagePath=\"consumer DB\"> { INSERT INTO ce_rule (phase, intent_code, rule_type, match_pattern, action, action_value, priority, enabled, description) VALUES ('PIPELINE_RULES', 'REQUEST_TRACKER', 'REGEX', '(?i).*track.*request.*', 'SET_TASK', 'requestTrackerTask:loadStatus', 10, true, 'Invoke consumer task bean'); } </CodeBlockToggle> <CodeBlockToggle title=\"Consumer task bean\" language=\"java\" packagePath=\"com.zapper.convengine.tasks\"> { @Component(\"requestTrackerTask\") public class RequestTrackerTask implements CeRuleTask { public void loadStatus(EngineSession session, CeRule rule) { session.putInputParam(\"requestStatus\", \"IN_REVIEW\"); } } } </CodeBlockToggle> </TabItem> <TabItem value=\"schema-json\" label=\"Getting Extracted Data\"> <CodeBlockToggle title=\"Read schema extracted values\" language=\"java\" packagePath=\"consumer logic\"> { String accountId = (String) session.getInputParams().get(\"accountId\"); } </CodeBlockToggle> </TabItem> <TabItem value=\"transformers\" label=\"Interceptors / Transformers\"> <CodeBlockToggle title=\"Interception chain\" language=\"java\" packagePath=\"com.zapper.convengine.ext\"> { @Component public class MyInterceptor implements ContainerDataInterceptor { @Override public Map<String, Object> intercept(Map<String, Object> inputParams) { inputParams.putIfAbsent(\"channel\", \"web\"); return inputParams; } } @Component public class MyContainerTransformer implements ContainerDataTransformer { @Override public Object transform(Object data, EngineSession session) { return data; } } @Component public class MyResponseTransformer implements ResponseTransformer { @Override public OutputPayload transform(OutputPayload payload, EngineSession session) { return payload; } } } </CodeBlockToggle> </TabItem> </Tabs> ## 7. Persistence, audit and streaming tuning <Highlight type=\"tip\" title=\"Production sequence\"> Start with direct <MethodRef>HTTP</MethodRef> + <MethodRef>IMMEDIATE</MethodRef> audit. Then enable async dispatch and bounded queue. Move to <MethodRef>DEFERRED_BULK</MethodRef> only after validating final-step flush behavior for your trace requirements. </Highlight> <DbTable title=\"High-impact runtime knobs\" columns={[\"Area\", \"Config\", \"Effect\"]} rows={[ [\"Audit dispatch\", \"convengine.audit.dispatch.*\", \"Decouples request latency from listener work\"], [\"Queue/backpressure\", \"convengine.audit.dispatch.queue-capacity + rejection-policy\", \"Bounds memory and defines overflow behavior\"], [\"Audit persistence mode\", \"convengine.audit.persistence.mode\", \"IMMEDIATE or DEFERRED_BULK (JDBC batch flush)\"], [\"Stage filtering\", \"convengine.audit.level + include-stages/exclude-stages\", \"Controls emitted/saved stages\"], [\"Broker relay\", \"convengine.transport.stomp.broker.mode=RELAY\", \"Optional external broker for STOMP scaling\"], [\"Stream hard requirement\", \"@EnableConvEngine(stream=true)\", \"Fails startup if both SSE and STOMP are disabled\"], ]} />",
    "excerpt": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , , , , ]; x1: , x2: , x3: , x4: , x5: , x6: , x7: , x8: , x9: , x10: , x11: , }; De…"
  },
  {
    "id": "deep-dive/examples.mdx",
    "title": "examples",
    "permalink": "/docs/deep-dive/examples",
    "content": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , ]; faq_api: , faq_engine: , faq_pipeline: , faq_intent: , faq_rules: , faq_response: , faq_persist: , }; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , ]; d_intent: , d_schema: , d_lock: , d_ask: , d_turn2: , d_merge: , d_rules: , d_done: , }; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , ]; l_api: , l_intent: , l_schema: , l_rules: , l_resp: , l_persist: , }; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , ]; t_api: , t_intent: , t_rules: , t_task: , t_resp: , t_done: , }; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , ]; r_api: , r_load: , r_reset: , r_audit: , r_resp: , r_done: , }; Real world Examples (Debug Trace) Canonical Runtime Step Set 1 LoadOrCreateConversationStep 2 ResetConversationStep 3 PersistConversationBootstrapStep 4 AuditUserInputStep 5 PolicyEnforcementStep 6 IntentResolutionStep 7 ResetResolvedIntentStep 8 FallbackIntentStateStep 9 AddContainerDataStep 10 McpToolStep 11 SchemaExtractionStep 12 AutoAdvanceStep 13 RulesStep 14 ResponseResolutionStep 15 PersistConversationStep 16 PipelineEndGuardStep These examples zoom into relevant branches; conditional/system steps from the canonical set are omitted in each graph unless they materially affect that scenario. Each example has three tabs: Conversation : chat + execution flow DML Entries : starter rows for ce_intent , ce_prompt_template , ce_output_schema , ce_response Audit Trail : stage by stage ce_audit view Example 1: FAQ Can I move my connection within Zapper? Yes, you can request relocation from the support portal. }', true); insert into ce_output_schema(intent_code, state_code, schema_json, enabled) values ('FAQ', null, ' }}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('FAQ', 'IDLE', 'EXACT', 'TEXT', 'Yes, you can request relocation from the support portal.', true); } , \"responseType\": \"EXACT\", \"outputFormat\": \"TEXT\" } } Example 2: DISCONNECT_ELECTRICITY Disconnect electricity for account 10004567. Please share disconnect date and reason. Date is 2026 03 31, reason moving out. Done, request submitted. }', true); insert into ce_output_schema(intent_code, state_code, schema_json, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', ' ,\"disconnectDate\": ,\"reason\": },\"required\":[\"accountId\",\"disconnectDate\",\"reason\"]}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', 'DERIVED', 'TEXT', null, true); } , \"missingFields\": [\"disconnectDate\", \"reason\"], \"locked\": true } } Example 3: LOG_ANALYSIS Analyze this stack trace and tell root cause. Likely connection pool exhaustion; tune pool and reduce long transactions. ,\"component\": ,\"severity\": }}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('LOG_ANALYSIS', 'ANALYZE', 'DERIVED', 'TEXT', null, true); } Example 4: REQUEST_TRACKER Track request REQ 99123 REQ 99123 is APPROVAL_PENDING since 2026 02 10. }}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('REQUEST_TRACKER', 'LOOKUP', 'DERIVED', 'TEXT', null, true); } Example 5: RESET_SESSION RESET_SESSION Session reset complete. Starting fresh. }', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('RESET_SESSION', 'IDLE', 'EXACT', 'TEXT', 'Session reset complete. Starting fresh.', true); } For extraction customization hook EngineStep.Name.SchemaExtractionStep . For final output normalization use ResponseTransformer .",
    "rawContent": "{ id: \"faq_api\", position: { x: 20, y: 50 }, data: { label: \"ConversationController.message\" } }, { id: \"faq_engine\", position: { x: 280, y: 50 }, data: { label: \"DefaultConversationalEngine.process\" } }, { id: \"faq_pipeline\", position: { x: 540, y: 50 }, data: { label: \"EnginePipeline.execute\" } }, { id: \"faq_intent\", position: { x: 20, y: 220 }, data: { label: \"IntentResolutionStep\" } }, { id: \"faq_rules\", position: { x: 280, y: 220 }, data: { label: \"RulesStep\" } }, { id: \"faq_response\", position: { x: 540, y: 220 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"faq_persist\", position: { x: 800, y: 220 }, data: { label: \"PersistConversationStep\" } }, ]; { id: \"faq_e1\", source: \"faq_api\", target: \"faq_engine\" }, { id: \"faq_e2\", source: \"faq_engine\", target: \"faq_pipeline\" }, { id: \"faq_e3\", source: \"faq_pipeline\", target: \"faq_intent\" }, { id: \"faq_e4\", source: \"faq_intent\", target: \"faq_rules\" }, { id: \"faq_e5\", source: \"faq_rules\", target: \"faq_response\" }, { id: \"faq_e6\", source: \"faq_response\", target: \"faq_persist\" }, ]; faq_api: { title: \"API entry\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Builds EngineContext and calls engine.process.\", session: [\"userText set\", \"inputParams normalized\"], tables: [\"none\"] }, faq_engine: { title: \"Engine entry\", file: \"engine/provider/DefaultConversationalEngine.java\", method: \"process(...)\", stage: \"ENGINE_ENTRY\", summary: \"Opens session and executes pipeline.\", session: [\"session hydrated\"], tables: [\"ce_conversation (R)\"] }, faq_pipeline: { title: \"Step loop\", file: \"engine/pipeline/EnginePipeline.java\", method: \"execute(...)\", stage: \"STEP_ENTER/STEP_EXIT\", summary: \"Runs all steps in DAG order.\", session: [\"timing + audits emitted\"], tables: [\"ce_audit (W)\"] }, faq_intent: { title: \"Intent resolve\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...)\", stage: \"INTENT_RESOLVED\", summary: \"Classifier picks FAQ.\", session: [\"intent=FAQ\"], tables: [\"ce_intent_classifier (R)\", \"ce_intent (R)\"] }, faq_rules: { title: \"Rules pass\", file: \"engine/steps/RulesStep.java\", method: \"execute(...)\", stage: \"RULE_NO_MATCH\", summary: \"No matching action.\", session: [\"state unchanged\"], tables: [\"ce_rule (R)\"] }, faq_response: { title: \"Response resolve\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...)\", stage: \"ASSISTANT_OUTPUT\", summary: \"Returns EXACT response.\", session: [\"payload type TEXT\"], tables: [\"ce_response (R)\"] }, faq_persist: { title: \"Persist\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(...)\", stage: \"CONVERSATION_PERSIST\", summary: \"Writes latest state/result.\", session: [\"conversation synced\"], tables: [\"ce_conversation (W)\"] }, }; { id: \"d_intent\", position: { x: 20, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"d_schema\", position: { x: 280, y: 60 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"d_lock\", position: { x: 540, y: 60 }, data: { label: \"Intent lock (incomplete schema)\" } }, { id: \"d_ask\", position: { x: 800, y: 60 }, data: { label: \"Follow-up response\" } }, { id: \"d_turn2\", position: { x: 20, y: 220 }, data: { label: \"Next turn resume\" } }, { id: \"d_merge\", position: { x: 280, y: 220 }, data: { label: \"Context merge + complete\" } }, { id: \"d_rules\", position: { x: 540, y: 220 }, data: { label: \"RulesStep (SET_STATE/SET_TASK)\" } }, { id: \"d_done\", position: { x: 800, y: 220 }, data: { label: \"Final response + persist\" } }, ]; { id: \"d1\", source: \"d_intent\", target: \"d_schema\" }, { id: \"d2\", source: \"d_schema\", target: \"d_lock\" }, { id: \"d3\", source: \"d_lock\", target: \"d_ask\" }, { id: \"d4\", source: \"d_ask\", target: \"d_turn2\" }, { id: \"d5\", source: \"d_turn2\", target: \"d_merge\" }, { id: \"d6\", source: \"d_merge\", target: \"d_rules\" }, { id: \"d7\", source: \"d_rules\", target: \"d_done\" }, ]; d_intent: { title: \"Intent\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...)\", stage: \"INTENT_RESOLVED\", summary: \"Resolves DISCONNECT_ELECTRICITY.\", session: [\"intent fixed for flow\"], tables: [\"ce_intent (R)\"] }, d_schema: { title: \"Extract schema\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...)\", stage: \"SCHEMA_EVALUATED\", summary: \"Gets accountId, missing required fields remain.\", session: [\"contextJson partial\", \"missing fields tracked\"], tables: [\"ce_output_schema (R)\", \"ce_prompt_template (R)\"] }, d_lock: { title: \"Lock\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"lockIntentWhenIncomplete(...)\", stage: \"SCHEMA_INCOMPLETE\", summary: \"Prevents reclassification next turn.\", session: [\"intent locked\"], tables: [\"ce_audit (W)\"] }, d_ask: { title: \"Follow-up\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...)\", stage: \"ASSISTANT_OUTPUT\", summary: \"Asks user only missing fields.\", session: [\"followups prepared\"], tables: [\"ce_response (R)\"] }, d_turn2: { title: \"Resume\", file: \"engine/steps/LoadOrCreateConversationStep.java\", method: \"execute(...)\", stage: \"SESSION_REHYDRATE\", summary: \"Loads same conversationId state.\", session: [\"prior context loaded\"], tables: [\"ce_conversation (R)\"] }, d_merge: { title: \"Complete\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"mergeExtractedWithContext(...)\", stage: \"SCHEMA_COMPLETE\", summary: \"Merges new values and unlocks intent.\", session: [\"contextJson complete\"], tables: [\"ce_output_schema (R)\"] }, d_rules: { title: \"Actions\", file: \"engine/steps/RulesStep.java\", method: \"execute(...)\", stage: \"RULE_MATCHED\", summary: \"Moves state and task.\", session: [\"state updated\", \"task set\"], tables: [\"ce_rule (R)\"] }, d_done: { title: \"Done\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...)\", stage: \"ASSISTANT_OUTPUT\", summary: \"Final confirmation.\", session: [\"payload final\"], tables: [\"ce_response (R)\", \"ce_conversation (W)\"] }, }; { id: \"l_api\", position: { x: 20, y: 60 }, data: { label: \"API entry\" } }, { id: \"l_intent\", position: { x: 280, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"l_schema\", position: { x: 540, y: 60 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"l_rules\", position: { x: 800, y: 60 }, data: { label: \"RulesStep (GET_SCHEMA_JSON)\" } }, { id: \"l_resp\", position: { x: 280, y: 220 }, data: { label: \"ResponseResolutionStep (DERIVED)\" } }, { id: \"l_persist\", position: { x: 540, y: 220 }, data: { label: \"PersistConversationStep\" } }, ]; { id: \"l1\", source: \"l_api\", target: \"l_intent\" }, { id: \"l2\", source: \"l_intent\", target: \"l_schema\" }, { id: \"l3\", source: \"l_schema\", target: \"l_rules\" }, { id: \"l4\", source: \"l_rules\", target: \"l_resp\" }, { id: \"l5\", source: \"l_resp\", target: \"l_persist\" }, ]; l_api: { title: \"API\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Start turn.\", session: [\"incoming log text\"], tables: [\"none\"] }, l_intent: { title: \"Intent\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...)\", stage: \"INTENT_RESOLVED\", summary: \"LOG_ANALYSIS selected.\", session: [\"intent=LOG_ANALYSIS\"], tables: [\"ce_intent (R)\"] }, l_schema: { title: \"Structured extraction\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...)\", stage: \"SCHEMA_EVALUATED\", summary: \"Extracts errorCode/component/severity from text.\", session: [\"schemaJson built\"], tables: [\"ce_output_schema (R)\"] }, l_rules: { title: \"Schema-aware rule\", file: \"engine/steps/RulesStep.java\", method: \"execute(...)\", stage: \"RULE_MATCHED\", summary: \"Reads extracted schema via GET_SCHEMA_JSON.\", session: [\"state maybe ESCALATE\"], tables: [\"ce_rule (R)\"] }, l_resp: { title: \"Derived answer\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...)\", stage: \"ASSISTANT_OUTPUT\", summary: \"Prompt template creates root-cause summary.\", session: [\"derived payload\"], tables: [\"ce_response (R)\", \"ce_prompt_template (R)\"] }, l_persist: { title: \"Persist\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(...)\", stage: \"CONVERSATION_PERSIST\", summary: \"Stores turn output.\", session: [\"state saved\"], tables: [\"ce_conversation (W)\"] }, }; { id: \"t_api\", position: { x: 20, y: 60 }, data: { label: \"API entry\" } }, { id: \"t_intent\", position: { x: 260, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"t_rules\", position: { x: 500, y: 60 }, data: { label: \"RulesStep (SET_TASK)\" } }, { id: \"t_task\", position: { x: 740, y: 60 }, data: { label: \"Consumer service call\" } }, { id: \"t_resp\", position: { x: 260, y: 220 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"t_done\", position: { x: 500, y: 220 }, data: { label: \"Persist + output\" } }, ]; { id: \"t1\", source: \"t_api\", target: \"t_intent\" }, { id: \"t2\", source: \"t_intent\", target: \"t_rules\" }, { id: \"t3\", source: \"t_rules\", target: \"t_task\" }, { id: \"t4\", source: \"t_task\", target: \"t_resp\" }, { id: \"t5\", source: \"t_resp\", target: \"t_done\" }, ]; t_api: { title: \"API\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Request starts.\", session: [\"request id detected\"], tables: [\"none\"] }, t_intent: { title: \"Intent\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...)\", stage: \"INTENT_RESOLVED\", summary: \"REQUEST_TRACKER resolved.\", session: [\"intent set\"], tables: [\"ce_intent (R)\"] }, t_rules: { title: \"Task assignment\", file: \"engine/steps/RulesStep.java\", method: \"execute(...)\", stage: \"RULE_MATCHED\", summary: \"SET_TASK marks downstream work.\", session: [\"task=TRACK_REQUEST_STATUS\"], tables: [\"ce_rule (R)\"] }, t_task: { title: \"Consumer callback\", file: \"consumer hook/service\", method: \"afterStep(...) or service call\", stage: \"TASK_EXECUTION\", summary: \"Consumer fetches tracker state from own system and injects context.\", session: [\"context.status/context.lastUpdated set\"], tables: [\"consumer DB/API\"] }, t_resp: { title: \"Final response\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...)\", stage: \"ASSISTANT_OUTPUT\", summary: \"Builds tracker response from context.\", session: [\"payload text/json\"], tables: [\"ce_response (R)\"] }, t_done: { title: \"Persist\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(...)\", stage: \"CONVERSATION_PERSIST\", summary: \"Persists turn.\", session: [\"conversation updated\"], tables: [\"ce_conversation (W)\"] }, }; { id: \"r_api\", position: { x: 20, y: 60 }, data: { label: \"API entry\" } }, { id: \"r_load\", position: { x: 260, y: 60 }, data: { label: \"LoadOrCreateConversationStep\" } }, { id: \"r_reset\", position: { x: 500, y: 60 }, data: { label: \"ResetConversationStep\" } }, { id: \"r_audit\", position: { x: 740, y: 60 }, data: { label: \"CONVERSATION_RESET audit\" } }, { id: \"r_resp\", position: { x: 260, y: 220 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"r_done\", position: { x: 500, y: 220 }, data: { label: \"PersistConversationStep\" } }, ]; { id: \"r1\", source: \"r_api\", target: \"r_load\" }, { id: \"r2\", source: \"r_load\", target: \"r_reset\" }, { id: \"r3\", source: \"r_reset\", target: \"r_audit\" }, { id: \"r4\", source: \"r_audit\", target: \"r_resp\" }, { id: \"r5\", source: \"r_resp\", target: \"r_done\" }, ]; r_api: { title: \"API\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Receives reset command.\", session: [\"message contains reset token\"], tables: [\"none\"] }, r_load: { title: \"Load\", file: \"engine/steps/LoadOrCreateConversationStep.java\", method: \"execute(...)\", stage: \"SESSION_REHYDRATE\", summary: \"Loads existing session state.\", session: [\"existing intent/state/context loaded\"], tables: [\"ce_conversation (R)\"] }, r_reset: { title: \"Reset\", file: \"engine/steps/ResetConversationStep.java\", method: \"execute(...)\", stage: \"CONVERSATION_RESET\", summary: \"Clears intent/state/context by configured reset command.\", session: [\"intent/state/context wiped\"], tables: [\"ce_config (R)\", \"ce_conversation (W)\"] }, r_audit: { title: \"Audit\", file: \"audit/DbAuditService.java\", method: \"audit(...)\", stage: \"CONVERSATION_RESET\", summary: \"Writes reset trace.\", session: [\"meta includes conversationId\"], tables: [\"ce_audit (W)\"] }, r_resp: { title: \"Reset response\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...)\", stage: \"ASSISTANT_OUTPUT\", summary: \"Returns fresh-start message.\", session: [\"final payload\"], tables: [\"ce_response (R)\"] }, r_done: { title: \"Persist\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(...)\", stage: \"CONVERSATION_PERSIST\", summary: \"Saves empty baseline state.\", session: [\"new baseline saved\"], tables: [\"ce_conversation (W)\"] }, }; # Real-world Examples (Debug Trace) ## Canonical Runtime Step Set <div className=\"ce-step-badge-list\" role=\"list\" aria-label=\"Canonical runtime step set\"> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">1</span><span className=\"ce-step-badge-label\">LoadOrCreateConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">2</span><span className=\"ce-step-badge-label\">ResetConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">3</span><span className=\"ce-step-badge-label\">PersistConversationBootstrapStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">4</span><span className=\"ce-step-badge-label\">AuditUserInputStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">5</span><span className=\"ce-step-badge-label\">PolicyEnforcementStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">6</span><span className=\"ce-step-badge-label\">IntentResolutionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">7</span><span className=\"ce-step-badge-label\">ResetResolvedIntentStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">8</span><span className=\"ce-step-badge-label\">FallbackIntentStateStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">9</span><span className=\"ce-step-badge-label\">AddContainerDataStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">10</span><span className=\"ce-step-badge-label\">McpToolStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">11</span><span className=\"ce-step-badge-label\">SchemaExtractionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">12</span><span className=\"ce-step-badge-label\">AutoAdvanceStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">13</span><span className=\"ce-step-badge-label\">RulesStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">14</span><span className=\"ce-step-badge-label\">ResponseResolutionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">15</span><span className=\"ce-step-badge-label\">PersistConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">16</span><span className=\"ce-step-badge-label\">PipelineEndGuardStep</span></div> </div> These examples zoom into relevant branches; conditional/system steps from the canonical set are omitted in each graph unless they materially affect that scenario. Each example has three tabs: - Conversation : chat + execution flow - DML Entries : starter rows for ce_intent , ce_prompt_template , ce_output_schema , ce_response - Audit Trail : stage-by-stage ce_audit view ## Example 1: FAQ <Tabs groupId=\"ex-faq-tabs\"> <TabItem value=\"conversation\" label=\"Conversation\" default> <Conversation title=\"FAQ\"> <User>Can I move my connection within Zapper?</User> <Assistant>Yes, you can request relocation from the support portal.</Assistant> </Conversation> <EngineDebugFlow title=\"FAQ flow\" subtitle=\"Classifier-first deterministic path\" nodes={faqNodes} edges={faqEdges} detailsById={faqDetails} defaultSelectedId=\"faq_intent\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"FAQ scenario DML\" language=\"sql\"> { insert into ce_intent(intent_code, enabled) values ('FAQ', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ('FAQ', null, 'TEXT', 'You are a support assistant.', 'Answer FAQ clearly in one paragraph from user text: {{user_input}}', true); insert into ce_output_schema(intent_code, state_code, schema_json, enabled) values ('FAQ', null, '{\"type\":\"object\",\"properties\":{\"question\":{\"type\":\"string\"}}}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('FAQ', 'IDLE', 'EXACT', 'TEXT', 'Yes, you can request relocation from the support portal.', true); } </CodeBlockToggle> <DbTable title=\"FAQ config rows preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=FAQ\"], [\"ce_prompt_template\", \"intent_code=FAQ, state_code=null, response_type=TEXT\"], [\"ce_output_schema\", \"intent_code=FAQ\"], [\"ce_response\", \"response_type=EXACT, output_format=TEXT\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"FAQ ce_audit trail\" columns={[\"Stage\", \"What happened\"]} rows={[ [\"USER_INPUT\", \"Incoming user message stored\"], [\"STEP_ENTER (IntentResolutionStep)\", \"Intent step starts\"], [\"INTENT_RESOLVED\", \"Classifier matched FAQ\"], [\"RULE_NO_MATCH\", \"No rule action\"], [\"ASSISTANT_OUTPUT\", \"Exact FAQ response selected\"], [\"STEP_EXIT (PersistConversationStep)\", \"Conversation persisted\"], ]} /> <CodeBlockToggle title=\"FAQ audit payload sample\" language=\"json\"> { { \"_meta\": { \"stage\": \"ASSISTANT_OUTPUT\", \"conversationId\": \"conv-faq-001\", \"intent\": \"FAQ\", \"state\": \"IDLE\" }, \"responseType\": \"EXACT\", \"outputFormat\": \"TEXT\" } } </CodeBlockToggle> </TabItem> </Tabs> ## Example 2: DISCONNECT_ELECTRICITY <Tabs groupId=\"ex-disconnect-tabs\"> <TabItem value=\"conversation\" label=\"Conversation\" default> <Conversation title=\"DISCONNECT_ELECTRICITY\"> <User>Disconnect electricity for account 10004567.</User> <Assistant>Please share disconnect date and reason.</Assistant> <User>Date is 2026-03-31, reason moving out.</User> <Assistant>Done, request submitted.</Assistant> </Conversation> <EngineDebugFlow title=\"Disconnect flow\" subtitle=\"Multi-turn schema completion and intent lock/unlock\" nodes={disconnectNodes} edges={disconnectEdges} detailsById={disconnectDetails} defaultSelectedId=\"d_schema\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"DISCONNECT_ELECTRICITY scenario DML\" language=\"sql\"> { insert into ce_intent(intent_code, enabled) values ('DISCONNECT_ELECTRICITY', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', 'TEXT', 'Collect missing disconnect fields.', 'If required fields are missing, ask only for missing values. User: {{user_input}}', true); insert into ce_output_schema(intent_code, state_code, schema_json, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', '{\"type\":\"object\",\"properties\":{\"accountId\":{\"type\":\"string\"},\"disconnectDate\":{\"type\":\"string\"},\"reason\":{\"type\":\"string\"}},\"required\":[\"accountId\",\"disconnectDate\",\"reason\"]}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', 'DERIVED', 'TEXT', null, true); } </CodeBlockToggle> <DbTable title=\"DISCONNECT_ELECTRICITY config rows preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=DISCONNECT_ELECTRICITY\"], [\"ce_prompt_template\", \"intent_code=DISCONNECT_ELECTRICITY, state_code=COLLECT_REQUIRED\"], [\"ce_output_schema\", \"required=accountId,disconnectDate,reason\"], [\"ce_response\", \"response_type=DERIVED\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"DISCONNECT_ELECTRICITY ce_audit trail\" columns={[\"Stage\", \"What happened\"]} rows={[ [\"INTENT_RESOLVED\", \"Intent set to DISCONNECT_ELECTRICITY\"], [\"SCHEMA_EVALUATED\", \"accountId extracted, fields missing\"], [\"SCHEMA_INCOMPLETE\", \"Intent lock enabled\"], [\"ASSISTANT_OUTPUT\", \"Follow-up question asked\"], [\"SCHEMA_COMPLETE\", \"All required fields merged\"], [\"RULE_MATCHED\", \"SET_STATE/SET_TASK applied\"], [\"ASSISTANT_OUTPUT\", \"Final confirmation response\"], ]} /> <CodeBlockToggle title=\"Schema incomplete audit payload sample\" language=\"json\"> { { \"_meta\": { \"stage\": \"SCHEMA_INCOMPLETE\", \"conversationId\": \"conv-disconnect-001\", \"intent\": \"DISCONNECT_ELECTRICITY\" }, \"missingFields\": [\"disconnectDate\", \"reason\"], \"locked\": true } } </CodeBlockToggle> </TabItem> </Tabs> ## Example 3: LOG_ANALYSIS <Tabs groupId=\"ex-log-tabs\"> <TabItem value=\"conversation\" label=\"Conversation\" default> <Conversation title=\"LOG_ANALYSIS\"> <User>Analyze this stack trace and tell root cause.</User> <Assistant>Likely connection pool exhaustion; tune pool and reduce long transactions.</Assistant> </Conversation> <EngineDebugFlow title=\"Log analysis flow\" subtitle=\"Schema extraction + GET_SCHEMA_JSON rule + derived response\" nodes={logNodes} edges={logEdges} detailsById={logDetails} defaultSelectedId=\"l_schema\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"LOG_ANALYSIS scenario DML\" language=\"sql\"> { insert into ce_intent(intent_code, enabled) values ('LOG_ANALYSIS', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ('LOG_ANALYSIS', 'ANALYZE', 'TEXT', 'Generate root-cause analysis from extracted fields.', 'Use extracted severity/component/errorCode and explain cause + fix in bullets.', true); insert into ce_output_schema(intent_code, state_code, schema_json, enabled) values ('LOG_ANALYSIS', 'ANALYZE', '{\"type\":\"object\",\"properties\":{\"errorCode\":{\"type\":\"string\"},\"component\":{\"type\":\"string\"},\"severity\":{\"type\":\"string\"}}}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('LOG_ANALYSIS', 'ANALYZE', 'DERIVED', 'TEXT', null, true); } </CodeBlockToggle> <DbTable title=\"LOG_ANALYSIS config rows preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=LOG_ANALYSIS\"], [\"ce_prompt_template\", \"intent_code=LOG_ANALYSIS, state_code=ANALYZE\"], [\"ce_output_schema\", \"properties=errorCode,component,severity\"], [\"ce_response\", \"response_type=DERIVED\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"LOG_ANALYSIS ce_audit trail\" columns={[\"Stage\", \"What happened\"]} rows={[ [\"INTENT_RESOLVED\", \"Intent set to LOG_ANALYSIS\"], [\"SCHEMA_EVALUATED\", \"errorCode/component/severity extracted\"], [\"RULE_MATCHED\", \"GET_SCHEMA_JSON branch triggered\"], [\"ASSISTANT_OUTPUT\", \"Derived explanation generated\"], [\"CONVERSATION_PERSIST\", \"Final payload persisted\"], ]} /> </TabItem> </Tabs> ## Example 4: REQUEST_TRACKER <Tabs groupId=\"ex-tracker-tabs\"> <TabItem value=\"conversation\" label=\"Conversation\" default> <Conversation title=\"REQUEST_TRACKER\"> <User>Track request REQ-99123</User> <Assistant>REQ-99123 is APPROVAL_PENDING since 2026-02-10.</Assistant> </Conversation> <EngineDebugFlow title=\"Tracker flow\" subtitle=\"SET_TASK driven consumer integration path\" nodes={trackerNodes} edges={trackerEdges} detailsById={trackerDetails} defaultSelectedId=\"t_rules\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"REQUEST_TRACKER scenario DML\" language=\"sql\"> { insert into ce_intent(intent_code, enabled) values ('REQUEST_TRACKER', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ('REQUEST_TRACKER', 'LOOKUP', 'TEXT', 'Render request tracker status from context.', 'Respond with requestId, status and lastUpdated.', true); insert into ce_output_schema(intent_code, state_code, schema_json, enabled) values ('REQUEST_TRACKER', 'LOOKUP', '{\"type\":\"object\",\"properties\":{\"requestId\":{\"type\":\"string\"}}}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('REQUEST_TRACKER', 'LOOKUP', 'DERIVED', 'TEXT', null, true); } </CodeBlockToggle> <DbTable title=\"REQUEST_TRACKER config rows preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=REQUEST_TRACKER\"], [\"ce_prompt_template\", \"intent_code=REQUEST_TRACKER, state_code=LOOKUP\"], [\"ce_output_schema\", \"property=requestId\"], [\"ce_response\", \"response_type=DERIVED\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"REQUEST_TRACKER ce_audit trail\" columns={[\"Stage\", \"What happened\"]} rows={[ [\"INTENT_RESOLVED\", \"Intent set to REQUEST_TRACKER\"], [\"RULE_MATCHED\", \"SET_TASK=TRACK_REQUEST_STATUS\"], [\"TASK_EXECUTION\", \"Consumer service injected context\"], [\"ASSISTANT_OUTPUT\", \"Tracker response built\"], [\"CONVERSATION_PERSIST\", \"Payload and state persisted\"], ]} /> </TabItem> </Tabs> ## Example 5: RESET_SESSION <Tabs groupId=\"ex-reset-tabs\"> <TabItem value=\"conversation\" label=\"Conversation\" default> <Conversation title=\"RESET_SESSION\"> <User>RESET_SESSION</User> <Assistant>Session reset complete. Starting fresh.</Assistant> </Conversation> <EngineDebugFlow title=\"Reset flow\" subtitle=\"Config-driven reset command through ResetConversationStep\" nodes={resetNodes} edges={resetEdges} detailsById={resetDetails} defaultSelectedId=\"r_reset\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"RESET_SESSION scenario DML\" language=\"sql\"> { insert into ce_intent(intent_code, enabled) values ('RESET_SESSION', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ('RESET_SESSION', 'IDLE', 'TEXT', 'Confirm reset and ask next request.', 'User issued reset. Confirm reset and ask how to help next.', true); insert into ce_output_schema(intent_code, state_code, schema_json, enabled) values ('RESET_SESSION', 'IDLE', '{\"type\":\"object\",\"properties\":{}}', true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('RESET_SESSION', 'IDLE', 'EXACT', 'TEXT', 'Session reset complete. Starting fresh.', true); } </CodeBlockToggle> <DbTable title=\"RESET_SESSION config rows preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=RESET_SESSION\"], [\"ce_prompt_template\", \"intent_code=RESET_SESSION, state_code=IDLE\"], [\"ce_output_schema\", \"empty schema object\"], [\"ce_response\", \"response_type=EXACT\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"RESET_SESSION ce_audit trail\" columns={[\"Stage\", \"What happened\"]} rows={[ [\"SESSION_REHYDRATE\", \"Existing conversation loaded\"], [\"CONVERSATION_RESET\", \"Intent/state/context wiped\"], [\"STEP_EXIT (ResetConversationStep)\", \"Reset step completed\"], [\"ASSISTANT_OUTPUT\", \"Reset confirmation emitted\"], [\"CONVERSATION_PERSIST\", \"Baseline state saved\"], ]} /> </TabItem> </Tabs> <Highlight type=\"tip\" title=\"Intervention points\"> For extraction customization hook <MethodRef>EngineStep.Name.SchemaExtractionStep</MethodRef>. For final output normalization use <MethodRef>ResponseTransformer</MethodRef>. </Highlight>",
    "excerpt": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , ]; faq_api: , faq_engine: , faq_pipeline: , faq_intent: , faq_rules: , faq_response: , faq_persist: , }; , data: }, , data: }, ,…"
  },
  {
    "id": "deep-dive/failure-gotchas.mdx",
    "title": "failure gotchas",
    "permalink": "/docs/deep-dive/failure-gotchas",
    "content": "Data Correctness Gotchas This page documents where ConvEngine can produce incorrect, stale, or misleading output without necessarily crashing. It also lists framework constraints and a concrete roadmap to make the system safer, easier to operate, and more scalable. High risk improper data scenarios Additional correctness traps Framework limitations (current behavior) Improvement roadmap Phase 1: Correctness hardening (highest priority) Phase 2: Convenience and developer experience Phase 3: Scalability and throughput Confirmed from repository code: state overrides from JSON output, sticky intent skip behavior, rule pass mutation loops, context merge semantics, broad prompt var exposure, no optimistic lock field on conversation entity, and findAll() hot path scans. Inferred (consumer dependent): ingress concurrency controls, infra level ordering guarantees, and custom LlmClient timeout/retry strategy.",
    "rawContent": "# Data Correctness Gotchas This page documents where ConvEngine can produce **incorrect, stale, or misleading output** without necessarily crashing. It also lists framework constraints and a concrete roadmap to make the system safer, easier to operate, and more scalable. ## High-risk improper data scenarios <DbTable title=\"Top correctness failure modes\" columns={[ \"Gotcha\", \"Trigger\", \"Bad output pattern\", \"Fast detection\", \"Practical mitigation\" ]} rows={[ [ \"LLM JSON overrides engine intent/state\", \"Response JSON includes intent or state ; resolver applies those fields directly.\", \"Flow silently jumps to wrong state/intent on next turn.\", \"Compare pre/post state around RESOLVE_RESPONSE_LLM_OUTPUT and final persisted conversation row.\", \"Allowlist transitions, reject unknown states, and gate model-driven state changes behind validator hooks.\" ], [ \"Sticky intent routes new question to old flow\", \" STICKY_INTENT=true + no explicit switch/reset signal.\", \"User asks new intent but gets response from previous intent templates/rules.\", \"Frequent INTENT_RESOLVE_SKIPPED_STICKY_INTENT on semantically new user text.\", \"Force re-resolve on low confidence turns, topic-shift heuristics, and explicit UI switch-intent controls.\" ], [ \"Rule chain side effects create wrong final state\", \"Multiple matching rules mutate intent/state across passes.\", \"Technically valid response, semantically wrong transition path.\", \"Inspect ordered RULE_MATCHED / RULE_APPLIED events by pass and phase.\", \"Constrain rule ownership, cap cross-intent actions, and add collision regression tests for rule priority.\" ], [ \"Context merge preserves stale fields\", \"Schema extraction merges partial JSON into existing context and does not clear incompatible prior fields.\", \"Old values leak into later prompts and responses.\", \"Diff context pre/post schema extraction and check unchanged keys across intent/state changes.\", \"Add per-intent field reset policy and explicit stale-key eviction on transition boundaries.\" ], [ \"Concurrent writes race on same conversation\", \"Parallel requests share same conversationId with no optimistic version check.\", \"Last-write-wins overwrites can produce drifted context/intent/state.\", \"Look for overlapping timestamps and contradictory stage order for one conversation.\", \"Serialize by conversation key at API boundary or add optimistic locking ( @Version ).\" ] ]} /> ## Additional correctness traps <DbTable title=\"Less obvious but important\" columns={[\"Area\", \"What happens\", \"Why it matters\", \"Recommended guardrail\"]} rows={[ [ \"Prompt variable exposure\", \"All inputParams are exposed as prompt vars ( promptTemplateVars path).\", \"Unexpected/sensitive params can influence model behavior or leak into prompts.\", \"Move to explicit allowlist of exposable keys and redact secret-like fields.\" ], [ \"LLM invocation ThreadLocal lifecycle\", \" LlmInvocationContext.set(...) is used in several flows without matching clear in same path.\", \"Pooled-thread reuse can cause wrong attribution/context bleed in custom LlmClient logging.\", \"Wrap set/clear in try/finally in every LLM call site.\" ], [ \"Silent exception swallowing\", \"Several context/container merge failures are ignored to keep pipeline running.\", \"Turn completes with partial enrichment, giving plausible but incorrect output.\", \"Emit warning stages with structured reason and defaulted fields when fallback path is taken.\" ], [ \"History reconstruction quality\", \"Conversation history is reconstructed from audit stages (not canonical turn table).\", \"Missing or filtered audit events can distort LLM context history.\", \"Persist normalized user/assistant turn table and use that as primary history source.\" ], [ \"MCP tool safety assumptions\", \" safe_mode exists on DB tool config but execution path does not enforce separate safe-mode logic.\", \"Risk of over-trusting tool configuration for sensitive data queries.\", \"Enforce explicit read-only policy, SQL allowlist checks, and per-tool security policy validation.\" ] ]} /> ## Framework limitations (current behavior) <DbTable title=\"Design constraints to plan around\" columns={[\"Limitation\", \"Current behavior\", \"Consumer impact\", \"Better direction\"]} rows={[ [ \"No full-turn ACID boundary\", \"Turn state is updated across multiple independent saves/steps.\", \"Partial turn artifacts can persist after mid-pipeline failures.\", \"Introduce transactional turn boundary or compensating state machine.\" ], [ \"No built-in optimistic concurrency for conversation row\", \" ce_conversation entity has no versioned conflict detection.\", \"Racing requests overwrite each other nondeterministically.\", \"Add version column + conflict retry/merge strategy.\" ], [ \"Heavy dynamic config with mixed refresh model\", \"Some configs are read at startup; others queried per turn from DB.\", \"Operational behavior can be hard to reason about after config updates.\", \"Document refresh semantics per config and add explicit reload controls.\" ], [ \"In-memory scan selection paths\", \" findAll().stream() used in response/template/schema selection in hot path.\", \"Larger config tables increase latency and raise variability.\", \"Replace with indexed targeted queries + bounded caches.\" ], [ \"Single-process assumptions for ordering\", \"Conversation ordering and mutation safety are mostly local-process concerns.\", \"Horizontal scale can amplify race and ordering ambiguity.\", \"Adopt distributed per-conversation lock/queue semantics.\" ] ]} /> ## Improvement roadmap ### Phase 1: Correctness hardening (highest priority) <DbTable title=\"Immediate improvements\" columns={[\"Change\", \"Value\", \"Effort\", \"Notes\"]} rows={[ [ \"Add response state-transition validator\", \"Prevents invalid model-driven intent/state jumps.\", \"Low-Medium\", \"Apply before PersistConversationStep ; reject or quarantine invalid transitions.\" ], [ \"Add optimistic locking on ce_conversation \", \"Eliminates silent last-write-wins corruption.\", \"Medium\", \"Introduce version field + retry policy for conflict cases.\" ], [ \"Guarantee LlmInvocationContext.clear() \", \"Prevents cross-request attribution bleed.\", \"Low\", \"Wrap all LLM call sites with try/finally .\" ], [ \"Prompt-var allowlist + redaction\", \"Reduces prompt contamination and secret leakage risk.\", \"Low-Medium\", \"Replace current expose-all behavior with explicit allowlist.\" ], [ \"Emit structured fallback warnings\", \"Makes silent degradations diagnosable.\", \"Low\", \"When a catch-ignore path is hit, emit a dedicated stage with cause metadata.\" ] ]} /> ### Phase 2: Convenience and developer experience <DbTable title=\"Make ConvEngine easier to run\" columns={[\"Enhancement\", \"Why it helps\", \"Suggested shape\"]} rows={[ [ \"Config lint + dry-run validator\", \"Catches broken rules/templates before production impact.\", \"CLI/admin endpoint validating response mappings, rule loops, unresolved template vars, and MCP tool safety.\" ], [ \"State transition map visualization\", \"Helps teams reason about intent/state flows and side effects.\", \"Generate graph from rules + responses + schema transitions with dead-end and collision markers.\" ], [ \"Deterministic replay mode\", \"Simplifies debugging wrong-output incidents.\", \"Replay one conversation against snapshot config and compare expected vs actual transitions.\" ], [ \"Scenario test harness\", \"Moves quality from ad-hoc manual checks to repeatable tests.\", \"YAML/JSON test fixtures for input turn sequences, expected intent/state, payload assertions.\" ] ]} /> ### Phase 3: Scalability and throughput <DbTable title=\"Scale safely\" columns={[\"Scalability upgrade\", \"Benefit\", \"Implementation direction\"]} rows={[ [ \"Targeted repository queries\", \"Cuts CPU and DB transfer overhead in hot path.\", \"Replace findAll().stream() with indexed query methods for intent/state/priority.\" ], [ \"Hot config cache with version invalidation\", \"Stabilizes latency under high QPS.\", \"Cache rules/templates/schemas per intent-state; invalidate on config change event.\" ], [ \"Per-conversation serialized execution\", \"Removes race conditions while scaling horizontally.\", \"Route by conversation key to queue/partition; process one active turn per key.\" ], [ \"Async/parallelizable non-critical enrichments\", \"Reduces end-to-end response time.\", \"Move optional container/MCP enrichments off critical path with explicit timeout budget.\" ], [ \"Canonical turn store\", \"Improves history quality and replay reliability.\", \"Persist normalized user/assistant turns instead of reconstructing from audit stream.\" ] ]} /> <Highlight type=\"info\" title=\"Confirmed vs inferred\"> Confirmed from repository code: state overrides from JSON output, sticky-intent skip behavior, rule pass mutation loops, context merge semantics, broad prompt-var exposure, no optimistic lock field on conversation entity, and findAll() hot-path scans. Inferred (consumer-dependent): ingress concurrency controls, infra-level ordering guarantees, and custom LlmClient timeout/retry strategy. </Highlight>",
    "excerpt": "Data Correctness Gotchas This page documents where ConvEngine can produce incorrect, stale, or misleading output without necessarily crashing. It also lists framework constraints and a concrete roadmap to make the system…"
  },
  {
    "id": "deep-dive/file-map.mdx",
    "title": "file map",
    "permalink": "/docs/deep-dive/file-map",
    "content": "File Map (by responsibility)",
    "rawContent": "# File Map (by responsibility) <DbTable title=\"API\" columns={[\"Class\", \"Path\", \"Responsibility\"]} rows={[ [\"ConversationController\", \"api/controller/ConversationController.java\", \"Main request/audit endpoints\"], [\"ExperimentalController\", \"api/controller/ExperimentalController.java\", \"Experimental SQL generation endpoint\"], [\"ConversationRequest/Response\", \"api/dto/*\", \"REST contracts\"], ]} /> <DbTable title=\"Engine Core\" columns={[\"Class\", \"Path\", \"Responsibility\"]} rows={[ [\"DefaultConversationalEngine\", \"engine/provider/DefaultConversationalEngine.java\", \"Entry point to pipeline\"], [\"EnginePipelineFactory\", \"engine/factory/EnginePipelineFactory.java\", \"Step DAG ordering + wrappers\"], [\"EnginePipeline\", \"engine/pipeline/EnginePipeline.java\", \"Step loop execution\"], [\"EngineSession\", \"engine/session/EngineSession.java\", \"Mutable turn state\"], ]} /> <DbTable title=\"Intent + Schema\" columns={[\"Class\", \"Path\", \"Responsibility\"]} rows={[ [\"CompositeIntentResolver\", \"intent/CompositeIntentResolver.java\", \"Classifier + agent arbitration\"], [\"AgentIntentResolver\", \"intent/AgentIntentResolver.java\", \"LLM-based intent scoring\"], [\"SchemaExtractionStep\", \"engine/steps/SchemaExtractionStep.java\", \"Structured extraction + lock handling\"], ]} /> <DbTable title=\"Rules + Response\" columns={[\"Class\", \"Path\", \"Responsibility\"]} rows={[ [\"RulesStep\", \"engine/steps/RulesStep.java\", \"Rule passes + action dispatch\"], [\"ResponseResolutionStep\", \"engine/steps/ResponseResolutionStep.java\", \"ce_response selection + payload build\"], [\"TextOutputFormatResolver\", \"engine/response/format/provider/TextOutputFormatResolver.java\", \"Derived text generation\"], [\"JsonOutputFormatResolver\", \"engine/response/format/provider/JsonOutputFormatResolver.java\", \"Derived json generation\"], ]} /> <DbTable title=\"MCP + Audit\" columns={[\"Class\", \"Path\", \"Responsibility\"]} rows={[ [\"McpToolStep\", \"engine/steps/McpToolStep.java\", \"Planner-tool loop\"], [\"McpPlanner\", \"engine/mcp/McpPlanner.java\", \"LLM decision CALL_TOOL/ANSWER\"], [\"DbAuditService\", \"audit/DbAuditService.java\", \"Audit persistence + metadata\"], [\"AuditTraceService\", \"audit/AuditTraceService.java\", \"Step timeline projection\"], ]} />",
    "excerpt": "File Map (by responsibility)"
  },
  {
    "id": "deep-dive/improvement-backlog.mdx",
    "title": "improvement backlog",
    "permalink": "/docs/deep-dive/improvement-backlog",
    "content": "Improvement Backlog This page turns the correctness and scalability recommendations into implementation ready work items. Use it as the execution plan after reading Data Correctness Gotchas . Phase 1: Correctness critical tickets Phase 2: Operability and convenience tickets Phase 3: Scalability tickets 90% in steady state without stale config incidents.\", \"M L\" ], [ \"CE 012: Per conversation execution serialization\", \"Concurrent turns create races as scale increases.\", \"Route requests by conversation key to single active worker/partition.\", \"No race induced state drift in concurrency stress tests.\", \"L\" ], [ \"CE 013: Canonical turn store\", \"History reconstructed from audit can be incomplete/noisy.\", \"Persist normalized user/assistant turns and switch history provider to it.\", \"History quality checks pass even when audit levels change.\", \"M L\" ], [ \"CE 014: Bounded enrichment budgets\", \"Optional enrichments can inflate synchronous latency.\", \"Apply strict timeout budget for container/MCP enrichments and degrade gracefully.\", \"SLO maintained under downstream slowdown with deterministic fallback behavior.\", \"M\" ] ]} / Recommended rollout order 1. CE 003 and CE 001 first (cheap/high impact correctness guards). 2. CE 002 before any high concurrency scale work. 3. CE 004 and CE 005 before prompt/template expansion. 4. CE 006 + CE 008 to stop regressions while refactoring. 5. CE 010 and CE 011 to stabilize throughput. 6. CE 012 for horizontal scale and race elimination. 7. CE 013 and CE 014 for long term quality and latency control. Done criteria for the program Treat each ticket as a tracked ADR backed change. For every ticket: define owner, rollout guardrails, migration/rollback plan, and evidence artifact (test report or benchmark).",
    "rawContent": "# Improvement Backlog This page turns the correctness and scalability recommendations into implementation-ready work items. Use it as the execution plan after reading Data Correctness Gotchas . ## Phase 1: Correctness-critical tickets <DbTable title=\"P0/P1 backlog\" columns={[\"Ticket\", \"Problem\", \"Implementation\", \"Acceptance criteria\", \"Effort\"]} rows={[ [ \"CE-001: State transition guard\", \"Model output can force invalid intent/state jumps.\", \"Add transition validator before final persistence; block or quarantine disallowed transitions.\", \"Invalid transitions never persist; blocked transitions produce explicit error stage and fallback response.\", \"M\" ], [ \"CE-002: Conversation optimistic locking\", \"Concurrent same-conversation writes produce last-write-wins corruption.\", \"Add version column and optimistic lock handling on conversation updates.\", \"Conflicting parallel updates produce deterministic conflict behavior (retry or fail with known code).\", \"M\" ], [ \"CE-003: LLM context lifecycle safety\", \"ThreadLocal LLM context can leak across pooled threads if not cleared.\", \"Wrap every LlmInvocationContext.set(...) in try/finally + clear() .\", \"No stale context observed under stress test with mixed conversation IDs.\", \"S\" ], [ \"CE-004: Prompt variable allowlist\", \"All input params are currently exposable to prompt rendering.\", \"Introduce allowlist + redaction for sensitive/unexpected keys.\", \"Only approved prompt keys appear in rendered prompt payloads.\", \"M\" ], [ \"CE-005: Stale context eviction rules\", \"Partial schema merges can keep incompatible old fields.\", \"Add per-intent/state field-retention policy and evict on transitions.\", \"Transition tests show old incompatible fields are removed deterministically.\", \"M\" ] ]} /> ## Phase 2: Operability and convenience tickets <DbTable title=\"Developer and operator UX\" columns={[\"Ticket\", \"Problem\", \"Implementation\", \"Acceptance criteria\", \"Effort\"]} rows={[ [ \"CE-006: Config lint and dry-run\", \"Broken rules/prompts are discovered too late.\", \"Add validator command/endpoint for response mapping coverage, unresolved vars, rule loops, MCP safety checks.\", \"Invalid config sets fail lint in CI and are blocked from promotion.\", \"M\" ], [ \"CE-007: Deterministic replay tool\", \"Wrong-output incidents are hard to reproduce.\", \"Replay conversation turns against frozen config snapshot and compare expected vs actual transitions.\", \"At least one production incident can be replayed locally with identical state progression.\", \"M-L\" ], [ \"CE-008: Scenario test harness\", \"Manual QA misses edge-path regressions.\", \"Add fixture-driven conversation tests (turn sequence + expected intent/state/output assertions).\", \"Regression suite catches known sticky-intent, rule-collision, and reset-flow bugs.\", \"M\" ], [ \"CE-009: Transition map generator\", \"State machine behavior is opaque to integrators.\", \"Generate graph from rules/responses/schema transitions with dead-end warnings.\", \"Docs include generated transition map and dead-end detection report.\", \"S-M\" ] ]} /> ## Phase 3: Scalability tickets <DbTable title=\"Throughput and horizontal scale\" columns={[\"Ticket\", \"Problem\", \"Implementation\", \"Acceptance criteria\", \"Effort\"]} rows={[ [ \"CE-010: Hot-path query refactor\", \" findAll().stream() in request path degrades with config size.\", \"Replace with indexed query methods for response/template/schema selection.\", \"P95 latency remains stable when control-plane rows scale 10x.\", \"M\" ], [ \"CE-011: Config cache with version invalidation\", \"Repeated config reads increase latency variability.\", \"Add cache per intent/state with invalidation on config mutation.\", \"Cache hit ratio > 90% in steady state without stale-config incidents.\", \"M-L\" ], [ \"CE-012: Per-conversation execution serialization\", \"Concurrent turns create races as scale increases.\", \"Route requests by conversation key to single active worker/partition.\", \"No race-induced state drift in concurrency stress tests.\", \"L\" ], [ \"CE-013: Canonical turn store\", \"History reconstructed from audit can be incomplete/noisy.\", \"Persist normalized user/assistant turns and switch history provider to it.\", \"History quality checks pass even when audit levels change.\", \"M-L\" ], [ \"CE-014: Bounded enrichment budgets\", \"Optional enrichments can inflate synchronous latency.\", \"Apply strict timeout budget for container/MCP enrichments and degrade gracefully.\", \"SLO maintained under downstream slowdown with deterministic fallback behavior.\", \"M\" ] ]} /> ## Recommended rollout order 1. CE-003 and CE-001 first (cheap/high impact correctness guards). 2. CE-002 before any high-concurrency scale work. 3. CE-004 and CE-005 before prompt/template expansion. 4. CE-006 + CE-008 to stop regressions while refactoring. 5. CE-010 and CE-011 to stabilize throughput. 6. CE-012 for horizontal scale and race elimination. 7. CE-013 and CE-014 for long-term quality and latency control. ## Done criteria for the program <DbTable title=\"Exit gates\" columns={[\"Gate\", \"Target\"]} rows={[ [\"Correctness\", \"No illegal transition persistence in test suite + canary runtime.\"], [\"Concurrency\", \"No race-induced state drift under parallel same-conversation load tests.\"], [\"Security\", \"Prompt exposure allowlist and MCP safety policy enforcement enabled by default.\"], [\"Scalability\", \"Stable p95/p99 under 10x config growth and peak expected QPS.\"], [\"Operability\", \"Config lint, replay, and scenario tests integrated into release workflow.\"] ]} /> <Highlight type=\"success\" title=\"How to use this backlog\"> Treat each ticket as a tracked ADR-backed change. For every ticket: define owner, rollout guardrails, migration/rollback plan, and evidence artifact (test report or benchmark). </Highlight>",
    "excerpt": "Improvement Backlog This page turns the correctness and scalability recommendations into implementation ready work items. Use it as the execution plan after reading Data Correctness Gotchas . Phase 1: Correctness critica…"
  },
  {
    "id": "deep-dive/index.mdx",
    "title": "index",
    "permalink": "/docs/deep-dive",
    "content": "Overview This is the file level wiki for how request control actually moves through ConvEngine. Read this section when you need to debug why a turn changed state unexpectedly a template variable was unresolved MCP produced wrong tool call intent switched during schema collection response mapping selection looks wrong Recommended read order 1. 2. 3. 4. 5. 6. 7. 8. Keep one real conversationId open in /audit/ while reading this section. Follow each stage and compare with the file level explanation.",
    "rawContent": "# Overview This is the file-level wiki for how request control actually moves through ConvEngine. ## Read this section when - you need to debug why a turn changed state unexpectedly - a template variable was unresolved - MCP produced wrong tool call - intent switched during schema collection - response mapping selection looks wrong ## Recommended read order 1. [File Map](/docs/deep-dive/file-map) 2. [Request Lifecycle](/docs/deep-dive/request-lifecycle) 3. [Pipeline Steps](/docs/deep-dive/pipeline-steps) 4. [Intent & Schema](/docs/deep-dive/intent-and-schema) 5. [Rules & Responses](/docs/deep-dive/rules-responses) 6. [MCP & Audit](/docs/deep-dive/mcp-audit) 7. [Data Correctness Gotchas](/docs/deep-dive/failure-gotchas) 8. [Improvement Backlog](/docs/deep-dive/improvement-backlog) <Highlight type=\"info\" title=\"How to use this section\"> Keep one real conversationId open in /audit/{id} while reading this section. Follow each stage and compare with the file-level explanation. </Highlight>",
    "excerpt": "Overview This is the file level wiki for how request control actually moves through ConvEngine. Read this section when you need to debug why a turn changed state unexpectedly a template variable was unresolved MCP produc…"
  },
  {
    "id": "deep-dive/intent-and-schema.mdx",
    "title": "intent and schema",
    "permalink": "/docs/deep-dive/intent-and-schema",
    "content": "Intent Resolution and Schema Collection Intent resolution sources 1. Deterministic classifier rules ( ce_intent_classifier ) 2. Agent scoring path ( AgentIntentResolver ) using ce_config prompts 3. Composite arbitration in CompositeIntentResolver ce_config keys that shape intent behavior ce_prompt_template for schema extraction SchemaExtractionStep resolves template by: response_type = SCHEMA_JSON intent_code state_code (or fallback) } Context: } Schema: } Conversation History: } } Intent lock behavior When schema is incomplete: session.intentLocked = true IntentResolutionStep skips re resolving to prevent intent drift lock reason is persisted in context ( intent_lock.reason ) When schema becomes complete: lock is released if STICKY_INTENT=true , resolver can still skip and retain existing intent/state explicit switch/reset/force signals still allow re resolution Without lock behavior, multi turn collection flows can jump to a new intent after partial input and break deterministic progression.",
    "rawContent": "# Intent Resolution and Schema Collection ## Intent resolution sources 1. Deterministic classifier rules ( ce_intent_classifier ) 2. Agent scoring path ( AgentIntentResolver ) using ce_config prompts 3. Composite arbitration in CompositeIntentResolver ## ce_config keys that shape intent behavior <DbTable title=\"AgentIntentResolver keys\" columns={[\"config_key\", \"Purpose\", \"Example\"]} rows={[ [\"MIN_CONFIDENCE\", \"Minimum confidence to accept agent intent\", \"0.55\"], [\"COLLISION_GAP_THRESHOLD\", \"Top-score gap threshold for collision\", \"0.10\"], [\"SYSTEM_PROMPT\", \"System behavior contract\", \"JSON-only intent scoring rules\"], [\"USER_PROMPT\", \"User template with context/history/allowed intents\", \"{{context}}, {{allowed_intents}}, {{user_input}}\"], ]} /> <DbTable title=\"IntentResolutionStep keys\" columns={[\"config_key\", \"Purpose\", \"Example\"]} rows={[ [\"STICKY_INTENT\", \"Keep resolved intent/state stable across turns and skip unnecessary re-resolution\", \"true\"], ]} /> ## ce_prompt_template for schema extraction SchemaExtractionStep resolves template by: - response_type = SCHEMA_JSON - intent_code - state_code (or fallback) <CodeBlockToggle title=\"Schema extraction prompt pattern\" language=\"text\" defaultOpen={false} > { System prompt: Extract only valid JSON that conforms to schema. No extra keys. No prose. User prompt: User Input: {{user_input}} Context: {{context}} Schema: {{schema}} Conversation History: {{conversation_history}} } </CodeBlockToggle> ## Intent lock behavior When schema is incomplete: - session.intentLocked = true - IntentResolutionStep skips re-resolving to prevent intent drift - lock reason is persisted in context ( intent_lock.reason ) When schema becomes complete: - lock is released - if STICKY_INTENT=true , resolver can still skip and retain existing intent/state - explicit switch/reset/force signals still allow re-resolution <Highlight type=\"success\" title=\"Why this matters\"> Without lock behavior, multi-turn collection flows can jump to a new intent after partial input and break deterministic progression. </Highlight>",
    "excerpt": "Intent Resolution and Schema Collection Intent resolution sources 1. Deterministic classifier rules ( ce_intent_classifier ) 2. Agent scoring path ( AgentIntentResolver ) using ce_config prompts 3. Composite arbitration …"
  },
  {
    "id": "deep-dive/lifecycle.mdx",
    "title": "lifecycle",
    "permalink": "/docs/deep-dive/lifecycle",
    "content": "Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open /docs/deep dive/request lifecycle . 1. API Entry Point The journey begins when a client sends a POST request to /api/v1/conversation/message . } 2. Engine Processing } 3. The Pipeline (Step by Step) PolicyEnforcementStep , ResetResolvedIntentStep , FallbackIntentStateStep , AddContainerDataStep , and McpToolStep are route conditional and run only when config/session conditions match. Every step above emits an audit event. Use /audit/ /trace and then open /docs/deep dive/request lifecycle for the full interactive step tree and method level trace.",
    "rawContent": "# Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open <FileRef>/docs/deep-dive/request-lifecycle</FileRef>. ## 1. API Entry Point The journey begins when a client sends a POST request to /api/v1/conversation/message . <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.api.controller\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\" > { @PostMapping(\"/message\") public ConversationResponse message(@RequestBody ConversationRequest request) { EngineContext engineContext = EngineContext.builder() .conversationId(request.getConversationId()) .userText(request.getMessage()) .inputParams(request.getInputParams()) .build(); EngineResult result = engine.process(engineContext); return mapToResponse(result); } } </CodeBlockToggle> ## 2. Engine Processing <CodeBlockToggle title=\"DefaultConversationalEngine.process\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" > { @Override public EngineResult process(EngineContext engineContext) { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } } </CodeBlockToggle> ## 3. The Pipeline (Step-by-Step) <PipelineStepList ariaLabel=\"Pipeline step-by-step\" /> <Highlight type=\"info\" title=\"Core path vs conditional steps\"> PolicyEnforcementStep , ResetResolvedIntentStep , FallbackIntentStateStep , AddContainerDataStep , and McpToolStep are route-conditional and run only when config/session conditions match. </Highlight> <Highlight type=\"success\" title=\"Audit Trail\"> Every step above emits an audit event. Use /audit/{id}/trace and then open <FileRef>/docs/deep-dive/request-lifecycle</FileRef> for the full interactive step tree and method-level trace. </Highlight>",
    "excerpt": "Request Lifecycle This page is the quick lifecycle view. For the full interactive debug tree, open /docs/deep dive/request lifecycle . 1. API Entry Point The journey begins when a client sends a POST request to /api/v1/c…"
  },
  {
    "id": "deep-dive/mcp-audit.mdx",
    "title": "mcp audit",
    "permalink": "/docs/deep-dive/mcp-audit",
    "content": "MCP and Audit Internals MCP flow McpToolStep does: 1. skip on pending clarification 2. list enabled tools 3. clear stale context_json.mcp branch 4. planner loop ( CALL_TOOL or ANSWER ) 5. DB tool execution via McpDbExecutor 6. store observations and final answer in context MCP related tables Audit stream model DbAuditService writes normalized payload with _meta block, then: applies AuditStageControl (level/include/exclude/rate controls) dispatches listeners through AuditEventDispatcher (sync by default, async optional) Transport outputs: SSE stream ( /api/v1/conversation/stream/ ) optional STOMP topic ( /topic/convengine/audit/ ) STOMP broker mode: simple in memory (default) or relay (RabbitMQ/other STOMP relay) Trace API GET /api/v1/conversation/audit/ /trace Returns: step timeline ordered stage list source class/file metadata When output is wrong, compare raw audit stages with trace step boundaries. This isolates whether issue came from resolver logic, rule mutation, MCP plan, or response mapping.",
    "rawContent": "# MCP and Audit Internals ## MCP flow McpToolStep does: 1. skip on pending clarification 2. list enabled tools 3. clear stale context_json.mcp branch 4. planner loop ( CALL_TOOL or ANSWER ) 5. DB tool execution via McpDbExecutor 6. store observations and final answer in context ## MCP-related tables <DbTable title=\"MCP table usage\" columns={[\"Table\", \"Role\", \"Key fields\"]} rows={[ [\"ce_mcp_tool\", \"Tool registry\", \"tool_code, tool_group, enabled\"], [\"ce_mcp_db_tool\", \"DB tool SQL template config\", \"sql_template, param_schema, max_rows, safe_mode\"], [\"ce_config\", \"Planner prompts\", \"McpPlanner.SYSTEM_PROMPT, McpPlanner.USER_PROMPT\"], ]} /> ## Audit stream model DbAuditService writes normalized payload with _meta block, then: - applies AuditStageControl (level/include/exclude/rate controls) - dispatches listeners through AuditEventDispatcher (sync by default, async optional) Transport outputs: - SSE stream ( /api/v1/conversation/stream/{conversationId} ) - optional STOMP topic ( /topic/convengine/audit/{conversationId} ) - STOMP broker mode: simple in-memory (default) or relay (RabbitMQ/other STOMP relay) ## Trace API GET /api/v1/conversation/audit/{conversationId}/trace Returns: - step timeline - ordered stage list - source class/file metadata <CodeBlockToggle title=\"SSE subscribe example\" language=\"bash\"> { curl -N http://localhost:8080/api/v1/conversation/stream/9bf7540a-b129-4685-a120-730e8a0cb94b } </CodeBlockToggle> <Highlight type=\"success\" title=\"Debug strategy\"> When output is wrong, compare raw audit stages with trace step boundaries. This isolates whether issue came from resolver logic, rule mutation, MCP plan, or response mapping. </Highlight>",
    "excerpt": "MCP and Audit Internals MCP flow McpToolStep does: 1. skip on pending clarification 2. list enabled tools 3. clear stale context_json.mcp branch 4. planner loop ( CALL_TOOL or ANSWER ) 5. DB tool execution via McpDbExecu…"
  },
  {
    "id": "deep-dive/pipeline-steps.mdx",
    "title": "pipeline steps",
    "permalink": "/docs/deep-dive/pipeline-steps",
    "content": "Pipeline Steps (what each step does) :::tip Hook where you need precision Before schema extraction: normalize inputs After rules: inspect intent/state transition correctness Before response resolution: inject display hints ::: Prefer transitions in ce_rule unless absolutely framework level behavior is required. This keeps domain behavior data driven and testable via audit traces.",
    "rawContent": "# Pipeline Steps (what each step does) <DbTable title=\"Step responsibilities\" columns={[\"Step\", \"Primary responsibility\", \"Main session mutations\", \"Config/table dependencies\"]} rows={[ [\"LoadOrCreateConversationStep\", \"Fetch or bootstrap conversation row\", \"conversation, intent/state/context sync\", \"ce_conversation\"], [\"ResetConversationStep\", \"Early explicit reset\", \"intent/state/context/input params reset\", \"input flags, command text\"], [\"PersistConversationBootstrapStep\", \"Ensure conversation row persisted\", \"none/metadata\", \"ce_conversation\"], [\"AuditUserInputStep\", \"Persist user input audit\", \"none\", \"ce_audit\"], [\"PolicyEnforcementStep\", \"Policy block and stop\", \"payload + stop result on block\", \"ce_policy\"], [\"IntentResolutionStep\", \"Resolve intent with classifier+agent\", \"intent/state/clarification fields\", \"ce_intent, ce_intent_classifier, ce_config\"], [\"ResetResolvedIntentStep\", \"Reset on configured reset intent\", \"full reset\", \"ce_config RESET_INTENT_CODES\"], [\"FallbackIntentStateStep\", \"Fill missing intent/state defaults\", \"intent/state\", \"none\"], [\"AddContainerDataStep\", \"Fetch and attach container data\", \"containerData/context merge\", \"ce_container_config\"], [\"McpToolStep\", \"MCP planner/tool loop\", \"context_json.mcp.*\", \"ce_mcp_tool, ce_mcp_db_tool, ce_config\"], [\"SchemaExtractionStep\", \"Schema-driven extraction and lock handling\", \"schema facts/context/lock\", \"ce_output_schema, ce_prompt_template\"], [\"AutoAdvanceStep\", \"Compute schema status facts\", \"schemaComplete/hasAny\", \"resolved schema + context\"], [\"RulesStep\", \"Match and apply transitions/actions\", \"intent/state/input params\", \"ce_rule\"], [\"ResponseResolutionStep\", \"Resolve and generate output payload\", \"payload/last assistant json\", \"ce_response, ce_prompt_template\"], [\"PersistConversationStep\", \"Persist final conversation and result\", \"finalResult\", \"ce_conversation\"], [\"PipelineEndGuardStep\", \"Timing audit + terminal guard\", \"timings\", \"ce_audit\"], ]} /> :::tip Hook where you need precision - Before schema extraction: normalize inputs - After rules: inspect intent/state transition correctness - Before response resolution: inject display hints ::: <Highlight type=\"warning\" title=\"Don’t hardcode transitions in steps\"> Prefer transitions in ce_rule unless absolutely framework-level behavior is required. This keeps domain behavior data-driven and testable via audit traces. </Highlight>",
    "excerpt": "Pipeline Steps (what each step does) :::tip Hook where you need precision Before schema extraction: normalize inputs After rules: inspect intent/state transition correctness Before response resolution: inject display hin…"
  },
  {
    "id": "deep-dive/request-lifecycle.mdx",
    "title": "request lifecycle",
    "permalink": "/docs/deep-dive/request-lifecycle",
    "content": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , , , , , , , , ]; api: , engine: , session: , pipeline: , s1: , s2: , s3: , s4: , s5: , s6: , s7: , s8: , s9: , s10: , out: , }; Request Lifecycle (IDE Debug Mode) This page is the runtime control flow view for one turn. Think of it as stepping through breakpoints from API entry to final persistence. Canonical step inventory (latest) The visual flow highlights the common deterministic runtime path. Conditional/system steps from the list above still execute when their prerequisites are met. Engine\" default // orderByDag uses @MustRunAfter, @MustRunBefore, @RequiresConversationPersisted // wrapWithTiming adds STEP_ENTER / STEP_EXIT / STEP_ERROR audits + hook callbacks } } return session.getFinalResult(); } default void beforeStep(EngineStep.Name stepName, EngineSession session) default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) } } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) } } Table Touch Matrix Start at IntentResolutionStep , then click SchemaExtractionStep and RulesStep in the tree. That path explains most multi turn behavior differences.",
    "rawContent": "{ id: \"api\", position: { x: 20, y: 40 }, data: { label: \"API: ConversationController.message\" } }, { id: \"engine\", position: { x: 300, y: 40 }, data: { label: \"DefaultConversationalEngine.process\" } }, { id: \"session\", position: { x: 580, y: 40 }, data: { label: \"EngineSessionFactory.open\" } }, { id: \"pipeline\", position: { x: 860, y: 40 }, data: { label: \"EnginePipelineFactory.create\" } }, { id: \"s1\", position: { x: 20, y: 190 }, data: { label: \"LoadOrCreateConversationStep\" } }, { id: \"s2\", position: { x: 260, y: 190 }, data: { label: \"ResetConversationStep\" } }, { id: \"s3\", position: { x: 500, y: 190 }, data: { label: \"AuditUserInputStep\" } }, { id: \"s4\", position: { x: 740, y: 190 }, data: { label: \"IntentResolutionStep\" } }, { id: \"s5\", position: { x: 980, y: 190 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"s6\", position: { x: 20, y: 340 }, data: { label: \"AutoAdvanceStep\" } }, { id: \"s7\", position: { x: 260, y: 340 }, data: { label: \"RulesStep\" } }, { id: \"s8\", position: { x: 500, y: 340 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"s9\", position: { x: 740, y: 340 }, data: { label: \"PersistConversationStep\" } }, { id: \"s10\", position: { x: 980, y: 340 }, data: { label: \"PipelineEndGuardStep\" } }, { id: \"out\", position: { x: 500, y: 500 }, data: { label: \"EngineResult -> HTTP Response\" } }, ]; { id: \"e1\", source: \"api\", target: \"engine\" }, { id: \"e2\", source: \"engine\", target: \"session\" }, { id: \"e3\", source: \"session\", target: \"pipeline\" }, { id: \"e4\", source: \"pipeline\", target: \"s1\" }, { id: \"e5\", source: \"s1\", target: \"s2\" }, { id: \"e6\", source: \"s2\", target: \"s3\" }, { id: \"e7\", source: \"s3\", target: \"s4\" }, { id: \"e8\", source: \"s4\", target: \"s5\" }, { id: \"e9\", source: \"s5\", target: \"s6\" }, { id: \"e10\", source: \"s6\", target: \"s7\" }, { id: \"e11\", source: \"s7\", target: \"s8\" }, { id: \"e12\", source: \"s8\", target: \"s9\" }, { id: \"e13\", source: \"s9\", target: \"s10\" }, { id: \"e14\", source: \"s10\", target: \"out\" }, ]; api: { title: \"ConversationController.message\", file: \"api/controller/ConversationController.java\", method: \"message(...)\", stage: \"HTTP_ENTRY\", summary: \"Reads request body, normalizes inputParams, injects reset flag when needed, builds EngineContext and delegates to engine.process.\", session: [\"conversationId maybe provided or generated\", \"userText from request.message\", \"inputParams merged\"], tables: [\"none\"], }, engine: { title: \"DefaultConversationalEngine.process\", file: \"engine/provider/DefaultConversationalEngine.java\", method: \"process(EngineContext)\", stage: \"ENGINE_ENTRY\", summary: \"Opens EngineSession, loads conversation history provider data, executes pipeline, returns EngineResult.\", session: [\"session created\", \"conversationHistory injected\"], tables: [\"ce_audit (indirect via steps)\", \"ce_conversation (indirect via steps)\"], }, session: { title: \"EngineSessionFactory.open\", file: \"engine/factory/EngineSessionFactory.java\", method: \"open(EngineContext)\", stage: \"SESSION_BOOTSTRAP\", summary: \"Ensures conversation bootstrap row exists, attaches it into session, syncs state/intent/context/input params.\", session: [\"conversation object attached\", \"intent/state/context synced from DB\"], tables: [\"ce_conversation (R/W bootstrap)\"], }, pipeline: { title: \"EnginePipelineFactory.create\", file: \"engine/factory/EnginePipelineFactory.java\", method: \"orderByDag(...) + wrapWithTiming(...)\", stage: \"PIPELINE_BUILD\", summary: \"Resolves step DAG by annotations, wraps each step in timing/audit/hook-aware wrapper.\", session: [\"none (topology build)\"], tables: [\"none\"], }, s1: { title: \"LoadOrCreateConversationStep.execute\", file: \"engine/steps/LoadOrCreateConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Loads/syncs conversation row into session and keeps runtime state consistent.\", session: [\"conversation synchronized\", \"state available for next steps\"], tables: [\"ce_conversation (R/W)\"], }, s2: { title: \"ResetConversationStep.execute\", file: \"engine/steps/ResetConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Checks reset controls ( reset , restart , conversation_reset , command text). If triggered, wipes conversation runtime state.\", session: [\"intent/state/context reset conditionally\", \"input controls filtered\"], tables: [\"ce_conversation (W)\", \"ce_audit (CONVERSATION_RESET)\"], }, s3: { title: \"AuditUserInputStep.execute\", file: \"engine/steps/AuditUserInputStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Writes compact user input audit record with session meta intent/state.\", session: [\"user input captured\"], tables: [\"ce_audit (W)\"], }, s4: { title: \"IntentResolutionStep.execute\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Resolves intent using classifier + agent flow, with schema lock checks and collision handling.\", session: [\"intent maybe changed\", \"state may become INTENT_COLLISION\"], tables: [\"ce_intent (R)\", \"ce_intent_classifier (R)\", \"ce_config (R)\", \"ce_audit (W)\"], }, s5: { title: \"SchemaExtractionStep.execute\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Finds schema by intent/state, renders prompt template, calls LLM JSON extraction, merges context, computes missing fields, locks/unlocks intent.\", session: [\"contextJson merged\", \"schemaComplete/schemaHasAnyValue flags\", \"missing fields/options\"], tables: [\"ce_output_schema (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\", \"ce_config (R optional)\"], }, s6: { title: \"AutoAdvanceStep.execute\", file: \"engine/steps/AutoAdvanceStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Applies deterministic state changes from schema facts before rules run.\", session: [\"state may auto-transition\"], tables: [\"ce_audit (W)\"], }, s7: { title: \"RulesStep.execute\", file: \"engine/steps/RulesStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Runs enabled rules in priority order with multi-pass cascading when intent/state changes.\", session: [\"intent/state/context/inputParams may mutate via actions\"], tables: [\"ce_rule (R)\", \"ce_audit (W)\"], }, s8: { title: \"ResponseResolutionStep.execute\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Selects response mapping, executes EXACT/DERIVED strategy, resolves templates for derived output, applies transformers, audits output.\", session: [\"payload set\", \"finalResult staged\"], tables: [\"ce_response (R)\", \"ce_prompt_template (R)\", \"ce_audit (W)\"], }, s9: { title: \"PersistConversationStep.execute\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Persists final conversation state and last assistant payload to durable row.\", session: [\"conversation row synchronized with runtime\"], tables: [\"ce_conversation (W)\", \"ce_audit (W optional)\"], }, s10: { title: \"PipelineEndGuardStep.execute\", file: \"engine/steps/PipelineEndGuardStep.java\", method: \"execute(EngineSession)\", stage: \"STEP\", summary: \"Final guard/timing stage, emits pipeline timing audit and closes execution envelope.\", session: [\"step timings finalized\"], tables: [\"ce_audit (W)\"], }, out: { title: \"EngineResult return\", file: \"api/controller/ConversationController.java\", method: \"message(...) return\", stage: \"HTTP_RESPONSE\", summary: \"Controller maps EngineResult to API response payload type (TEXT/JSON) and returns to client.\", session: [\"final result exposed\"], tables: [\"none\"], }, }; # Request Lifecycle (IDE Debug Mode) This page is the runtime control-flow view for one turn. Think of it as stepping through breakpoints from API entry to final persistence. ## Canonical step inventory (latest) <PipelineStepList ariaLabel=\"Canonical step inventory\" /> <Highlight type=\"tip\" title=\"Graph below is the common path\"> The visual flow highlights the common deterministic runtime path. Conditional/system steps from the list above still execute when their prerequisites are met. </Highlight> <EngineDebugFlow title=\"Request Turn Execution Graph\" subtitle=\"Click any node in tree or graph to inspect method-level detail, session snapshots, and table touch points.\" nodes={lifecycleNodes} edges={lifecycleEdges} detailsById={lifecycleDetails} defaultSelectedId=\"s4\" /> <Tabs groupId=\"lifecycle-code\"> <TabItem value=\"entry\" label=\"Controller -> Engine\" default> <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.api.controller\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\" > { EngineContext engineContext = EngineContext.builder() .conversationId(conversationId.toString()) .userText(request.getMessage()) .inputParams(inputParams) .build(); EngineResult result = engine.process(engineContext); } </CodeBlockToggle> <CodeBlockToggle title=\"DefaultConversationalEngine.process\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.provider\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\" > { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } </CodeBlockToggle> </TabItem> <TabItem value=\"pipeline\" label=\"DAG + Step Wrapper\"> <CodeBlockToggle title=\"EnginePipelineFactory.orderByDag + wrapWithTiming\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.factory\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/factory/EnginePipelineFactory.java\" > { @PostConstruct public void init() { List<EngineStep> ordered = orderByDag(discoveredSteps); this.pipeline = new EnginePipeline(wrapWithTiming(ordered)); } // orderByDag uses @MustRunAfter, @MustRunBefore, @RequiresConversationPersisted // wrapWithTiming adds STEP_ENTER / STEP_EXIT / STEP_ERROR audits + hook callbacks } </CodeBlockToggle> <CodeBlockToggle title=\"EnginePipeline.execute\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.pipeline\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java\" > { for (EngineStep step : steps) { StepResult r = step.execute(session); if (r instanceof StepResult.Stop(EngineResult result)) { return result; } } return session.getFinalResult(); } </CodeBlockToggle> </TabItem> <TabItem value=\"hooks\" label=\"Step Hook Interception\"> <CodeBlockToggle title=\"EngineStepHook typed step matching\" language=\"java\" packagePath=\"com.github.salilvnair.convengine.engine.hook\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/hook/EngineStepHook.java\" > { public interface EngineStepHook { default boolean supports(EngineStep.Name stepName, EngineSession session) { return true; } default void beforeStep(EngineStep.Name stepName, EngineSession session) {} default void afterStep(EngineStep.Name stepName, EngineSession session, StepResult result) {} default void onStepError(EngineStep.Name stepName, EngineSession session, Throwable error) {} } } </CodeBlockToggle> <CodeBlockToggle title=\"Consumer hook example\" language=\"java\" packagePath=\"com.zapper.convengine.hooks\" > { @Component public class MyHook implements EngineStepHook { @Override public boolean supports(EngineStep.Name stepName, EngineSession session) { return EngineStep.Name.SchemaExtractionStep == stepName; } @Override public void beforeStep(EngineStep.Name stepName, EngineSession session) { session.putInputParam(\"consumer_hint\", \"compact\"); } } } </CodeBlockToggle> </TabItem> </Tabs> ## Table Touch Matrix <DbTable title=\"Per-turn table access\" columns={[\"Table\", \"Read Path\", \"Write Path\"]} rows={[ [\"ce_conversation\", \"LoadOrCreateConversationStep\", \"PersistConversationStep / reset steps\"], [\"ce_intent\", \"IntentResolutionStep\", \"-\"], [\"ce_intent_classifier\", \"IntentResolutionStep\", \"-\"], [\"ce_output_schema\", \"SchemaExtractionStep\", \"-\"], [\"ce_prompt_template\", \"SchemaExtractionStep / ResponseResolutionStep\", \"-\"], [\"ce_rule\", \"RulesStep\", \"-\"], [\"ce_response\", \"ResponseResolutionStep\", \"-\"], [\"ce_config\", \"intent/reset/mcp/sql-agent config lookup\", \"-\"], [\"ce_audit\", \"-\", \"all stage audits via DbAuditService\"], ]} /> <Highlight type=\"info\" title=\"How to read this page\"> Start at IntentResolutionStep , then click SchemaExtractionStep and RulesStep in the tree. That path explains most multi-turn behavior differences. </Highlight>",
    "excerpt": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , , , , , , , , , , ]; api: , engine: , sess…"
  },
  {
    "id": "deep-dive/rules-responses.mdx",
    "title": "rules responses",
    "permalink": "/docs/deep-dive/rules-responses",
    "content": "Rules and Response Resolution Rule types currently implemented Rule actions in detail Response selection algorithm 1. Find enabled ce_response candidates matching intent/state 2. Score by exact state/intent ANY/null fallback priority 3. Choose top candidate 4. Resolve by response type EXACT vs DERIVED EXACT : deterministic payload ( exact_text ) DERIVED : template rendered + LLM generated output :::tip Intervention points Use ResponseTransformer after response resolution to apply consumer specific post processing. Use hook on RulesStep to inspect rule cascades in production debugging. ::: Do not insert unimplemented rule types/actions in DB. Keep ce_rule values aligned with installed resolver classes.",
    "rawContent": "# Rules and Response Resolution ## Rule types currently implemented <DbTable title=\"Rule type resolver coverage\" columns={[\"rule_type\", \"Resolver\", \"When to use\"]} rows={[ [\"EXACT\", \"ExactRuleTypeResolver\", \"Exact text-driven trigger\"], [\"REGEX\", \"RegexRuleTypeResolver\", \"Pattern-driven trigger\"], [\"JSON_PATH\", \"JsonPathRuleTypeResolver\", \"Condition over session/context/payload facts\"], ]} /> ## Rule actions in detail <DbTable title=\"Action behavior\" columns={[\"action\", \"What it changes\", \"Typical real-world use\"]} rows={[ [\"SET_STATE\", \"session.state\", \"Move flow to AWAITING_ACCOUNT_ID\"], [\"SET_INTENT\", \"session.intent\", \"Reclassify after deterministic signal\"], [\"SET_JSON\", \"input param from JSON path extract\", \"Pull ticketId/correlationId from context\"], [\"GET_CONTEXT\", \"input param snapshot of context\", \"Use context in downstream prompts/tasks\"], [\"GET_SESSION\", \"input param snapshot of session facts\", \"Expose runtime flags to prompts\"], [\"GET_SCHEMA_JSON\", \"input param schema-only field subset\", \"Use only extracted form fields\"], [\"SET_TASK\", \"executes custom task bean methods\", \"Raise incident, call internal orchestrator\"] ]} /> ## Response selection algorithm 1. Find enabled ce_response candidates matching intent/state 2. Score by exact state/intent > ANY/null fallback > priority 3. Choose top candidate 4. Resolve by response type ## EXACT vs DERIVED - EXACT : deterministic payload ( exact_text ) - DERIVED : template-rendered + LLM-generated output <CodeBlockToggle title=\"Derived response path (concept)\" language=\"text\"> { ce_response(response_type=DERIVED, output_format=TEXT) -> template from ce_prompt_template(response_type=TEXT) -> render variables -> llm.generateText(...) -> optional ResponseTransformer -> persisted assistant output } </CodeBlockToggle> :::tip Intervention points - Use ResponseTransformer after response resolution to apply consumer-specific post-processing. - Use hook on RulesStep to inspect rule cascades in production debugging. ::: <Highlight type=\"warning\" title=\"Enum drift warning\"> Do not insert unimplemented rule types/actions in DB. Keep ce_rule values aligned with installed resolver classes. </Highlight>",
    "excerpt": "Rules and Response Resolution Rule types currently implemented Rule actions in detail Response selection algorithm 1. Find enabled ce_response candidates matching intent/state 2. Score by exact state/intent ANY/null fall…"
  },
  {
    "id": "examples.mdx",
    "title": "examples",
    "permalink": "/docs/examples",
    "content": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , ]; faq_api: , faq_engine: , faq_intent: , faq_rules: , faq_resp: , faq_persist: , }; , data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , ]; d_intent: , d_schema: , d_followup: , d_turn2: , d_rules: , d_done: , }; , data: }, , data: }, , data: }, , data: }, ]; , , , ]; l_intent: , l_schema: , l_rules: , l_resp: , }; , data: }, , data: }, , data: }, , data: }, ]; , , , ]; t_intent: , t_schema: , t_rules: , t_resp: , }; Examples (ReactFlow + DML + Audit) This page is the practical E2E companion to deep dive. Each example shows: conversation UX runtime flow graph DML seed rows expected audit stages Canonical Runtime Step Set Step loop invokes each execute(session) . If a step returns Stop , response returns immediately; otherwise loop continues. 1 LoadOrCreateConversationStep 2 ResetConversationStep 3 PersistConversationBootstrapStep 4 AuditUserInputStep 5 PolicyEnforcementStep 6 IntentResolutionStep 7 ResetResolvedIntentStep 8 FallbackIntentStateStep 9 AddContainerDataStep 10 McpToolStep 11 SchemaExtractionStep 12 AutoAdvanceStep 13 RulesStep 14 ResponseResolutionStep 15 PersistConversationStep 16 PipelineEndGuardStep Open full step traversal with snippets EngineContext engineContext = EngineContext.builder() .conversationId(conversationId.toString()) .userText(request.getMessage()) .inputParams(inputParams) .build(); EngineResult result = engine.process(engineContext); return mapToResponse(result); } } } } if (session.getFinalResult() == null) return session.getFinalResult(); } } } IntentResolutionTrace trace = resolver.resolveWithTrace(session.getUserText(), session.contextDict()); session.setIntent(trace.getIntent()); session.setState(trace.getState()); audit.audit(\"INTENT_RESOLVED\", session.getConversationId(), Map.of( \"intent\", trace.getIntent(), \"confidence\", trace.getConfidence(), \"source\", trace.getSource() )); return new StepResult.Continue(); } } CeOutputSchema schema = schemaOpt.get(); String prompt = promptRenderer.renderSchemaPrompt(session, schema); String extractedJson = llmClient.generateJson(prompt, schema.getSchemaJson(), session.getContextJsonOrEmpty()); session.mergeContextJson(extractedJson); MissingFieldResult missing = missingFieldEvaluator.evaluate(schema.getSchemaJson(), session.contextDict()); session.setMissingFields(missing.names()); session.setSchemaLocked(!missing.isComplete()); audit.audit(\"SCHEMA_EVALUATED\", session.getConversationId(), Map.of(\"missing\", missing.names())); return new StepResult.Continue(); } } RuleOutcome outcome = actionExecutor.apply(rule, session); changed = changed || outcome.mutatedIntentOrState(); audit.audit(\"RULE_MATCHED\", session.getConversationId(), Map.of(\"ruleId\", rule.getId(), \"action\", rule.getAction())); } } while (changed && pass } } FAQ Can I move my connection within Zapper? Yes. You can request relocation from the support portal. DISCONNECT_ELECTRICITY Disconnect electricity for account 10004567. Please share disconnect date and reason. Date is 2026 03 31, reason moving out. Done. Request submitted. follow up complete finalize\" nodes= edges= detailsById= defaultSelectedId=\"d_schema\" / ,\"disconnectDate\": ,\"reason\": },\"required\":[\"accountId\",\"disconnectDate\",\"reason\"]}', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', 'TEXT', 'Collect missing disconnect fields.', 'Ask only for missing disconnect fields from: }', true); insert into ce_response(intent_code, state_code, response_type, output_format, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', 'DERIVED', 'TEXT', true); } LOG_ANALYSIS Analyze timeout logs and tell root cause. Root cause is DB connection pool saturation from 11:02 to 11:07 UTC. REQUEST_TRACKER Track request REQ 778102. REQ 778102 is IN_REVIEW and assigned to Queue 3. For each example run, inspect both /api/v1/conversation/audit/ '} and /api/v1/conversation/audit/ '}/trace .",
    "rawContent": "{ id: \"faq_api\", position: { x: 20, y: 60 }, data: { label: \"ConversationController.message\" } }, { id: \"faq_engine\", position: { x: 290, y: 60 }, data: { label: \"DefaultConversationalEngine.process\" } }, { id: \"faq_intent\", position: { x: 560, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"faq_rules\", position: { x: 830, y: 60 }, data: { label: \"RulesStep\" } }, { id: \"faq_resp\", position: { x: 290, y: 220 }, data: { label: \"ResponseResolutionStep\" } }, { id: \"faq_persist\", position: { x: 560, y: 220 }, data: { label: \"PersistConversationStep\" } }, ]; { id: \"faq_e1\", source: \"faq_api\", target: \"faq_engine\" }, { id: \"faq_e2\", source: \"faq_engine\", target: \"faq_intent\" }, { id: \"faq_e3\", source: \"faq_intent\", target: \"faq_rules\" }, { id: \"faq_e4\", source: \"faq_rules\", target: \"faq_resp\" }, { id: \"faq_e5\", source: \"faq_resp\", target: \"faq_persist\" }, ]; faq_api: { title: \"API entry\", file: \"api/controller/ConversationController.java\", method: \"message(...) \", stage: \"HTTP_ENTRY\", summary: \"Builds EngineContext and delegates to engine.\", session: [\"message + params normalized\"], tables: [\"none\"] }, faq_engine: { title: \"Engine processing\", file: \"engine/provider/DefaultConversationalEngine.java\", method: \"process(...) \", stage: \"ENGINE_ENTRY\", summary: \"Opens session and executes pipeline.\", session: [\"conversation history attached\"], tables: [\"ce_conversation (R)\"] }, faq_intent: { title: \"Intent resolution\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"Classifier/agent resolve FAQ.\", session: [\"intent=FAQ\"], tables: [\"ce_intent, ce_intent_classifier\"] }, faq_rules: { title: \"Rules evaluation\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_NO_MATCH\", summary: \"No transition, state remains.\", session: [\"state unchanged\"], tables: [\"ce_rule\"] }, faq_resp: { title: \"Response resolution\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Selects EXACT/TEXT response row.\", session: [\"payload ready\"], tables: [\"ce_response\"] }, faq_persist: { title: \"Persist\", file: \"engine/steps/PersistConversationStep.java\", method: \"execute(...) \", stage: \"CONVERSATION_PERSIST\", summary: \"Persists final session snapshot.\", session: [\"context + payload stored\"], tables: [\"ce_conversation (W)\"] }, }; { id: \"d_intent\", position: { x: 20, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"d_schema\", position: { x: 300, y: 60 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"d_followup\", position: { x: 580, y: 60 }, data: { label: \"Follow-up response\" } }, { id: \"d_turn2\", position: { x: 860, y: 60 }, data: { label: \"Turn 2 resume\" } }, { id: \"d_rules\", position: { x: 300, y: 220 }, data: { label: \"RulesStep\" } }, { id: \"d_done\", position: { x: 580, y: 220 }, data: { label: \"Response + Persist\" } }, ]; { id: \"d_e1\", source: \"d_intent\", target: \"d_schema\" }, { id: \"d_e2\", source: \"d_schema\", target: \"d_followup\" }, { id: \"d_e3\", source: \"d_followup\", target: \"d_turn2\" }, { id: \"d_e4\", source: \"d_turn2\", target: \"d_rules\" }, { id: \"d_e5\", source: \"d_rules\", target: \"d_done\" }, ]; d_intent: { title: \"Intent\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"Resolves DISCONNECT_ELECTRICITY.\", session: [\"intent fixed\"], tables: [\"ce_intent\"] }, d_schema: { title: \"Schema extraction\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...) \", stage: \"SCHEMA_INCOMPLETE\", summary: \"Missing fields are detected and intent is locked.\", session: [\"missingFields tracked\"], tables: [\"ce_output_schema, ce_prompt_template\"] }, d_followup: { title: \"Clarification\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Returns follow-up for missing fields.\", session: [\"follow-up payload\"], tables: [\"ce_response\"] }, d_turn2: { title: \"Session continuity\", file: \"engine/steps/LoadOrCreateConversationStep.java\", method: \"execute(...) \", stage: \"SESSION_REHYDRATE\", summary: \"Restores same conversation context.\", session: [\"existing context loaded\"], tables: [\"ce_conversation\"] }, d_rules: { title: \"Transition\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_MATCHED\", summary: \"Applies state transition once schema complete.\", session: [\"state moved\"], tables: [\"ce_rule\"] }, d_done: { title: \"Finalization\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"CONVERSATION_PERSIST\", summary: \"Sends final message and persists.\", session: [\"final payload\"], tables: [\"ce_response, ce_conversation\"] }, }; { id: \"l_intent\", position: { x: 20, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"l_schema\", position: { x: 300, y: 60 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"l_rules\", position: { x: 580, y: 60 }, data: { label: \"RulesStep (GET_SCHEMA_JSON)\" } }, { id: \"l_resp\", position: { x: 860, y: 60 }, data: { label: \"ResponseResolutionStep (DERIVED)\" } }, ]; { id: \"l_e1\", source: \"l_intent\", target: \"l_schema\" }, { id: \"l_e2\", source: \"l_schema\", target: \"l_rules\" }, { id: \"l_e3\", source: \"l_rules\", target: \"l_resp\" }, ]; l_intent: { title: \"Intent\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"LOG_ANALYSIS selected.\", session: [\"intent=LOG_ANALYSIS\"], tables: [\"ce_intent\"] }, l_schema: { title: \"Extracted facts\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...) \", stage: \"SCHEMA_EVALUATED\", summary: \"Extracts structured fields from logs.\", session: [\"schemaJson prepared\"], tables: [\"ce_output_schema\"] }, l_rules: { title: \"Rule action\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_MATCHED\", summary: \"GET_SCHEMA_JSON action reads extracted values.\", session: [\"rule context enriched\"], tables: [\"ce_rule\"] }, l_resp: { title: \"Derived answer\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Prompt template creates RCA summary.\", session: [\"derived response\"], tables: [\"ce_prompt_template, ce_response\"] }, }; { id: \"t_intent\", position: { x: 20, y: 60 }, data: { label: \"IntentResolutionStep\" } }, { id: \"t_schema\", position: { x: 300, y: 60 }, data: { label: \"SchemaExtractionStep\" } }, { id: \"t_rules\", position: { x: 580, y: 60 }, data: { label: \"RulesStep (SET_TASK)\" } }, { id: \"t_resp\", position: { x: 860, y: 60 }, data: { label: \"ResponseResolutionStep\" } }, ]; { id: \"t_e1\", source: \"t_intent\", target: \"t_schema\" }, { id: \"t_e2\", source: \"t_schema\", target: \"t_rules\" }, { id: \"t_e3\", source: \"t_rules\", target: \"t_resp\" }, ]; t_intent: { title: \"Intent\", file: \"engine/steps/IntentResolutionStep.java\", method: \"execute(...) \", stage: \"INTENT_RESOLVED\", summary: \"REQUEST_TRACKER selected.\", session: [\"intent=REQUEST_TRACKER\"], tables: [\"ce_intent\"] }, t_schema: { title: \"Extraction\", file: \"engine/steps/SchemaExtractionStep.java\", method: \"execute(...) \", stage: \"SCHEMA_EVALUATED\", summary: \"Extracts requestId.\", session: [\"requestId available\"], tables: [\"ce_output_schema\"] }, t_rules: { title: \"Task assignment\", file: \"engine/steps/RulesStep.java\", method: \"execute(...) \", stage: \"RULE_MATCHED\", summary: \"SET_TASK marks consumer work.\", session: [\"task set\"], tables: [\"ce_rule\"] }, t_resp: { title: \"Output\", file: \"engine/steps/ResponseResolutionStep.java\", method: \"execute(...) \", stage: \"ASSISTANT_OUTPUT\", summary: \"Builds final status message.\", session: [\"payload finalized\"], tables: [\"ce_response\"] }, }; # Examples (ReactFlow + DML + Audit) This page is the practical E2E companion to deep dive. Each example shows: - conversation UX - runtime flow graph - DML seed rows - expected audit stages ## Canonical Runtime Step Set <Highlight type=\"info\" title=\"Step loop behavior\"> Step loop invokes each <MethodRef>execute(session)</MethodRef>. If a step returns <MethodRef>Stop</MethodRef>, response returns immediately; otherwise loop continues. </Highlight> <div className=\"ce-step-badge-list\" role=\"list\" aria-label=\"Canonical runtime step set\"> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">1</span><span className=\"ce-step-badge-label\">LoadOrCreateConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">2</span><span className=\"ce-step-badge-label\">ResetConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">3</span><span className=\"ce-step-badge-label\">PersistConversationBootstrapStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">4</span><span className=\"ce-step-badge-label\">AuditUserInputStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">5</span><span className=\"ce-step-badge-label\">PolicyEnforcementStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">6</span><span className=\"ce-step-badge-label\">IntentResolutionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">7</span><span className=\"ce-step-badge-label\">ResetResolvedIntentStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">8</span><span className=\"ce-step-badge-label\">FallbackIntentStateStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">9</span><span className=\"ce-step-badge-label\">AddContainerDataStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">10</span><span className=\"ce-step-badge-label\">McpToolStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">11</span><span className=\"ce-step-badge-label\">SchemaExtractionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">12</span><span className=\"ce-step-badge-label\">AutoAdvanceStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">13</span><span className=\"ce-step-badge-label\">RulesStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">14</span><span className=\"ce-step-badge-label\">ResponseResolutionStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">15</span><span className=\"ce-step-badge-label\">PersistConversationStep</span></div> <div className=\"ce-step-badge-item\"><span className=\"ce-step-badge-index\">16</span><span className=\"ce-step-badge-label\">PipelineEndGuardStep</span></div> </div> <details className=\"ce-trace-details\"> <summary>Open full step traversal with snippets</summary> <CodeBlockToggle title=\"ConversationController.message\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/api/controller/ConversationController.java\"> { @PostMapping(\"/message\") public ConversationResponse message(@RequestBody ConversationRequest request) { UUID conversationId = request.getConversationId() != null ? request.getConversationId() : UUID.randomUUID(); Map<String, Object> inputParams = new LinkedHashMap<>(); if (request.getInputParams() != null) { inputParams.putAll(request.getInputParams()); } EngineContext engineContext = EngineContext.builder() .conversationId(conversationId.toString()) .userText(request.getMessage()) .inputParams(inputParams) .build(); EngineResult result = engine.process(engineContext); return mapToResponse(result); } } </CodeBlockToggle> <CodeBlockToggle title=\"DefaultConversationalEngine.process\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java\"> { @Override public EngineResult process(EngineContext engineContext) { EngineSession session = sessionFactory.open(engineContext); session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10)); EnginePipeline pipeline = pipelineFactory.create(); return pipeline.execute(session); } } </CodeBlockToggle> <CodeBlockToggle title=\"EnginePipeline.execute\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java\"> { public EngineResult execute(EngineSession session) { for (EngineStep step : steps) { StepResult result = step.execute(session); if (result instanceof StepResult.Stop(EngineResult finalResult)) { return finalResult; } } if (session.getFinalResult() == null) { throw new ConversationEngineException(ConversationEngineErrorCode.PIPELINE_NO_FINAL_RESULT); } return session.getFinalResult(); } } </CodeBlockToggle> <CodeBlockToggle title=\"LoadOrCreateConversationStep.execute\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/LoadOrCreateConversationStep.java\"> { public StepResult execute(EngineSession session) { CeConversation persisted = conversationRepo.findByConversationId(session.getConversationId()) .orElseGet(() -> conversationRepo.save(createConversation(session.getConversationId()))); session.setConversation(persisted); session.setIntent(persisted.getIntentCode()); session.setState(persisted.getStateCode()); session.mergeContextJson(persisted.getContextJson()); return new StepResult.Continue(); } } </CodeBlockToggle> <CodeBlockToggle title=\"IntentResolutionStep.execute\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/IntentResolutionStep.java\"> { public StepResult execute(EngineSession session) { if (session.isSchemaLocked() && session.hasIntent()) { audit.audit(\"INTENT_SKIP_LOCKED\", session.getConversationId(), Map.of(\"intent\", session.getIntent())); return new StepResult.Continue(); } IntentResolutionTrace trace = resolver.resolveWithTrace(session.getUserText(), session.contextDict()); session.setIntent(trace.getIntent()); session.setState(trace.getState()); audit.audit(\"INTENT_RESOLVED\", session.getConversationId(), Map.of( \"intent\", trace.getIntent(), \"confidence\", trace.getConfidence(), \"source\", trace.getSource() )); return new StepResult.Continue(); } } </CodeBlockToggle> <CodeBlockToggle title=\"SchemaExtractionStep.execute\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/SchemaExtractionStep.java\"> { public StepResult execute(EngineSession session) { Optional<CeOutputSchema> schemaOpt = outputSchemaRepo.findEnabled(session.getIntent(), session.getState()); if (schemaOpt.isEmpty()) { return new StepResult.Continue(); } CeOutputSchema schema = schemaOpt.get(); String prompt = promptRenderer.renderSchemaPrompt(session, schema); String extractedJson = llmClient.generateJson(prompt, schema.getSchemaJson(), session.getContextJsonOrEmpty()); session.mergeContextJson(extractedJson); MissingFieldResult missing = missingFieldEvaluator.evaluate(schema.getSchemaJson(), session.contextDict()); session.setMissingFields(missing.names()); session.setSchemaLocked(!missing.isComplete()); audit.audit(\"SCHEMA_EVALUATED\", session.getConversationId(), Map.of(\"missing\", missing.names())); return new StepResult.Continue(); } } </CodeBlockToggle> <CodeBlockToggle title=\"RulesStep.execute\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/RulesStep.java\"> { public StepResult execute(EngineSession session) { int pass = 0; boolean changed; do { changed = false; pass++; for (CeRule rule : ruleRepo.findEnabled(session.getIntent(), session.getState())) { if (!ruleMatcher.matches(rule, session)) { continue; } RuleOutcome outcome = actionExecutor.apply(rule, session); changed = changed || outcome.mutatedIntentOrState(); audit.audit(\"RULE_MATCHED\", session.getConversationId(), Map.of(\"ruleId\", rule.getId(), \"action\", rule.getAction())); } } while (changed && pass < 4); return new StepResult.Continue(); } } </CodeBlockToggle> <CodeBlockToggle title=\"ResponseResolutionStep.execute\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/ResponseResolutionStep.java\"> { public StepResult execute(EngineSession session) { CeResponse row = responseRepo.resolve(session.getIntent(), session.getState()) .orElseThrow(() -> new ConversationEngineException(RESPONSE_NOT_FOUND)); EngineResult result = \"EXACT\".equalsIgnoreCase(row.getResponseType()) ? exactResolver.resolve(row, session) : derivedResolver.resolve(row, session); session.setFinalResult(result); audit.audit(\"ASSISTANT_OUTPUT\", session.getConversationId(), Map.of( \"responseType\", row.getResponseType(), \"outputFormat\", row.getOutputFormat() )); return new StepResult.Continue(); } } </CodeBlockToggle> <CodeBlockToggle title=\"PersistConversationStep.execute\" language=\"java\" filePath=\"src/main/java/com/github/salilvnair/convengine/engine/steps/PersistConversationStep.java\"> { public StepResult execute(EngineSession session) { CeConversation c = session.getConversation(); c.setIntentCode(session.getIntent()); c.setStateCode(session.getState()); c.setContextJson(session.getContextJsonOrEmpty()); c.setLastAssistantJson(session.getFinalResultJson()); conversationRepo.save(c); return new StepResult.Continue(); } } </CodeBlockToggle> </details> ## FAQ <Tabs groupId=\"example-faq\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"FAQ\"> <User>Can I move my connection within Zapper?</User> <Assistant>Yes. You can request relocation from the support portal.</Assistant> </Conversation> <EngineDebugFlow title=\"FAQ runtime flow\" subtitle=\"Classifier-first deterministic path\" nodes={faqNodes} edges={faqEdges} detailsById={faqDetails} defaultSelectedId=\"faq_intent\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"FAQ seed SQL\" language=\"sql\"> { insert into ce_intent(intent_code, state_code, enabled) values ('FAQ', null, true); insert into ce_intent_classifier(intent_code, match_pattern, priority, enabled) values ('FAQ', '(?i).*(office|location|address).*', 10, true); insert into ce_response(intent_code, state_code, response_type, output_format, exact_text, enabled) values ('FAQ', null, 'EXACT', 'TEXT', 'Yes. You can request relocation from the support portal.', true); insert into ce_config(component, config_key, config_value, enabled) values ('ResetConversationStep', 'RESET_COMMAND', 'RESET_SESSION', true); } </CodeBlockToggle> <DbTable title=\"FAQ seed preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=FAQ\"], [\"ce_intent_classifier\", \"pattern=(?i).*(office|location|address).*\"] , [\"ce_response\", \"response_type=EXACT, output_format=TEXT\"], [\"ce_config\", \"RESET_COMMAND=RESET_SESSION\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"FAQ expected ce_audit trail\" columns={[\"Stage\", \"Meaning\"]} rows={[ [\"USER_INPUT\", \"Incoming user message captured\"], [\"INTENT_RESOLVED\", \"FAQ selected\"], [\"RULE_NO_MATCH\", \"No transition rule needed\"], [\"ASSISTANT_OUTPUT\", \"EXACT response emitted\"], [\"CONVERSATION_PERSIST\", \"Session snapshot saved\"], ]} /> </TabItem> </Tabs> ## DISCONNECT_ELECTRICITY <Tabs groupId=\"example-disconnect\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"DISCONNECT_ELECTRICITY\"> <User>Disconnect electricity for account 10004567.</User> <Assistant>Please share disconnect date and reason.</Assistant> <User>Date is 2026-03-31, reason moving out.</User> <Assistant>Done. Request submitted.</Assistant> </Conversation> <EngineDebugFlow title=\"Disconnect flow\" subtitle=\"Incomplete schema -> follow-up -> complete -> finalize\" nodes={disconnectNodes} edges={disconnectEdges} detailsById={disconnectDetails} defaultSelectedId=\"d_schema\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <CodeBlockToggle title=\"DISCONNECT_ELECTRICITY seed SQL\" language=\"sql\"> { insert into ce_intent(intent_code, enabled) values ('DISCONNECT_ELECTRICITY', true); insert into ce_output_schema(intent_code, schema_json, enabled) values ('DISCONNECT_ELECTRICITY', '{\"type\":\"object\",\"properties\":{\"accountId\":{\"type\":\"string\"},\"disconnectDate\":{\"type\":\"string\"},\"reason\":{\"type\":\"string\"}},\"required\":[\"accountId\",\"disconnectDate\",\"reason\"]}', true); insert into ce_prompt_template(intent_code, state_code, response_type, system_prompt, user_prompt, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', 'TEXT', 'Collect missing disconnect fields.', 'Ask only for missing disconnect fields from: {{user_input}}', true); insert into ce_response(intent_code, state_code, response_type, output_format, enabled) values ('DISCONNECT_ELECTRICITY', 'COLLECT_REQUIRED', 'DERIVED', 'TEXT', true); } </CodeBlockToggle> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"DISCONNECT_ELECTRICITY expected ce_audit trail\" columns={[\"Stage\", \"Meaning\"]} rows={[ [\"INTENT_RESOLVED\", \"Intent selected\"], [\"SCHEMA_INCOMPLETE\", \"Missing fields detected\"], [\"ASSISTANT_OUTPUT\", \"Follow-up asked\"], [\"SCHEMA_COMPLETE\", \"All required fields present\"], [\"RULE_MATCHED\", \"State transition executed\"], [\"CONVERSATION_PERSIST\", \"Final state stored\"], ]} /> </TabItem> </Tabs> ## LOG_ANALYSIS <Tabs groupId=\"example-log\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"LOG_ANALYSIS\"> <User>Analyze timeout logs and tell root cause.</User> <Assistant>Root cause is DB connection pool saturation from 11:02 to 11:07 UTC.</Assistant> </Conversation> <EngineDebugFlow title=\"Log analysis flow\" subtitle=\"GET_SCHEMA_JSON rule and DERIVED output\" nodes={logNodes} edges={logEdges} detailsById={logDetails} defaultSelectedId=\"l_rules\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <DbTable title=\"LOG_ANALYSIS seed preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=LOG_ANALYSIS\"], [\"ce_output_schema\", \"fields=errorCode,component,severity\"], [\"ce_rule\", \"action=GET_SCHEMA_JSON\"], [\"ce_response\", \"response_type=DERIVED\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"LOG_ANALYSIS expected ce_audit trail\" columns={[\"Stage\", \"Meaning\"]} rows={[ [\"INTENT_RESOLVED\", \"LOG_ANALYSIS selected\"], [\"SCHEMA_EVALUATED\", \"Structured facts extracted\"], [\"RULE_MATCHED\", \"GET_SCHEMA_JSON evaluated\"], [\"ASSISTANT_OUTPUT\", \"Derived explanation produced\"], ]} /> </TabItem> </Tabs> ## REQUEST_TRACKER <Tabs groupId=\"example-tracker\"> <TabItem value=\"conversation\" label=\"Conversation + Flow\" default> <Conversation title=\"REQUEST_TRACKER\"> <User>Track request REQ-778102.</User> <Assistant>REQ-778102 is IN_REVIEW and assigned to Queue-3.</Assistant> </Conversation> <EngineDebugFlow title=\"Tracker flow\" subtitle=\"SET_TASK driven state path\" nodes={trackerNodes} edges={trackerEdges} detailsById={trackerDetails} defaultSelectedId=\"t_rules\" /> </TabItem> <TabItem value=\"dml\" label=\"DML Entries\"> <DbTable title=\"REQUEST_TRACKER seed preview\" columns={[\"Table\", \"Key values\"]} rows={[ [\"ce_intent\", \"intent_code=REQUEST_TRACKER\"], [\"ce_output_schema\", \"field=requestId\"], [\"ce_rule\", \"action=SET_TASK\"], [\"ce_response\", \"response_type=DERIVED\"], ]} /> </TabItem> <TabItem value=\"audit\" label=\"Audit Trail\"> <DbTable title=\"REQUEST_TRACKER expected ce_audit trail\" columns={[\"Stage\", \"Meaning\"]} rows={[ [\"INTENT_RESOLVED\", \"REQUEST_TRACKER selected\"], [\"RULE_MATCHED\", \"SET_TASK applied\"], [\"ASSISTANT_OUTPUT\", \"Status response emitted\"], [\"CONVERSATION_PERSIST\", \"Turn persisted\"], ]} /> </TabItem> </Tabs> <Highlight type=\"tip\" title=\"Fast validation\"> For each example run, inspect both <FileRef>/api/v1/conversation/audit/{'{conversationId}'}</FileRef> and <FileRef>/api/v1/conversation/audit/{'{conversationId}'}/trace</FileRef>. </Highlight>",
    "excerpt": ", data: }, , data: }, , data: }, , data: }, , data: }, , data: }, ]; , , , , , ]; faq_api: , faq_engine: , faq_intent: , faq_rules: , faq_resp: , faq_persist: , }; , data: }, , data: }, , data: }, , data: }, , data: }, ,…"
  },
  {
    "id": "local-development.mdx",
    "title": "local development",
    "permalink": "/docs/local-development",
    "content": "Local Development Prerequisites Java 21 Spring compatible host app PostgreSQL + ConvEngine ce_ schema LlmClient implementation bean Minimal integration } } Required runtime beans from consumer side LlmClient datasource + JPA config any custom hooks/transformers you need Recommended local test loop 1. Send one turn to /message 2. Read /audit/ '} 3. Read /audit/ '}/trace 4. Tune DB rows and rerun same conversation id Transport toggles Keep SSE enabled initially. Use STOMP only when your client architecture needs bidirectional websocket semantics. Optional feature annotations } } With @EnableConvEngine(stream = true) (default), startup fails if both SSE and STOMP are disabled. With @EnableConvEngine(stream = false) , transport flags are ignored and only REST flow is active.",
    "rawContent": "# Local Development ## Prerequisites - Java 21 - Spring-compatible host app - PostgreSQL + ConvEngine <FileRef>ce_*</FileRef> schema - <MethodRef>LlmClient</MethodRef> implementation bean ## Minimal integration <CodeBlockToggle title=\"Enable ConvEngine\" language=\"java\" packagePath=\"your.app\" > { @EnableConvEngine @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> ## Required runtime beans from consumer side - <MethodRef>LlmClient</MethodRef> - datasource + JPA config - any custom hooks/transformers you need ## Recommended local test loop 1. Send one turn to <FileRef>/message</FileRef> 2. Read <FileRef>/audit/{'{conversationId}'}</FileRef> 3. Read <FileRef>/audit/{'{conversationId}'}/trace</FileRef> 4. Tune DB rows and rerun same conversation id ## Transport toggles <CodeBlockToggle title=\"application.yml\" language=\"yaml\"> { server: port: 8080 spring: datasource: url: jdbc:postgresql://localhost:5432/convengine username: convengine_user password: convengine_pwd convengine: transport: sse: enabled: true or false emitter-timeout-ms: 1800000 stomp: enabled: true or false endpoint: /ws-convengine app-destination-prefix: /app topic-prefix: /topic audit-destination-base: /topic/convengine/audit allowed-origin-pattern: \"*\" sock-js: true broker: mode: SIMPLE relay-destination-prefixes: /topic,/queue relay-host: localhost relay-port: 61613 client-login: \"\" client-passcode: \"\" system-login: \"\" system-passcode: \"\" virtual-host: \"\" system-heartbeat-send-interval-ms: 10000 system-heartbeat-receive-interval-ms: 10000 audit: enabled: true level: ALL include-stages: [] exclude-stages: [] persistence: mode: IMMEDIATE jdbc-batch-size: 200 max-buffered-events: 5000 flush-stages: ENGINE_KNOWN_FAILURE,ENGINE_UNKNOWN_FAILURE final-step-names: PipelineEndGuardStep flush-on-stop-outcome: true dispatch: async-enabled: false worker-threads: 2 queue-capacity: 2000 rejection-policy: CALLER_RUNS keep-alive-seconds: 60 rate-limit: enabled: false max-events: 200 window-ms: 1000 per-conversation: true per-stage: true max-tracked-buckets: 20000 experimental: enabled: false } </CodeBlockToggle> <Highlight type=\"warning\" title=\"When enabling STOMP\"> Keep SSE enabled initially. Use STOMP only when your client architecture needs bidirectional websocket semantics. </Highlight> ## Optional feature annotations <CodeBlockToggle title=\"Enable optional performance features\" language=\"java\"> { @EnableConvEngine(stream = true) @EnableConvEngineAsyncAuditDispatch @EnableConvEngineStompBrokerRelay @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } } </CodeBlockToggle> <Highlight type=\"info\" title=\"Stream flag behavior\"> With <MethodRef>@EnableConvEngine(stream = true)</MethodRef> (default), startup fails if both SSE and STOMP are disabled. With <MethodRef>@EnableConvEngine(stream = false)</MethodRef>, transport flags are ignored and only REST flow is active. </Highlight>",
    "excerpt": "Local Development Prerequisites Java 21 Spring compatible host app PostgreSQL + ConvEngine ce_ schema LlmClient implementation bean Minimal integration } } Required runtime beans from consumer side LlmClient datasource +…"
  },
  {
    "id": "overview.mdx",
    "title": "overview",
    "permalink": "/docs/overview",
    "content": "ConvEngine Overview ConvEngine is a deterministic, DB configured conversation engine. It is built for workflow grade systems where behavior must be auditable and configurable through data. :::tip Why teams choose ConvEngine You can evolve behavior by updating ce_ rows instead of re releasing Java code for every intent/state/prompt change. ::: Runtime Model 1. API receives one turn. 2. Engine opens/restores session state. 3. Ordered steps run as a pipeline. 4. Rules and response mapping produce output. 5. Conversation and audit timeline are persisted. Determinism Boundary Deterministic controls: ce_rule , ce_response , ce_intent_classifier , ce_output_schema , ce_policy Constrained LLM usage: intent scoring, schema extraction, derived response generation Fully auditable runtime: ce_audit stage stream + trace API All ce_ Tables (what/why) DISCONNECT_ELECTRICITY\"], [\"ce_output_schema\", \"Schema contract for structured data extraction by intent/state.\", \"Required fields: accountId, serviceAddress\"], [\"ce_prompt_template\", \"System/user prompt templates for schema extraction and derived outputs.\", \"response_type=SCHEMA_JSON or TEXT with system/user prompt\"], [\"ce_response\", \"Maps intent/state to EXACT or DERIVED output behavior.\", \"intent=FAQ, state=IDLE, response_type=EXACT\"], [\"ce_rule\", \"State machine transitions and context actions with execution phase control.\", \"phase=PIPELINE_RULES, JSON_PATH SET_STATE=AWAITING_ACCOUNT_ID\"], [\"ce_policy\", \"Early safety blocks (contains/regex/etc.).\", \"Block prohibited request patterns with fixed response\"], [\"ce_mcp_tool\", \"Tool registry visible to MCP planner.\", \"postgres.schema, postgres.query\"], [\"ce_mcp_db_tool\", \"SQL templates and safety limits for DB tools.\", \"sql_template with param_schema and max_rows\"], [\"ce_config\", \"Runtime tunables/prompts per component class.\", \"AgentIntentResolver.MIN_CONFIDENCE=0.55\"], [\"ce_conversation\", \"Current durable state for each conversation id.\", \"intent/state/context json + last assistant output\"], [\"ce_audit\", \"Append only execution timeline for each stage.\", \"INTENT_RESOLVE_START, RULE_MATCHED, ASSISTANT_OUTPUT\"], ]} / ce_prompt_template and ce_config are not interchangeable. ce_prompt_template is intent/state/response template content. ce_config is class keyed runtime config (thresholds/system prompts/component behavior). Use ce_policy to block prohibited request patterns with a fixed response. Use ce_prompt_template + ce_response for response shapes like SCHEMA_JSON or TEXT with explicit system/user prompts.",
    "rawContent": "# ConvEngine Overview ConvEngine is a deterministic, DB-configured conversation engine. It is built for workflow-grade systems where behavior must be auditable and configurable through data. :::tip Why teams choose ConvEngine You can evolve behavior by updating ce_* rows instead of re-releasing Java code for every intent/state/prompt change. ::: ## Runtime Model 1. API receives one turn. 2. Engine opens/restores session state. 3. Ordered steps run as a pipeline. 4. Rules and response mapping produce output. 5. Conversation and audit timeline are persisted. ## Determinism Boundary - Deterministic controls: ce_rule , ce_response , ce_intent_classifier , ce_output_schema , ce_policy - Constrained LLM usage: intent scoring, schema extraction, derived response generation - Fully auditable runtime: ce_audit stage stream + trace API ## All ce_* Tables (what/why) <DbTable title=\"Control Plane + Runtime Tables\" columns={[\"Table\", \"Why this table exists\", \"Typical example row\"]} rows={[ [\"ce_intent\", \"Defines allowed intents and metadata for resolvers.\", \"FAQ, DISCONNECT_ELECTRICITY, LOG_ANALYSIS, REQUEST_TRACKER\"], [\"ce_intent_classifier\", \"Deterministic matcher config (regex/exact/etc.) before/alongside LLM.\", \"Rule matching 'disconnect my power' -> DISCONNECT_ELECTRICITY\"], [\"ce_output_schema\", \"Schema contract for structured data extraction by intent/state.\", \"Required fields: accountId, serviceAddress\"], [\"ce_prompt_template\", \"System/user prompt templates for schema extraction and derived outputs.\", \"response_type=SCHEMA_JSON or TEXT with system/user prompt\"], [\"ce_response\", \"Maps intent/state to EXACT or DERIVED output behavior.\", \"intent=FAQ, state=IDLE, response_type=EXACT\"], [\"ce_rule\", \"State machine transitions and context actions with execution phase control.\", \"phase=PIPELINE_RULES, JSON_PATH -> SET_STATE=AWAITING_ACCOUNT_ID\"], [\"ce_policy\", \"Early safety blocks (contains/regex/etc.).\", \"Block prohibited request patterns with fixed response\"], [\"ce_mcp_tool\", \"Tool registry visible to MCP planner.\", \"postgres.schema, postgres.query\"], [\"ce_mcp_db_tool\", \"SQL templates and safety limits for DB tools.\", \"sql_template with param_schema and max_rows\"], [\"ce_config\", \"Runtime tunables/prompts per component class.\", \"AgentIntentResolver.MIN_CONFIDENCE=0.55\"], [\"ce_conversation\", \"Current durable state for each conversation id.\", \"intent/state/context json + last assistant output\"], [\"ce_audit\", \"Append-only execution timeline for each stage.\", \"INTENT_RESOLVE_START, RULE_MATCHED, ASSISTANT_OUTPUT\"], ]} /> <Highlight type=\"info\" title=\"Important\"> ce_prompt_template and ce_config are not interchangeable. - ce_prompt_template is intent/state/response template content. - ce_config is class-keyed runtime config (thresholds/system prompts/component behavior). </Highlight> <Highlight type=\"tip\" title=\"Prohibited Pattern Handling\"> Use ce_policy to block prohibited request patterns with a fixed response. Use ce_prompt_template + ce_response for response shapes like SCHEMA_JSON or TEXT with explicit system/user prompts. </Highlight>",
    "excerpt": "ConvEngine Overview ConvEngine is a deterministic, DB configured conversation engine. It is built for workflow grade systems where behavior must be auditable and configurable through data. :::tip Why teams choose ConvEng…"
  },
  {
    "id": "version-history.mdx",
    "title": "version history",
    "permalink": "/docs/version-history",
    "content": "Version History There is a non linear period ( 1.0.3 1.0.2 1.0.3 ) visible in raw commit history, which typically happens during branch merges/backports. Current published artifact in pom.xml is 1.0.10 . Artifact Version Bumps ( pom.xml ) 1.0.0\", \"Base code: core entities and interfaces\"], [\"2026 01 16\", \"0f1ff98\", \"1.0.0 2.0.0\", \"Large framework/entity expansion (transitional line)\"], [\"2026 01 27\", \"7e778cc\", \"2.0.0 1.0.0\", \"Packaging/publishing reset + metadata hardening\"], [\"2026 01 28\", \"cb38cc8\", \"1.0.0 1.0.1\", \"Release bump + core dependency refresh\"], [\"2026 02 07\", \"e302374\", \"1.0.1 1.0.3\", \"Intent/state handling upgrade\"], [\"2026 02 08\", \"d8faa28\", \"1.0.3 1.0.2\", \"JSON/session action resolver line (non linear branch)\"], [\"2026 02 12\", \"976c8f8\", \"1.0.2 1.0.3\", \"Response/session improvements + container/schema refinements\"], [\"2026 02 12\", \"48aae75\", \"1.0.3 1.0.4\", \"RulesStep integration into intent flow + audit improvements\"], [\"2026 02 12\", \"6f6033d\", \"1.0.4 1.0.5\", \"inputParamsJson and better session continuity\"], [\"2026 02 13\", \"05f9077\", \"1.0.5 1.0.7\", \"Schema handling + agent resolver controls\"], [\"2026 02 14\", \"a2daeec\", \"1.0.7 1.0.8\", \"Audit listener model + SSE/STOMP transport + reset flow\"], [\"2026 02 16\", \"695ef79\", \"1.0.8 1.0.9\", \"Experimental SQL generation zip export + SQL by table response model\"], [\"2026 02 17\", \"working tree\", \"1.0.9 1.0.10\", \"Rule phase model + sticky intent continuity + stream validator hardening\"], ]} / Release Notes By Version 1.0.10 (Current in pom.xml ) What changed: Added ce_rule.phase execution model: PIPELINE_RULES AGENT_POST_INTENT Added runtime rule phase filtering so: RulesStep executes only PIPELINE_RULES AgentIntentResolver post intent pass executes only AGENT_POST_INTENT Added session/input metadata for rule source awareness: postIntentRule , post_intent_rule rule_phase rule_execution_source , rule_execution_origin Added post intent rule invocation after accepted agent intent. Added sticky intent continuity controls: IntentResolutionStep.STICKY_INTENT ( ce_config , default true ) skip intent re resolution when intent/state are already resolved added audit stage INTENT_RESOLVE_SKIPPED_STICKY_INTENT explicit reset/switch/force signals still allow re resolution Updated prompt variable exposure: prompt extra now receives all inputParams keys includes runtime/system derived keys set via session.putInputParam(...) Hardened stream startup validation and condition timing behavior to avoid false positive startup failures. Updated SQL generation docs/prompts to include ce_rule.phase contract. 1.0.9 Commit: 695ef79 What changed: Enhanced experimental SQL generation API output for consumer import workflows. Added SQL by table response structure to make generated output easier to inspect and apply incrementally. Added zip packaging support with per table SQL files plus combined seed.sql . Updated docs and SQL generation guidance for clarity and alignment with current runtime model. 1.0.8 Commits: a2daeec core release bump and transport/audit foundation 57a2faa async audit dispatch + deferred flush controls (post bump enhancements on same line) c5c665f typed step API via EngineStep.Name 0c2c557 rule action rename to GET_SCHEMA_JSON What changed in detail: Added streaming transport stack: SSE and STOMP/WebSocket support consumer configurable stream mode Added audit event plumbing: AuditEventListener extension point stage broadcast path for streaming UIs Added advanced audit controls: async dispatch workers queue/backpressure policy deferred bulk persistence + flush triggers Strengthened step extension API: string based step matching replaced by typed EngineStep.Name safer EngineStepHook contracts ( supports/beforeStep/afterStep/onStepError ) Renamed schema action contract: GET_SCHEMA_EXTRACTED_DATA GET_SCHEMA_JSON aligned resolver/session access semantics 1.0.7 Commit: 05f9077 What changed: Schema extraction and intent resolution refinements additional agent resolver controls/flags better handling of schema aware intent decisions 1.0.5 Commit: 6f6033d What changed: Session continuity improvements with inputParamsJson stronger propagation of input parameters across turns better task action resolution in rules/action path 1.0.4 Commit: 48aae75 What changed: Intent pipeline refactor to integrate RulesStep cleanly improved rule driven transition behavior richer audit emission around intent/rule flow 1.0.3 Line Commits: e302374 , 976c8f8 (and non linear branch point via d8faa28 ) What changed: Intent/state handling updates response transformation improvements container data handling and schema path upgrades new JSON/session action resolvers and structured auditing 1.0.1 / 1.0.0 Foundation Commits: cb38cc8 , 7e778cc , 1ff9681 What changed: Initial publish line and project metadata hardening dependency/property cleanup in pom.xml foundational entities/interfaces and deterministic engine baseline Non Versioned (But Significant) Commits Current State Snapshot",
    "rawContent": "# Version History <Highlight type=\"info\" title=\"Important note on sequence\"> There is a non-linear period ( 1.0.3 -> 1.0.2 -> 1.0.3 ) visible in raw commit history, which typically happens during branch merges/backports. Current published artifact in pom.xml is <MethodRef>1.0.10</MethodRef>. </Highlight> ## Artifact Version Bumps ( pom.xml ) <DbTable title=\"Version bump trail from Git\" columns={[\"Date\", \"Commit\", \"pom.xml change\", \"Headline\"]} rows={[ [\"2026-01-04\", \"1ff9681\", \"-> 1.0.0\", \"Base code: core entities and interfaces\"], [\"2026-01-16\", \"0f1ff98\", \"1.0.0 -> 2.0.0\", \"Large framework/entity expansion (transitional line)\"], [\"2026-01-27\", \"7e778cc\", \"2.0.0 -> 1.0.0\", \"Packaging/publishing reset + metadata hardening\"], [\"2026-01-28\", \"cb38cc8\", \"1.0.0 -> 1.0.1\", \"Release bump + core dependency refresh\"], [\"2026-02-07\", \"e302374\", \"1.0.1 -> 1.0.3\", \"Intent/state handling upgrade\"], [\"2026-02-08\", \"d8faa28\", \"1.0.3 -> 1.0.2\", \"JSON/session action resolver line (non-linear branch)\"], [\"2026-02-12\", \"976c8f8\", \"1.0.2 -> 1.0.3\", \"Response/session improvements + container/schema refinements\"], [\"2026-02-12\", \"48aae75\", \"1.0.3 -> 1.0.4\", \"RulesStep integration into intent flow + audit improvements\"], [\"2026-02-12\", \"6f6033d\", \"1.0.4 -> 1.0.5\", \"inputParamsJson and better session continuity\"], [\"2026-02-13\", \"05f9077\", \"1.0.5 -> 1.0.7\", \"Schema handling + agent resolver controls\"], [\"2026-02-14\", \"a2daeec\", \"1.0.7 -> 1.0.8\", \"Audit listener model + SSE/STOMP transport + reset flow\"], [\"2026-02-16\", \"695ef79\", \"1.0.8 -> 1.0.9\", \"Experimental SQL generation zip export + SQL-by-table response model\"], [\"2026-02-17\", \"working-tree\", \"1.0.9 -> 1.0.10\", \"Rule phase model + sticky intent continuity + stream validator hardening\"], ]} /> ## Release Notes By Version ### 1.0.10 (Current in pom.xml ) What changed: - Added ce_rule.phase execution model: - PIPELINE_RULES - AGENT_POST_INTENT - Added runtime rule-phase filtering so: - RulesStep executes only PIPELINE_RULES - AgentIntentResolver post-intent pass executes only AGENT_POST_INTENT - Added session/input metadata for rule-source awareness: - postIntentRule , post_intent_rule - rule_phase - rule_execution_source , rule_execution_origin - Added post-intent rule invocation after accepted agent intent. - Added sticky intent continuity controls: - IntentResolutionStep.STICKY_INTENT ( ce_config , default true ) - skip intent re-resolution when intent/state are already resolved - added audit stage INTENT_RESOLVE_SKIPPED_STICKY_INTENT - explicit reset/switch/force signals still allow re-resolution - Updated prompt variable exposure: - prompt extra now receives all inputParams keys - includes runtime/system-derived keys set via session.putInputParam(...) - Hardened stream startup validation and condition timing behavior to avoid false-positive startup failures. - Updated SQL generation docs/prompts to include ce_rule.phase contract. ### 1.0.9 Commit: 695ef79 What changed: - Enhanced experimental SQL generation API output for consumer import workflows. - Added SQL-by-table response structure to make generated output easier to inspect and apply incrementally. - Added zip packaging support with per-table SQL files plus combined seed.sql . - Updated docs and SQL generation guidance for clarity and alignment with current runtime model. ### 1.0.8 Commits: - a2daeec core release bump and transport/audit foundation - 57a2faa async audit dispatch + deferred flush controls (post-bump enhancements on same line) - c5c665f typed step API via <MethodRef>EngineStep.Name</MethodRef> - 0c2c557 rule action rename to <MethodRef>GET_SCHEMA_JSON</MethodRef> What changed in detail: - Added streaming transport stack: - SSE and STOMP/WebSocket support - consumer-configurable stream mode - Added audit event plumbing: - AuditEventListener extension point - stage broadcast path for streaming UIs - Added advanced audit controls: - async dispatch workers - queue/backpressure policy - deferred bulk persistence + flush triggers - Strengthened step extension API: - string-based step matching replaced by typed <MethodRef>EngineStep.Name</MethodRef> - safer EngineStepHook contracts ( supports/beforeStep/afterStep/onStepError ) - Renamed schema action contract: - GET_SCHEMA_EXTRACTED_DATA -> GET_SCHEMA_JSON - aligned resolver/session access semantics ### 1.0.7 Commit: 05f9077 What changed: - Schema extraction and intent resolution refinements - additional agent resolver controls/flags - better handling of schema-aware intent decisions ### 1.0.5 Commit: 6f6033d What changed: - Session continuity improvements with inputParamsJson - stronger propagation of input parameters across turns - better task action resolution in rules/action path ### 1.0.4 Commit: 48aae75 What changed: - Intent pipeline refactor to integrate <MethodRef>RulesStep</MethodRef> cleanly - improved rule-driven transition behavior - richer audit emission around intent/rule flow ### 1.0.3 Line Commits: e302374 , 976c8f8 (and non-linear branch point via d8faa28 ) What changed: - Intent/state handling updates - response transformation improvements - container data handling and schema path upgrades - new JSON/session action resolvers and structured auditing ### 1.0.1 / 1.0.0 Foundation Commits: cb38cc8 , 7e778cc , 1ff9681 What changed: - Initial publish line and project metadata hardening - dependency/property cleanup in pom.xml - foundational entities/interfaces and deterministic engine baseline ## Non-Versioned (But Significant) Commits <DbTable title=\"Feature commits not tied to a new pom version\" columns={[\"Commit\", \"Area\", \"Why it matters\"]} rows={[ [\"57a2faa\", \"Audit + streaming controls\", \"Introduced async audit dispatch controls and deferred flush behavior for production performance\"], [\"c5c665f\", \"Step API typing\", \"Reduced runtime errors by replacing stringly-typed step names with EngineStep.Name enum\"], [\"0c2c557\", \"Rule action semantics\", \"Standardized schema action contract to GET_SCHEMA_JSON across engine/actions/docs\"], [\"7f4eb70\", \"Prompt/schema naming\", \"Aligned template/output naming ( SCHEMA_JSON ) and improved prompt-template retrieval by state\"], ]} /> ## Current State Snapshot <DbTable title=\"Current library status\" columns={[\"Signal\", \"Value\"]} rows={[ [\"Artifact version ( pom.xml )\", \"1.0.10\"], [\"Engine extension style\", \"Typed step hooks via EngineStep.Name\"], [\"Streaming\", \"REST + SSE + STOMP/WebSocket\"], [\"Audit model\", \"Immediate or deferred bulk persistence with async dispatch options\"], [\"Schema rule action\", \"GET_SCHEMA_JSON\"], [\"Rule phase contract\", \"PIPELINE_RULES + AGENT_POST_INTENT\"], ]} />",
    "excerpt": "Version History There is a non linear period ( 1.0.3 1.0.2 1.0.3 ) visible in raw commit history, which typically happens during branch merges/backports. Current published artifact in pom.xml is 1.0.10 . Artifact Version…"
  }
]