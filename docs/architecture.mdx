import {
  CodeBlockToggle,
  Conversation,
  User,
  Assistant,
  DbTable,
  Decision,
  Highlight,
  SchemaBlock,
} from "@site/src/components/convengine";

import {
  IconArrowRight,
  IconCpu,
  IconDatabase,
  IconBrain,
  IconTool,
  IconGitBranch,
  IconMessage,
  IconDeviceFloppy
} from "@tabler/icons-react";
import { Timeline, Text, Stack, Code } from "@mantine/core"

# Architecture

### End-to-end flow (the big picture)
<br />
<Timeline
  active={7}
  bulletSize={32}
  lineWidth={2}
>
  <Timeline.Item
    bullet={<IconArrowRight size={18} />}
    title="Request enters ConversationController"
  >
    <Stack gap="xs">
      <Text fw={600}>HTTP request received</Text>
      <Text size="sm" c="dimmed">
        REST API receives <Code>{"{conversationId, text}"}</Code>,
        audits <b>USER_INPUT</b>, and forwards control to
        <Code> DefaultConversationalEngine</Code>.
      </Text>
    </Stack>
  </Timeline.Item>

  <Timeline.Item
    bullet={<IconCpu size={18} />}
    title="EngineSession created + pipeline execution"
  >
    <Stack gap="xs">
      <Text fw={600}>Engine initializes execution context</Text>
      <Text size="sm" c="dimmed">
        EngineSession is a working POJO holding intent, state,
        context_json, payload, and history. The engine dynamically
        builds the pipeline from Spring-managed steps.
      </Text>
    </Stack>
  </Timeline.Item>

  <Timeline.Item
    bullet={<IconDatabase size={18} />}
    title="Conversation bootstrap + load"
  >
    <Stack gap="xs">
      <Text fw={600}>Conversation row ensured and restored</Text>
      <Text size="sm" c="dimmed">
        <Code>ce_conversation</Code> is created (if missing) and loaded.
        Existing <b>state_code</b>, <b>intent_code</b>, and
        <b>context_json</b> are restored into the session.
      </Text>
    </Stack>
  </Timeline.Item>

  <Timeline.Item
    bullet={<IconBrain size={18} />}
    title="Intent resolution"
  >
    <Stack gap="xs">
      <Text fw={600}>Intent classified using DB + LLM</Text>
      <Text size="sm" c="dimmed">
        Intent resolution is driven by
        <Code> ce_intent</Code>,
        <Code> ce_intent_classifier</Code>, and
        <Code> ce_prompt_template</Code>.
        AGENT classifiers invoke the LLM under strict JSON contracts.
      </Text>
    </Stack>
  </Timeline.Item>

  <Timeline.Item
    bullet={<IconTool size={18} />}
    title="MCP tool execution"
  >
    <Stack gap="xs">
      <Text fw={600}>Planner selects and executes tools</Text>
      <Text size="sm" c="dimmed">
        MCP context is cleared first.
        Planner selects tools from
        <Code> ce_mcp_tool</Code> +
        <Code> ce_mcp_db_tool</Code>,
        executes SQL safely, and stores observations and
        <b>finalAnswer</b> under <Code>context_json.mcp</Code>.
      </Text>
    </Stack>
  </Timeline.Item>

  <Timeline.Item
    bullet={<IconGitBranch size={18} />}
    title="Rules engine evaluation"
  >
    <Stack gap="xs">
      <Text fw={600}>DB-driven state machine applied</Text>
      <Text size="sm" c="dimmed">
        Rules from <Code>ce_rule</Code> run in priority order,
        mutating state, intent, or short-circuiting execution
        using resolver factories.
      </Text>
    </Stack>
  </Timeline.Item>

  <Timeline.Item
    bullet={<IconMessage size={18} />}
    title="Response resolution"
  >
    <Stack gap="xs">
      <Text fw={600}>Final payload generated</Text>
      <Text size="sm" c="dimmed">
        <Code>ce_response</Code> selects EXACT vs DERIVED output.
        DERIVED responses may invoke LLM; EXACT responses are
        deterministic and bypass generation.
      </Text>
    </Stack>
  </Timeline.Item>

  <Timeline.Item
    bullet={<IconDeviceFloppy size={18} />}
    title="Conversation persisted + response returned"
  >
    <Stack gap="xs">
      <Text fw={600}>Conversation saved and returned to client</Text>
      <Text size="sm" c="dimmed">
        Updated intent, state, context_json, and payload are
        persisted. The full execution trace is visible via
        <Code>ce_audit</Code>.
      </Text>
    </Stack>
  </Timeline.Item>
</Timeline>
---

## 1) Request entry point - controller

**File:** `api/controller/ConversationController.java`

**What happens here**
- Accepts `ConversationMessageRequest` with `conversationId` + `text`
- Writes a `USER_INPUT` audit so UI can replay the chain
- Delegates to `ConversationalEngine.process(...)`
- Returns `OutputPayload` (TextPayload or JsonPayload)

<CodeBlockToggle title="ConversationController.message(...)" language="java" defaultOpen={true}>
{`@PostMapping("/message")
public OutputPayload message(@RequestBody ConversationMessageRequest request) {
    UUID conversationId = request.getConversationId();

    audit.audit(
            "USER_INPUT",
            conversationId,
            "{\\"text\\":\\"" + JsonUtil.escape(request.getText()) + "\\"}"
    );

    EngineSession session = engine.process(conversationId, request.getText());

    audit.audit(
            "ENGINE_OUTPUT",
            conversationId,
            "{\\"payload\\":\\"" + JsonUtil.escape(String.valueOf(session.getPayload())) + "\\"}"
    );

    return session.getPayload();
}`}
</CodeBlockToggle>


---

## 2) ConversationalEngine - session + pipeline

**File:** `engine/provider/DefaultConversationalEngine.java`

This is the **single orchestration point** that:
- creates a new `EngineSession`
- creates the pipeline (dynamic steps)
- executes it
- returns the session to the controller

<CodeBlockToggle title="DefaultConversationalEngine.process(...)" language="java">
{`@Override
public EngineSession process(UUID conversationId, String userText) {

    EngineSession session =
            sessionFactory.create(conversationId, userText);

    EnginePipeline pipeline =
            pipelineFactory.createPipeline();

    pipeline.execute(session);

    return session;
}`}
</CodeBlockToggle>

<Highlight type="success">
  EngineSession is intentionally a <b>POJO working state</b>. 
  <br /><br />It should not ‚Äúreach into DB‚Äù. 
  <br /><br />DB reads/writes are done inside steps/services (like ConversationService, AuditHistoryProvider).
</Highlight>

---

## 3) EnginePipeline - the core loop (StepResult)

**File:** `engine/pipeline/EnginePipeline.java`

Every step returns a `StepResult`:
- `Continue` ‚Üí next step
- `Stop` ‚Üí pipeline terminates early and returns final OutputPayload

<CodeBlockToggle title="EnginePipeline.execute(...)" language="java" defaultOpen={true}>
{`public OutputPayload execute(EngineSession session) {

    for (EngineStep step : steps) {

        StepResult r = step.execute(session);

        if (r instanceof StepResult.Stop stop) {
            return stop.result();
        }
    }

    return session.getPayload();
}`}
</CodeBlockToggle>

<Highlight type="success">
  <div>
    <div>It's how the engine can <b>hard-stop</b> when required preconditions fail (missing payload, invalid state, no response configured).</div>
    <br />
    <div>It keeps ‚Äústop logic‚Äù centralized and predictable.</div>
  </div>
</Highlight>

---

## 4) Pipeline composition - how steps are discovered and ordered

**File:** `engine/factory/EnginePipelineFactory.java`

Steps are:
- discovered from Spring as beans of `EngineStep`
- filtered (conversation persisted requirement, etc.)
- ordered using annotations:
  - `@MustRunAfter`
  - `@MustRunBefore`
  - `@RequiresConversationPersisted`

<CodeBlockToggle title="EnginePipelineFactory ordering strategy (concept)" language="java">
{`// Pseudocode summary:
List<EngineStep> beans = stepsFromSpring();
List<EngineStep> ordered = orderResolver.sort(beans);
return new EnginePipeline(ordered);`}
</CodeBlockToggle>

<Highlight type="warning">
<b>Tip: adding a new step</b><br/>
1) Create a Spring component that implements EngineStep<br/>
2) Annotate with MustRunAfter / MustRunBefore relative to existing steps<br/>
3) If it requires a ce_conversation row, add @RequiresConversationPersisted<br/>
4) Add audits inside the step so UI shows it
</Highlight>

---

## 5) Database ‚Äúbrain‚Äù - all configuration tables (don't skip any)

Below is an overview of **every core table** that drives behavior.

<DbTable
  title="Configuration tables"
  columns={["Table", "What it controls", "Used by (code)", "Notes / key columns"]}
  rows={[
    [
      "ce_intent",
      "Allowed intents, priority ordering, description + llmHint",
      "AllowedIntentService, AgentIntentResolver",
      "intent_code, enabled, priority, llm_hint"
    ],
    [
      "ce_intent_classifier",
      "How intents are classified (AGENT/REGEX/EXACT etc) and which resolver to use",
      "IntentResolutionStep",
      "classifier_type, enabled, priority"
    ],
    [
      "ce_prompt_template",
      "Prompt templates by purpose + optional intent scoping",
      "AgentIntentResolver, MCP planner, Response resolvers",
      "purpose, intent_code, system_prompt, user_prompt, enabled"
    ],
    [
      "ce_output_schema",
      "Strict JSON schema control for LLM calls (by intent/state)",
      "AgentIntentResolver, response format resolvers",
      "intent_code, state_code, json_schema, enabled"
    ],
    [
      "ce_response",
      "Which response to use for (state,intent) and how to generate it",
      "ResponseResolutionStep + ResponseTypeResolverFactory",
      "state_code, intent_code, response_type, output_format, priority"
    ],
    [
      "ce_rule",
      "DB-driven state machine + short-circuit logic",
      "RulesStep + RuleTypeResolverFactory + RuleActionResolverFactory",
      "intent_code, rule_type, match_pattern, action, action_value, priority"
    ],
    [
      "ce_mcp_tool",
      "Tool registry (code/group/enabled/description)",
      "McpToolStep planner & tool loader",
      "tool_code, tool_group, enabled"
    ],
    [
      "ce_mcp_db_tool",
      "DB tool configuration (dialect, sql template, param schema, safe mode, max rows)",
      "McpDbToolExecutor",
      "tool_id (FK), sql_template, param_schema (jsonb), safe_mode, max_rows"
    ],
  ]}
/>

<DbTable
  title="Runtime tables"
  columns={["Table", "What it stores", "Written/Read by", "Key columns"]}
  rows={[
    [
      "ce_conversation",
      "One row per conversation with current state/intent + context_json + last response payload",
      "PersistConversationBootstrapStep, LoadOrCreateConversationStep, PersistConversationStep",
      "conversation_id, intent_code, state_code, context_json, last_assistant_json"
    ],
    [
      "ce_audit",
      "Append-only timeline of everything that happened during processing",
      "AuditService implementations; UI reads this for the chain",
      "conversation_id, stage, payload_json (json), created_at"
    ],
  ]}
/>

---

## 6) Step-by-step pipeline walk-through (actual steps)

Below is the **practical flow** you'll see in your engine.  
(Exact ordering can vary slightly based on annotations, but this is the intended lifecycle.)

### Step 1 - PersistConversationBootstrapStep

**File:** `engine/steps/PersistConversationBootstrapStep.java`

Purpose:
- Ensures the conversation exists in DB when needed (bootstrap)
- Audits the bootstrap action so your UI can see it



---

### Step 2 - LoadOrCreateConversationStep

**File:** `engine/steps/LoadOrCreateConversationStep.java`

Purpose:
- Loads existing conversation row OR creates a new one
- Syncs conversation's `intent_code`, `state_code`, `context_json` into EngineSession


<Highlight type="danger" >
  <div>
    <div>This is the boundary between ‚Äústateless HTTP call‚Äù and ‚Äústateful conversation engine‚Äù.</div>
    <br />
    <div>If this step is wrong, you'll see bugs like ‚Äúold move id answer repeats‚Äù because context wasn't updated/cleared correctly.</div>
  </div>
</Highlight>

---

### Step 3 - IntentResolutionStep

**File:** `engine/steps/IntentResolutionStep.java`

Purpose:
- Picks which classifier to run (from `ce_intent_classifier`)
- Classifiers can be AGENT / REGEX / EXACT
- Sets `session.intent` and audits


<CodeBlockToggle title="IntentResolutionStep (key idea)" language="java">
{`// Simplified:
CeIntentClassifier classifier = classifierRepo.findFirstEnabled(...);
IntentResolver resolver = resolverFactory.get(classifier.getClassifierType());
String intent = resolver.resolve(session);
session.setIntent(intent);`}
</CodeBlockToggle>

---

### Step 4 - (Validation / schema / extraction steps)

You have these steps in your engine to enrich session before MCP/Response:
- ValidationStep
- SchemaExtractionStep
- AutoAdvanceStep
(Exact behavior depends on your table config and your program features.)


---

### Step 5 - McpToolStep (MCP loop)

**File:** `engine/steps/McpToolStep.java`

Purpose:
- Clears old `context_json.mcp` (audit: MCP_CONTEXT_CLEARED)
- Planner calls LLM to decide tool usage
- Executes tools from DB tables:
  - ce_mcp_tool
  - ce_mcp_db_tool
- Writes:
  - `mcp.observations[]`
  - `mcp.finalAnswer`


<SchemaBlock title="context_json.mcp shape">
{`{
  "mcp": {
    "observations": [
      {
        "tool": "postgres.schema",
        "result": { "tables": ["..."] }
      },
      {
        "tool": "postgres.move_status",
        "result": { "rows": [ { "connection_id": "...", "status": "MOVED" } ] }
      }
    ],
    "finalAnswer": {
      "answer": "The status of your move for connection ... is MOVED."
    }
  }
}`}
</SchemaBlock>

<Highlight type="success">
  <div>
    <div>Tools come from <b>ce_mcp_tool</b> and <b>ce_mcp_db_tool</b>, not from if/else in Java.</div>
    <br />
    <div>SQL templates and param_schema are stored in DB and enforced via safe_mode + max_rows.</div>
    <br />
    <div>The planner's choice is audited so you can see exactly why it picked a tool.</div>
  </div>
</Highlight>

---

### Step 6 - RulesStep (DB-driven state machine + shortcuts)

**File:** `engine/steps/RulesStep.java`

Purpose:
- Iterates enabled rules ordered by priority
- Uses **factory pattern**:
  - RuleTypeResolverFactory ‚Üí resolves whether rule matches (JSON_PATH / REGEX / ‚Ä¶)
  - RuleActionResolverFactory ‚Üí applies mutation (SET_STATE / SET_INTENT / SHORT_CIRCUIT)
- Audits RULE_APPLIED / RULE_NOT_APPLIED etc



<Highlight type="success">
<b>This is where you build your state machine</b><br/>
Example: if MCP produced mcp.finalAnswer, you can SHORT_CIRCUIT deterministically (no LLM formatting required).
</Highlight>

---

### Step 7 - ResponseResolutionStep (ce_response driven)

**File:** `engine/steps/ResponseResolutionStep.java`

Purpose:
- Finds the matching `ce_response` row
- Delegates to `ResponseTypeResolverFactory`:
  - EXACT ‚Üí return configured response content directly
  - DERIVED ‚Üí uses templates + LLM (through OutputFormatResolverFactory)
- Writes audits including:
  - RESOLVE_RESPONSE
  - RESOLVE_RESPONSE_LLM_INPUT
  - RESOLVE_RESPONSE_LLM_OUTPUT



<Highlight type="success">
  <div>
    <div>Different programs can change responses without a build.</div>
    <br />
    <div>State+Intent drives the output: same intent can respond differently based on state_code.</div>
    <br />
    <div>DERIVED responses still remain controlled via templates + output schema.</div>
  </div>
</Highlight>

---

### Step 8 - PersistConversationStep + PipelineEndGuardStep

Purpose:
- PersistConversationStep syncs final `intent/state/context/last_assistant_json` to ce_conversation
- PipelineEndGuardStep ensures payload exists; otherwise returns STOP with error payload


---

## 7) Putting it together - example conversation + ‚Äúbehind the scenes‚Äù



# FAQ Example - How ConvEngine Answers FAQs (No MCP)

This document explains **exactly** how ConvEngine processes a **FAQ-style question**.
Unlike MOVE or other operational intents, **FAQ does NOT use MCP tools**.

If MCP runs for FAQ, that is a **bug** - not a feature.

---

## üó£Ô∏è Example FAQ Conversation

<Conversation>
  <User>
    Can I move my connections within zapper?
  </User>
  <br />
  <Assistant>
    Yes, internal account moves are supported.
  </Assistant>
</Conversation>

---

## üîÑ High-level Flow (FAQ)

Controller ‚Üí Engine ‚Üí Pipeline ‚Üí Intent ‚Üí Response ‚Üí Output

Key difference from MOVE:

- ‚ùå No MCP planner
- ‚ùå No MCP tools
- ‚ùå No DB queries via MCP
- ‚úÖ Direct FAQ resolution

---

## 1Ô∏è‚É£ Controller receives the request


<CodeBlockToggle
  title="ConversationController.message(...)"
  language="java">
{`@PostMapping("/message")
public OutputPayload message(@RequestBody ConversationMessageRequest request) {
    audit.audit(
        "USER_INPUT",
        request.getConversationId(),
        "{\\"text\\":\\"" + JsonUtil.escape(request.getText()) + "\\"}"
    );

    EngineSession session =
        engine.process(
            request.getConversationId(),
            request.getText()
        );

    return session.getPayload();
}`}
</CodeBlockToggle>

<Highlight type="info" title="Why audit USER_INPUT immediately?">
  <div>
    <div>So UI can replay the exact question later</div>
    <br />
    <div>So intent mistakes can be traced precisely</div>
  </div>
</Highlight>

---

## 2Ô∏è‚É£ Engine creates session and pipeline


<CodeBlockToggle
  title="DefaultConversationalEngine.process(...)"
  language="java">
{`EngineSession session =
    EngineSession.forConversation(conversationId, userText);

session.setHistory(historyProvider.load(conversationId));

EnginePipeline pipeline = pipelineFactory.create(session);
pipeline.execute(session);`}
</CodeBlockToggle>

<Highlight type="info">
EngineSession is a POJO.  
It does NOT decide behavior - the pipeline + DB do.
</Highlight>

---

## 3Ô∏è‚É£ Pipeline executes steps in order

<CodeBlockToggle
  title="EnginePipeline.execute(...)"
  language="java">
{`for (EngineStep step : steps) {
    StepResult r = step.execute(session);
    if (r instanceof StepResult.Stop stop) {
        return stop.result();
    }
}`}
</CodeBlockToggle>

<Decision type="info" title="Why StepResult?">
  <ul>
    <li>Allows SHORT_CIRCUIT</li>
    <li>Allows rules to stop flow early</li>
    <li>No hardcoded branching</li>
  </ul>
</Decision>

---

## 4Ô∏è‚É£ IntentResolutionStep ‚Üí FAQ

**Tables involved:**

<DbTable name="ce_intent" purpose="Allowed intents">
  <li>intent_code = FAQ</li>
  <li>priority</li>
  <li>enabled</li>
</DbTable>

<DbTable name="ce_prompt_template" purpose="Intent agent prompt">
  <li>purpose = INTENT_AGENT</li>
  <li>intent_code = null</li>
</DbTable>

The AgentIntentResolver:

- Sees allowed intents
- Uses LLM **only to classify**
- Returns `FAQ`

<Highlight type="success">
FAQ intent is resolved BEFORE any MCP logic exists.
</Highlight>

---

## 5Ô∏è‚É£ MCP is SKIPPED (IMPORTANT)

There is **no MCP planning** because:

- FAQ intent has **no MCP tools**
- No ce_mcp_tool applies
- No ce_mcp_db_tool is loaded

<Highlight type="danger">
If MCP runs for FAQ, your configuration is wrong.
</Highlight>

You will **not** see:
- MCP_PLAN_LLM_INPUT
- MCP_TOOL_CALL
- MCP_FINAL_ANSWER

---

## 6Ô∏è‚É£ RulesStep (usually no-op for FAQ)


Typical FAQ rules:

- none
- or cosmetic state changes

<DbTable name="ce_rule" purpose="Optional FAQ rules">
  <li>intent_code = FAQ</li>
  <li>rule_type = REGEX / JSON_PATH</li>
</DbTable>

<Highlight type="info">
FAQ usually has zero rules.
</Highlight>

---

## 7Ô∏è‚É£ ResponseResolutionStep


<DbTable name="ce_response" purpose="FAQ responses">
  <li>intent_code = FAQ</li>
  <li>state_code = IDLE</li>
  <li>response_type = EXACT or DERIVED</li>
</DbTable>

Two patterns:

### Pattern A - EXACT (no LLM)

- exact_text is returned
- fastest path

### Pattern B - DERIVED (LLM formatting)

- derivation_hint used
- still no MCP

<Highlight type="success">
FAQ responses NEVER depend on MCP context.
</Highlight>

---

## üîç What you'll see in ce_audit for FAQ

Typical stages:

- USER_INPUT
- INTENT_AGENT_LLM_INPUT
- INTENT_AGENT_LLM_OUTPUT
- RESOLVE_RESPONSE
- RESOLVE_RESPONSE_LLM_OUTPUT (only if DERIVED)

No MCP stages. Ever.

---

## ‚úÖ Final Takeaways (FAQ)

<Decision type="success" title="FAQ behavior summary">
  <ul>
    <li>Intent = FAQ</li>
    <li>No MCP planning</li>
    <li>No DB tools</li>
    <li>Response comes from ce_response</li>
    <li>Fully deterministic unless DERIVED</li>
  </ul>
</Decision>

If FAQ ever:
- reuses previous answers
- runs MCP
- hits DB tools

üëâ the bug is in **configuration**, not engine code.

---


# MOVE_CONNECTIONS - Architecture Deep Dive

This document explains **exactly** how ConvEngine processes a
`MOVE_CONNECTIONS` request - from REST controller to MCP tools to final response.

If you read this once, you should be able to:
- Debug any MOVE flow issue
- Add new MCP tools safely
- Understand where stale answers come from
- Explain the engine to another engineer confidently

---

## üó£Ô∏è Example Conversation

<Conversation>
  <User>
    What is the status of my move for connection USPSC003BA100SA277CON1388
  </User>
  <br />
  <Assistant>
    The status of your move for connection USPSC003BA100SA277CON1388 is MOVED.
  </Assistant>
  <br />
  <User>
    What is the status of my move for connection USPSC003BA100SA277CON1128
  </User>
  <br />
  <Assistant>
    The status of your move for connection USPSC003BA100SA277CON1128 is IN_PROGRESS.
  </Assistant>
</Conversation>

---

## üîÅ High-level Flow (One Turn)

Controller ‚Üí Engine ‚Üí Pipeline ‚Üí Intent ‚Üí MCP ‚Üí Rules ‚Üí Response

Every **User ‚Üí Assistant** turn follows this exact lifecycle.

---

## 1Ô∏è‚É£ Request enters via REST controller


**File:** `ConversationController.java`

<CodeBlockToggle language="java" title="ConversationController.message(...)">
{`@PostMapping("/message")
public OutputPayload message(@RequestBody ConversationMessageRequest request) {

    audit.audit(
        "USER_INPUT",
        request.getConversationId(),
        "{\\"text\\":\\"" + JsonUtil.escape(request.getText()) + "\\"}"
    );

    EngineSession session =
        engine.process(
            request.getConversationId(),
            request.getText()
        );

    audit.audit(
        "ENGINE_OUTPUT",
        session.getConversationId(),
        "{\\"payload\\":\\"" +
            JsonUtil.escape(String.valueOf(session.getPayload())) +
        "\\"}"
    );

    return session.getPayload();
}`}
</CodeBlockToggle>

<Decision type="info" title="Why audit at the controller?">
  <ul>
    <li><b>UI replay:</b> ce_audit becomes a full timeline</li>
    <li><b>Debug truth:</b> broken JSON or stale state is visible immediately</li>
    <li><b>No hidden behavior:</b> every request is auditable</li>
  </ul>
</Decision>

---

## 2Ô∏è‚É£ EngineSession + Pipeline orchestration


**File:** `DefaultConversationalEngine.java`

<CodeBlockToggle language="java" title="DefaultConversationalEngine.process(...)">
{`public EngineSession process(UUID conversationId, String userText) {

    EngineSession session =
        EngineSession.forConversation(conversationId, userText);

    session.setHistory(historyProvider.load(conversationId));

    EnginePipeline pipeline =
        pipelineFactory.create(session);

    pipeline.execute(session);

    return session;
}`}
</CodeBlockToggle>

<Highlight type="success">
EngineSession is a POJO.  
All intelligence lives in pipeline steps + DB configuration.
</Highlight>

---

## 3Ô∏è‚É£ Pipeline execution model


**File:** `EnginePipeline.java`

<CodeBlockToggle language="java" title="EnginePipeline.execute(...)">
{`for (EngineStep step : steps) {
    StepResult r = step.execute(session);

    if (r instanceof StepResult.Stop stop) {
        return stop.result();
    }
}`}
</CodeBlockToggle>

<Decision type="info" title="Why StepResult?">
  <ul>
    <li>Allows SHORT_CIRCUIT responses</li>
    <li>Allows rules to stop execution</li>
    <li>Keeps pipeline generic & extensible</li>
  </ul>
</Decision>

---

## 4Ô∏è‚É£ Core pipeline steps (order matters)

Selects resolver (AGENT / REGEX / EXACT) from DB.

---

## 5Ô∏è‚É£ Intent resolution for MOVE_CONNECTIONS


### Tables involved

<DbTable name="ce_intent" purpose="Allowed intents">
  <li>intent_code</li>
  <li>priority</li>
  <li>llm_hint</li>
  <li>enabled</li>
</DbTable>

<DbTable name="ce_prompt_template" purpose="Intent prompts">
  <li>purpose = INTENT_AGENT</li>
  <li>system_prompt</li>
  <li>user_prompt</li>
</DbTable>

<DbTable name="ce_output_schema" purpose="Strict JSON control">
  <li>intent_code</li>
  <li>state_code</li>
  <li>json_schema</li>
</DbTable>

The LLM returns structured JSON like:

<SchemaBlock title="Intent agent output">
{`{
  "intent": "MOVE_CONNECTIONS",
  "confidence": 0.92,
  "needsClarification": false,
  "clarificationResolved": false,
  "clarificationQuestion": ""
}`}
</SchemaBlock>

---

## 6Ô∏è‚É£ MCP Tool Step (MOVE_CONNECTIONS only)


<Highlight type="danger">
The FIRST thing MCP does is clear old context.  
If this does not happen, stale answers WILL appear.
</Highlight>

### MCP execution loop

1. MCP_CONTEXT_CLEARED  
2. MCP_PLAN_LLM_INPUT  
3. MCP_PLAN_LLM_OUTPUT  
4. MCP_TOOL_CALL  
5. MCP_TOOL_RESULT  
6. Repeat until MCP_FINAL_ANSWER

---

## 7Ô∏è‚É£ MCP database tools

<DbTable name="ce_mcp_tool" purpose="Tool registry">
  <li>tool_code</li>
  <li>tool_group</li>
  <li>enabled</li>
</DbTable>

<DbTable name="ce_mcp_db_tool" purpose="SQL-backed tools">
  <li>tool_id (FK)</li>
  <li>sql_template</li>
  <li>param_schema</li>
  <li>safe_mode</li>
  <li>max_rows</li>
</DbTable>

Example SQL template:

```sql
select status
from move_request
where connection_id = :connection_id

```

---

## 8Ô∏è‚É£ MCP writes final answer to context

<SchemaBlock title="context_json.mcp">
{`{
  "mcp": {
    "observations": [
      {
        "tool": "postgres.move_status",
        "rowsJson": "[{ status: 'MOVED' }]"
      }
    ],
    "finalAnswer": {
      "answer": "The status of your move is MOVED."
    }
  }
}`}
</SchemaBlock>

---

## 9Ô∏è‚É£ RulesStep - optional short-circuit


Rules can:

* SET_STATE
* SET_INTENT
* SHORT_CIRCUIT

Typical MOVE rule:

* rule_type = JSON_PATH
* match_pattern = `$.mcp.finalAnswer`
* action = SHORT_CIRCUIT

<Highlight type="info">
  <div>
    <div>Customer-specific behavior without code changes</div>
    <br />
    <div>Configurable state machine</div>
    <br />
    <div>Deterministic overrides</div>
  </div>
</Highlight>

---

## üîü ResponseResolutionStep


Uses `ce_response`:

<DbTable name="ce_response" purpose="Final output configuration">
  <li>state_code</li>
  <li>intent_code</li>
  <li>response_type (EXACT / DERIVED)</li>
  <li>output_format (TEXT / JSON)</li>
</DbTable>

### Two valid patterns

<Decision type="success" title="Pattern A - Deterministic">
  <ul>
    <li>Rules SHORT_CIRCUIT</li>
    <li>No LLM call</li>
    <li>Fast & safe</li>
  </ul>
</Decision>

<Decision type="info" title="Pattern B - Derived">
  <ul>
    <li>derivation_hint checks mcp.finalAnswer</li>
    <li>LLM formats response</li>
  </ul>
</Decision>

---

## üêû Debugging: stale move ID bug

If you see:

> Second request returns previous move result

The cause is almost always one of:

<Decision type="danger" title="Root causes">
  <ul>
    <li>MCP context not cleared early enough</li>
    <li>derivation_hint blindly reusing mcp.finalAnswer</li>
    <li>Tool param extraction failed and reused old params</li>
  </ul>
</Decision>

---

## ‚úÖ Final takeaway

ConvEngine MOVE flow is:

* Deterministic
* Auditable
* DB-driven
* MCP-powered
* Safe when configured correctly

If you understand this file,
you understand the MOVE engine end-to-end.

```
