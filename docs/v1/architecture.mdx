---
title: Architecture
sidebar_position: 2
---

import { FlowStep, Highlight, CodeBlockToggle, FileRef, MethodRef } from "@site/src/components/convengine";

# Architecture

## Layers

### API Layer
- <MethodRef>ConversationController</MethodRef>
- request DTO: <MethodRef>ConversationRequest</MethodRef>
- response DTO: <MethodRef>ConversationResponse</MethodRef>

### Engine Layer
- <MethodRef>DefaultConversationalEngine</MethodRef>
- <MethodRef>EnginePipelineFactory</MethodRef> (DAG sort + wrappers + timing + step hooks)
- <MethodRef>EngineSession</MethodRef> (per-turn mutable state)

### Resolver Layer
- intent: classifier + agent + collision resolver
- rules: type/action factories
- response: response type + output format factories
- MCP: planner + registry + DB executor

### Persistence Layer
- JPA repositories on <FileRef>ce_*</FileRef>
- <FileRef>ce_conversation</FileRef> and <FileRef>ce_audit</FileRef> write path

### Transport Layer (configurable)
- SSE stream endpoint
- STOMP/WebSocket publisher

## Request Path (high-level)

<FlowStep step="1" title="Controller receives request">
Builds <MethodRef>EngineContext</MethodRef> from <MethodRef>conversationId</MethodRef>, <MethodRef>message</MethodRef>, <MethodRef>inputParams</MethodRef>, optional <MethodRef>reset</MethodRef> flag.
</FlowStep>

<FlowStep step="2" title="Engine opens session">
<MethodRef>EngineSessionFactory</MethodRef> creates session and history provider injects last turns.
</FlowStep>

<FlowStep step="3" title="Pipeline runs ordered steps">
Each step receives same session instance and may mutate intent/state/context/payload.
</FlowStep>

<FlowStep step="4" title="Persist + return result">
Final payload is persisted and returned as TEXT/JSON response.
</FlowStep>

## Code references

<CodeBlockToggle
  title="Engine entrypoint"
  language="java"
  packagePath="com.github.salilvnair.convengine.engine.provider"
  filePath="src/main/java/com/github/salilvnair/convengine/engine/provider/DefaultConversationalEngine.java"
  defaultOpen={false}
>
{`@Override
public EngineResult process(EngineContext engineContext) {
    EngineSession session = sessionFactory.open(engineContext);
    session.setConversationHistory(historyProvider.lastTurns(session.getConversationId(), 10));
    EnginePipeline pipeline = pipelineFactory.create();
    return pipeline.execute(session);
}`}
</CodeBlockToggle>

<CodeBlockToggle
  title="Pipeline execution loop"
  language="java"
  packagePath="com.github.salilvnair.convengine.engine.pipeline"
  filePath="src/main/java/com/github/salilvnair/convengine/engine/pipeline/EnginePipeline.java"
>
{`for (EngineStep step : steps) {
    StepResult r = step.execute(session);
    if (r instanceof StepResult.Stop(EngineResult result)) {
        return result;
    }
}`}
</CodeBlockToggle>

:::tip Intervention point
You can intercept any step via <MethodRef>EngineStepHook</MethodRef> (<MethodRef>beforeStep</MethodRef>, <MethodRef>afterStep</MethodRef>, <MethodRef>onStepError</MethodRef>) without forking the engine.
:::

<Highlight type="warning" title="DAG-ordering model">
Step order is never hardcoded as a list. It is computed from annotations and validated for cycles/missing dependencies.
</Highlight>
